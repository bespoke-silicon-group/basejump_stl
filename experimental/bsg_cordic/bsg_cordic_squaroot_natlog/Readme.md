# bsg_cordic_squaroot_natlog
This is a Hyperbolic CORDIC based design to compute the square root and natural logarithm of a quantity and returns sqrt(quant_i) and log(quant_i) . `quant_i` is the input to the module and outputs the square root in `squaroot_o` and natural logarithm in `natlog_o`. The default rule for `make` is generating verilog module file with default parameters and **params_def.h** which enables access of the parmeters passed to the script for verilator testing. 

The documentation with more details for all the functions can be found at: https://docs.google.com/document/d/1FMqU0_CAKDEv--3Nw7s5GUfzWhasyPWOG0TNULLdxeE/edit

### Module and Script parameters
Generate the verilog module with **bsg_cordic_squaroot_natlog.py** script which generates the **params_def.h** as well. The following arguments are passed to the script:  

**angbitlen** : Defines the bit-length of the angular ('z' in CORDIC naming) datapath. Has a precision of `precision`  bits and is input to the module. This 'z'-register values represesnt the output of natural logarithm. Choose this carefully to accomodate the angles of the look-up table, maximum input quantity as well as the number of precision bits. While determining this please choose the maximum of bit-length of [2 * theta_max corresponding to the 'm' value in the table below] + 1 sign-bit + number of precision bits or [the bit-length of the constant generated by the script]. In most of the cases the latter will be same or more than the former. Let's explain this with an example. There are two ways of determing bit-lengths, depending upon where you start. If we have a fixed maximum value of say 15784956, then `angbitlen` would be bit-length of [ ln( 15784956 )] + 1 sign bit + number of precision bits + 1 overflow bit. If we have already determined the `negprec` say 6, then `angbitlen` should be bit-length of [ 2 * 15.54462] + 1 sign-bit + number of precision bits + 1 overflow bit. It's highly advised to spare 1-bit for overflow. The maximum input quantity in the testbench is determined by maxquant = exp( 2 * theta_final ) * pow (2 , precision) > (pow(2 , anslen-2) -1)  ? pow(2,anslen-2)-1: exp( 2 * theta_final ) * pow(2 , precision); meaning whichever of the max quantity determined by the below table or the max quantity that n-bits can accomodate in signed representation. We've taken 1-bit for overflow so please add the overflow bit into the the input length to the script accordingly. 


**ansbitlen**: Defines the bit-length of the answer ('x' and 'y' in CORDIC naming) datapath. Also has a precision of 'precision' bits and is output of the square root defined by sqrt(quant_i). A very important consideration while choosing this length is that it should be the maximum of length of either the constant computed in the script by `constant_compute` function or the answer of the next maximum exponent quantity from the table. In the example stated above, if negprec is determined before then `ansbitlen` should be bit-length of [exp(2 * 15.54462)] + 1-sign bit + precision bits + 1 overflow bit. In the  case where we deal with max quantity then `ansbitlen` is equal to bit-length of
 [ 15784956 ] + 1 sign bit + number of precision bits + 1 overflow bit.  
 
**negprec**: Determines the number of iterations in negative direction. These iterations increase the domain of input that can be converged by the module. These come as a part of the extension to the Hyperbolic CORDIC proposed by X.Hu in **"Expanding the range of convergence of the CORDIC algorithm"** in 1991. Choose the number of iterations as determined by the maximum input quantity to the module by the table listed below. In the case of this module, the max quantity is determined by 2*theta_max corresponding to 'm' iterations. For example, in the case of m = 6, the max quantity is sqrt(exp(2 * 15.54462)) in ans register and 2 * 15.54462 in ang register.   

**posprec**: Determines the number of iterations in positive direction which determines the precision of the output. It's advised and observed mathematically to have n-iterations to have a precision of n-bits.  

**precision**: Determines the precision of the output, lookup table as well as the input.  


**startquant_pow**: Determines the bit position to start the input of testing from. If experiencing high error in the lower range of quantities, try increasing this quantity. This can happen due to the fact that there's a large truncation error for the lower quantities because they lose their sense of magnitude in just first few iterations. Adjust this quantity along with the **ansbitlen** to shift the  max error to mid-lower quantities.   


| M      |Max Input Angle  | M     | Max Input Angle    | M|Max Input Angle|
| :---:       |    :----:   |:---: |:---:  | :---:|:---:|
| 0      | 2.09113       | 5   |12.42644 |10|31.48609
| 1   | 3.44515        | 6      |15.54462|
| 2   | 5.16215        |7     |19.00987|
| 3   | 7.23371        | 8     |22.82194|
| 4   | 9.65581        | 9      |26.98070|

### bsg_squaroot_natlog_help.py
This script helps in determining the parameters for the code generation script. It's designed to produce very safe limits for all the bit-lengths so it may not be best optimised. For example, it'll stay in the farmost limit for each 'm' in negative pipeline stages. Like in the case of 15784956, the `negprec` would be 4. Although it cab be represented in 24 bits but the help script will suggest you a bit-length for the max quantity on the boundary of 4 stages i.e exp(2*9.65581) = 243741793.60160324. The `angbitlen` would also be suggested in a similar way. Now one may think that it's sheer wastage of resources but we have to do this to accomodate the constant generated by `constant_compute` function in the script. Please be very very careful in choosing bit-lengths. If not chosen correctly, for all the values beyond pow(2, anslen-1)-1, the result may be wrong either for square root or natural logarithm or for both depending upon which bit-length is wrong. Try not to work on the boundary values of the stages and include at least 1-bit to prevent overflow.  


