// Generated by mbt & ChatGPT o1

`include "bsg_defines.sv"

module bsg_fifo_tracker_variable
  #(parameter `BSG_INV_PARAM(els_p)

    // Maximum number of items that can be enqueued in a single cycle
    , parameter `BSG_INV_PARAM(enq_amount_max_p)

    // Maximum number of items that can be dequeued in a single cycle
    , parameter `BSG_INV_PARAM(deq_amount_max_p)

    // Derived widths from the maximum enqueue/dequeue values.
    // BSG_WIDTH(x) = $clog2(x+1),
    // so if enq_amount_max_p=8, then enq_amount_width_lp=4 bits (covers 0..8).
    , localparam enq_amount_width_lp = `BSG_WIDTH(enq_amount_max_p)
    , localparam deq_amount_width_lp = `BSG_WIDTH(deq_amount_max_p)

    // Pointer width (index into els_p entries). BSG_SAFE_CLOG2(els_p):
    //   e.g., if els_p=128 => ptr_width_lp=7 bits (covers indices 0..127).
    , localparam ptr_width_lp        = `BSG_SAFE_CLOG2(els_p)

    // For counting how many entries are used/free:
    //   BSG_WIDTH(els_p) = $clog2(els_p+1).
    //   e.g., if els_p=128 => used_ptr_width_lp=8 bits, covers 0..128.
    , localparam used_ptr_width_lp   = `BSG_WIDTH(els_p)
  )
  (
    input                               clk_i
    , input                             reset_i

    // Amount to enqueue/dequeue this cycle
    // Widths are derived from enq_amount_max_p / deq_amount_max_p
    , input  [enq_amount_width_lp-1:0]  enq_amount_i
    , input  [deq_amount_width_lp-1:0]  deq_amount_i

    // Current read pointer, write pointer, and next read pointer
    , output [ptr_width_lp-1:0]         wptr_r_o
    , output [ptr_width_lp-1:0]         rptr_r_o
    , output [ptr_width_lp-1:0]         rptr_n_o

    // Registered number of free and used entries in the FIFO
    , output [used_ptr_width_lp-1:0]    free_entries_r_o
    , output [used_ptr_width_lp-1:0]    used_entries_r_o
  );

  // ---------------------------
  // Internal signals
  // ---------------------------
  logic [ptr_width_lp-1:0]         wptr_r;
  logic [ptr_width_lp-1:0]         rptr_r, rptr_n;

  // Number of items currently stored in the FIFO
  logic [used_ptr_width_lp-1:0]    used_entries_r, used_entries_n;

  // Number of free entries in the FIFO
  logic [used_ptr_width_lp-1:0]    free_entries_r, free_entries_n;

  // ---------------------------------------------------------------------------
  // Circular pointer for the READ pointer
  //  - max_add_p = deq_amount_max_p  (no +1)
  // ---------------------------------------------------------------------------
  bsg_circular_ptr #(
    .slots_p   (els_p),
    .max_add_p (deq_amount_max_p)
  ) rptr_circ (
    .clk      (clk_i),
    .reset_i  (reset_i),
    .add_i    (deq_amount_i),
    .o        (rptr_r),
    .n_o      (rptr_n)
  );

  // ---------------------------------------------------------------------------
  // Circular pointer for the WRITE pointer
  //  - max_add_p = enq_amount_max_p  (no +1)
  // ---------------------------------------------------------------------------
  bsg_circular_ptr #(
    .slots_p   (els_p),
    .max_add_p (enq_amount_max_p)
  ) wptr_circ (
    .clk      (clk_i),
    .reset_i  (reset_i),
    .add_i    (enq_amount_i),
    .o        (wptr_r),
    .n_o      ()
  );

  // ---------------------------------------------------------------------------
  // Next‚Äêstate logic for used/free entries
  //
  // IMPORTANT: Externally ensure
  //   enq_amount_i <= free_entries_r
  //   deq_amount_i <= used_entries_r
  // to avoid underflow/overflow.
  // ---------------------------------------------------------------------------
  always_comb begin
    used_entries_n = used_entries_r + enq_amount_i - deq_amount_i;
    free_entries_n = els_p - used_entries_n;
  end

  // ---------------------------------------------------------------------------
  // Update registers
  // ---------------------------------------------------------------------------
  always_ff @(posedge clk_i) begin
    if (reset_i) begin
      used_entries_r <= '0;      // empty at reset => used=0
      free_entries_r <= els_p;   // all free at reset => free=els_p
    end
    else begin
      used_entries_r <= used_entries_n;
      free_entries_r <= free_entries_n;
    end
  end

  // ---------------------------------------------------------------------------
  // Outputs
  // ---------------------------------------------------------------------------
  assign used_entries_r_o = used_entries_r;
  assign free_entries_r_o = free_entries_r;

  assign wptr_r_o         = wptr_r;
  assign rptr_r_o         = rptr_r;
  assign rptr_n_o         = rptr_n;

endmodule

`BSG_ABSTRACT_MODULE(bsg_fifo_tracker_variable)

