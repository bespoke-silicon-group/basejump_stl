diff --git a/bsg_cache/bsg_cache_to_dram_ctrl.v b/bsg_cache/bsg_cache_to_dram_ctrl.v
index 10edc2e3..9005a687 100644
--- a/bsg_cache/bsg_cache_to_dram_ctrl.v
+++ b/bsg_cache/bsg_cache_to_dram_ctrl.v
@@ -12,17 +12,19 @@
 module bsg_cache_to_dram_ctrl
   import bsg_cache_pkg::*;
   import bsg_dmc_pkg::*;
-  #(parameter `BSG_INV_PARAM(num_dma_p)
-    , parameter `BSG_INV_PARAM(dma_addr_width_p)
-    , parameter `BSG_INV_PARAM(dma_data_width_p)
-    , parameter `BSG_INV_PARAM(dma_burst_len_p)
+  #(parameter `BSG_INV_PARAM(num_cache_p)
+    , parameter `BSG_INV_PARAM(addr_width_p)
+    , parameter `BSG_INV_PARAM(data_width_p)
+    , parameter `BSG_INV_PARAM(block_size_in_words_p)
+    
+    , localparam mask_width_lp=(data_width_p>>3)
+    , localparam lg_num_cache_lp=`BSG_SAFE_CLOG2(num_cache_p)
+    , localparam dma_pkt_width_lp=`bsg_cache_dma_pkt_width(addr_width_p)
+
     , parameter `BSG_INV_PARAM(dram_ctrl_burst_len_p)
- 
-    , localparam lg_num_dma_lp=`BSG_SAFE_CLOG2(num_dma_p)
-    , localparam mask_width_lp=(dma_data_width_p>>3)
-    , localparam dma_pkt_width_lp=`bsg_cache_dma_pkt_width(dma_addr_width_p)
+    , parameter dram_ctrl_addr_width_p=(addr_width_p+lg_num_cache_lp)
 
-    , localparam num_req_lp=(dma_burst_len_p/dram_ctrl_burst_len_p)
+    , localparam num_req_lp=(block_size_in_words_p/dram_ctrl_burst_len_p)
   )
   (
     input clk_i
@@ -33,55 +35,79 @@ module bsg_cache_to_dram_ctrl
     , input [2:0] dram_size_i
 
     // cache side
-    , input [dma_pkt_width_lp-1:0] dma_pkt_i
-    , input dma_pkt_v_i
-    , output logic dma_pkt_yumi_o
-    , input [lg_num_dma_lp-1:0] dma_pkt_id_i
+    , input [num_cache_p-1:0][dma_pkt_width_lp-1:0] dma_pkt_i
+    , input [num_cache_p-1:0] dma_pkt_v_i
+    , output logic [num_cache_p-1:0] dma_pkt_yumi_o
 
-    , output logic [dma_data_width_p-1:0] dma_data_o
-    , output logic dma_data_v_o
-    , input dma_data_ready_i
+    , output logic [num_cache_p-1:0][data_width_p-1:0] dma_data_o
+    , output logic [num_cache_p-1:0] dma_data_v_o
+    , input [num_cache_p-1:0] dma_data_ready_i
 
-    , input [dma_data_width_p-1:0] dma_data_i
-    , input dma_data_v_i
-    , output logic dma_data_yumi_o
+    , input [num_cache_p-1:0][data_width_p-1:0] dma_data_i
+    , input [num_cache_p-1:0] dma_data_v_i
+    , output logic [num_cache_p-1:0] dma_data_yumi_o
 
     // dmc side
     , output logic app_en_o
     , input app_rdy_i
     , output app_cmd_e app_cmd_o
-    , output logic [dma_addr_width_p-1:0] app_addr_raw_o
-    , output logic [lg_num_dma_lp-1:0] app_addr_id_o
+    , output logic [dram_ctrl_addr_width_p-1:0] app_addr_o
 
     , output logic app_wdf_wren_o
     , input app_wdf_rdy_i
-    , output logic [dma_data_width_p-1:0] app_wdf_data_o
+    , output logic [data_width_p-1:0] app_wdf_data_o
     , output logic [mask_width_lp-1:0] app_wdf_mask_o
     , output logic app_wdf_end_o
 
     , input app_rd_data_valid_i
-    , input [dma_data_width_p-1:0] app_rd_data_i
+    , input [data_width_p-1:0] app_rd_data_i
     , input app_rd_data_end_i
   );
 
   // round robin for dma pkts
   //
-  `declare_bsg_cache_dma_pkt_s(dma_addr_width_p);
+  `declare_bsg_cache_dma_pkt_s(addr_width_p);
   bsg_cache_dma_pkt_s dma_pkt;
-  assign dma_pkt = dma_pkt_i;
+  logic rr_v_lo;
+  logic [lg_num_cache_lp-1:0] rr_tag_lo;
+  logic rr_yumi_li;
+
+  bsg_round_robin_n_to_1 #(
+    .width_p(dma_pkt_width_lp)
+    ,.num_in_p(num_cache_p)
+    ,.strict_p(0)
+  ) cache_rr (
+    .clk_i(clk_i)
+    ,.reset_i(reset_i)
+    ,.data_i(dma_pkt_i)
+    ,.v_i(dma_pkt_v_i)
+    ,.yumi_o(dma_pkt_yumi_o)
+    ,.v_o(rr_v_lo)
+    ,.data_o(dma_pkt)
+    ,.tag_o(rr_tag_lo)
+    ,.yumi_i(rr_yumi_li)
+  );
+
+  logic [lg_num_cache_lp-1:0] tag_r, tag_n;
 
   // rx module
   //
+  logic rx_v_li;
+  logic rx_ready_lo;
 
   bsg_cache_to_dram_ctrl_rx #(
-    .num_dma_p(num_dma_p)
-    ,.dma_data_width_p(dma_data_width_p)
-    ,.dma_burst_len_p(dma_burst_len_p)
+    .num_cache_p(num_cache_p)
+    ,.data_width_p(data_width_p)
+    ,.block_size_in_words_p(block_size_in_words_p)
     ,.dram_ctrl_burst_len_p(dram_ctrl_burst_len_p)
   ) rx (
     .clk_i(clk_i)
     ,.reset_i(reset_i)
 
+    ,.v_i(rx_v_li)
+    ,.tag_i(tag_r)
+    ,.ready_o(rx_ready_lo)
+
     ,.dma_data_o(dma_data_o)
     ,.dma_data_v_o(dma_data_v_o)
     ,.dma_data_ready_i(dma_data_ready_i)
@@ -93,15 +119,20 @@ module bsg_cache_to_dram_ctrl
 
   // tx module
   //
+  logic tx_v_li;
+  logic tx_ready_lo;
 
   bsg_cache_to_dram_ctrl_tx #(
-    .num_dma_p(num_dma_p)
-    ,.dma_data_width_p(dma_data_width_p)
-    ,.dma_burst_len_p(dma_burst_len_p)
+    .num_cache_p(num_cache_p)
+    ,.data_width_p(data_width_p)
+    ,.block_size_in_words_p(block_size_in_words_p)
     ,.dram_ctrl_burst_len_p(dram_ctrl_burst_len_p)
   ) tx (
     .clk_i(clk_i)
     ,.reset_i(reset_i)
+    ,.v_i(tx_v_li)
+    ,.tag_i(tag_r)
+    ,.ready_o(tx_ready_lo)
     ,.dma_data_i(dma_data_i)
     ,.dma_data_v_i(dma_data_v_i)
     ,.dma_data_yumi_o(dma_data_yumi_o)
@@ -120,27 +151,28 @@ module bsg_cache_to_dram_ctrl
   } req_state_e;
 
   req_state_e req_state_r, req_state_n;
-  logic [dma_addr_width_p-1:0] addr_r, addr_n;
+  logic [addr_width_p-1:0] addr_r, addr_n;
   logic write_not_read_r, write_not_read_n;
   logic [`BSG_SAFE_CLOG2(num_req_lp)-1:0] req_cnt_r, req_cnt_n;
-  logic [lg_num_dma_lp-1:0] tag_r, tag_n;
 
   always_comb begin
     app_en_o = 1'b0;
     app_cmd_o = WR;
-    dma_pkt_yumi_o = 1'b0;
+    rr_yumi_li = 1'b0;
+    tag_n = tag_r;
     write_not_read_n = write_not_read_r;
+    rx_v_li = 1'b0;
+    tx_v_li = 1'b0;
     req_state_n = req_state_r;
     req_cnt_n = req_cnt_r;
     addr_n = addr_r;
-    tag_n = tag_r;
     
     case (req_state_r)
       WAIT: begin
-        if (dma_pkt_v_i) begin
-          dma_pkt_yumi_o = 1'b1;
+        if (rr_v_lo) begin
+          rr_yumi_li = 1'b1;
+          tag_n = rr_tag_lo;
           addr_n = dma_pkt.addr;
-          tag_n = dma_pkt_id_i;
           write_not_read_n = dma_pkt.write_not_read;
           req_cnt_n = '0;
           req_state_n = SEND_REQ;
@@ -148,13 +180,18 @@ module bsg_cache_to_dram_ctrl
       end
 
       SEND_REQ: begin
-        app_en_o = 1'b1;
+        app_en_o = (write_not_read_r
+          ? tx_ready_lo
+          : rx_ready_lo);
         app_cmd_o = write_not_read_r
           ? WR
           : RD;
 
+        rx_v_li = ~write_not_read_r & rx_ready_lo & app_rdy_i;
+        tx_v_li = write_not_read_r & tx_ready_lo & app_rdy_i;
+
         addr_n = (app_rdy_i & app_en_o)
-          ? addr_r + (1 << `BSG_SAFE_CLOG2(dram_ctrl_burst_len_p*dma_data_width_p/8))
+          ? addr_r + (1 << `BSG_SAFE_CLOG2(dram_ctrl_burst_len_p*data_width_p/8))
           : addr_r;
         req_cnt_n = (app_rdy_i & app_en_o)
           ? req_cnt_r + 1
@@ -166,23 +203,32 @@ module bsg_cache_to_dram_ctrl
     endcase
   end
 
-  assign app_addr_raw_o = addr_r;
-  assign app_addr_id_o = tag_r;
+  // Append tag_r to top bits of dram address
+  // tag_r not used when only 1 cache exists
+  always_comb
+    case (dram_size_i)
+      0: app_addr_o = dram_ctrl_addr_width_p'({tag_r, addr_r[25-$clog2(num_cache_p)-1:0]});
+      1: app_addr_o = dram_ctrl_addr_width_p'({tag_r, addr_r[26-$clog2(num_cache_p)-1:0]});
+      2: app_addr_o = dram_ctrl_addr_width_p'({tag_r, addr_r[27-$clog2(num_cache_p)-1:0]});
+      3: app_addr_o = dram_ctrl_addr_width_p'({tag_r, addr_r[28-$clog2(num_cache_p)-1:0]});
+      4: app_addr_o = dram_ctrl_addr_width_p'({tag_r, addr_r[29-$clog2(num_cache_p)-1:0]});
+      default: app_addr_o = {tag_r, addr_r};
+    endcase
 
   // sequential
   //
   always_ff @ (posedge clk_i) begin
     if (reset_i) begin
       req_state_r <= WAIT;
-      addr_r <= '0;
       tag_r <= '0;
+      addr_r <= '0;
       req_cnt_r <= '0;
       write_not_read_r <= 1'b0;
     end
     else begin
       req_state_r <= req_state_n;
-      addr_r <= addr_n;
       tag_r <= tag_n;
+      addr_r <= addr_n;
       req_cnt_r <= req_cnt_n;
       write_not_read_r <= write_not_read_n;
     end
diff --git a/bsg_cache/bsg_cache_to_dram_ctrl_rx.v b/bsg_cache/bsg_cache_to_dram_ctrl_rx.v
index 3d668e69..9f766775 100644
--- a/bsg_cache/bsg_cache_to_dram_ctrl_rx.v
+++ b/bsg_cache/bsg_cache_to_dram_ctrl_rx.v
@@ -8,27 +8,31 @@
 `include "bsg_defines.v"
 
 module bsg_cache_to_dram_ctrl_rx
-  #(parameter `BSG_INV_PARAM(num_dma_p)
-    , parameter `BSG_INV_PARAM(dma_data_width_p)
-    , parameter `BSG_INV_PARAM(dma_burst_len_p)
+  #(parameter `BSG_INV_PARAM(num_cache_p)
+    , parameter `BSG_INV_PARAM(data_width_p)
+    , parameter `BSG_INV_PARAM(block_size_in_words_p)
 
     , parameter `BSG_INV_PARAM(dram_ctrl_burst_len_p)
     
-    , localparam lg_num_dma_lp=`BSG_SAFE_CLOG2(num_dma_p)
+    , localparam lg_num_cache_lp=`BSG_SAFE_CLOG2(num_cache_p)
     , localparam lg_dram_ctrl_burst_len_lp=`BSG_SAFE_CLOG2(dram_ctrl_burst_len_p)
-    , localparam num_req_lp=(dma_burst_len_p/dram_ctrl_burst_len_p)
+    , localparam num_req_lp=(block_size_in_words_p/dram_ctrl_burst_len_p)
   )
   (
     input clk_i
     , input reset_i
 
-    , output logic [dma_data_width_p-1:0] dma_data_o
-    , output logic dma_data_v_o
-    , input dma_data_ready_i
+    , input v_i
+    , input [lg_num_cache_lp-1:0] tag_i
+    , output logic ready_o
+  
+    , output logic [num_cache_p-1:0][data_width_p-1:0] dma_data_o
+    , output logic [num_cache_p-1:0] dma_data_v_o
+    , input [num_cache_p-1:0] dma_data_ready_i
 
     , input app_rd_data_valid_i
     , input app_rd_data_end_i
-    , input [dma_data_width_p-1:0] app_rd_data_i
+    , input [data_width_p-1:0] app_rd_data_i
   );
 
   wire unused = app_rd_data_end_i;
@@ -39,11 +43,11 @@ module bsg_cache_to_dram_ctrl_rx
   //
   logic fifo_v_lo;
   logic fifo_yumi_li;
-  logic [dma_data_width_p-1:0] fifo_data_lo;
+  logic [data_width_p-1:0] fifo_data_lo;
 
   bsg_fifo_1r1w_large #(
-    .width_p(dma_data_width_p)
-    ,.els_p(num_dma_p*dram_ctrl_burst_len_p)
+    .width_p(data_width_p)
+    ,.els_p(num_cache_p*dram_ctrl_burst_len_p)
   ) fifo (
     .clk_i(clk_i)
     ,.reset_i(reset_i)
@@ -57,13 +61,47 @@ module bsg_cache_to_dram_ctrl_rx
     ,.yumi_i(fifo_yumi_li)
   );
 
-  assign fifo_yumi_li = fifo_v_lo & dma_data_ready_i;
+
+  // tag_fifo
+  //
+  logic tag_fifo_v_lo;
+  logic tag_fifo_yumi_li;
+  logic [lg_num_cache_lp-1:0] tag_fifo_data_lo;
+
+  bsg_fifo_1r1w_small #(
+    .width_p(lg_num_cache_lp)
+    ,.els_p(num_cache_p)
+  ) tag_fifo (
+    .clk_i(clk_i)
+    ,.reset_i(reset_i)
+
+    ,.v_i(v_i)
+    ,.ready_o(ready_o)
+    ,.data_i(tag_i)
+
+    ,.v_o(tag_fifo_v_lo)
+    ,.data_o(tag_fifo_data_lo)
+    ,.yumi_i(tag_fifo_yumi_li)
+  ); 
+
+  assign fifo_yumi_li = fifo_v_lo & tag_fifo_v_lo & dma_data_ready_i[tag_fifo_data_lo];
 
   // demux
   //
+  logic [num_cache_p-1:0] cache_sel;
+  
+  bsg_decode_with_v #(
+    .num_out_p(num_cache_p)
+  ) demux (
+    .i(tag_fifo_data_lo)
+    ,.v_i(tag_fifo_v_lo)
+    ,.o(cache_sel)
+  );
 
-  assign dma_data_o = fifo_data_lo;
-  assign dma_data_v_o = fifo_v_lo;
+  for (genvar i = 0; i < num_cache_p; i++) begin
+    assign dma_data_o[i] = fifo_data_lo;
+    assign dma_data_v_o[i] = cache_sel[i] & fifo_v_lo;
+  end
 
   // counter
   //
@@ -87,10 +125,12 @@ module bsg_cache_to_dram_ctrl_rx
     if (count_lo == dram_ctrl_burst_len_p-1) begin
       counter_clear_li = fifo_yumi_li;
       counter_up_li = 1'b0;
+      tag_fifo_yumi_li = fifo_yumi_li;
     end
     else begin
       counter_clear_li = 1'b0;
       counter_up_li = fifo_yumi_li;
+      tag_fifo_yumi_li = 1'b0;
     end
   end
     
diff --git a/bsg_cache/bsg_cache_to_dram_ctrl_tx.v b/bsg_cache/bsg_cache_to_dram_ctrl_tx.v
index 65cb4153..1aa5c6f9 100644
--- a/bsg_cache/bsg_cache_to_dram_ctrl_tx.v
+++ b/bsg_cache/bsg_cache_to_dram_ctrl_tx.v
@@ -9,34 +9,73 @@
 `include "bsg_defines.v"
 
 module bsg_cache_to_dram_ctrl_tx
-  #(parameter `BSG_INV_PARAM(num_dma_p)
-    , parameter `BSG_INV_PARAM(dma_data_width_p)
-    , parameter `BSG_INV_PARAM(dma_burst_len_p)
+  #(parameter `BSG_INV_PARAM(num_cache_p)
+    , parameter `BSG_INV_PARAM(data_width_p)
+    , parameter `BSG_INV_PARAM(block_size_in_words_p)
 
     , parameter `BSG_INV_PARAM(dram_ctrl_burst_len_p)
 
-    , localparam mask_width_lp=(dma_data_width_p>>3)
-    , localparam num_req_lp=(dma_burst_len_p/dram_ctrl_burst_len_p)
-    , localparam lg_num_dma_lp=`BSG_SAFE_CLOG2(num_dma_p)
+    , localparam mask_width_lp=(data_width_p>>3)
+    , localparam num_req_lp=(block_size_in_words_p/dram_ctrl_burst_len_p)
+    , localparam lg_num_cache_lp=`BSG_SAFE_CLOG2(num_cache_p)
     , localparam lg_dram_ctrl_burst_len_lp=`BSG_SAFE_CLOG2(dram_ctrl_burst_len_p)
   )
   (
     input clk_i
     , input reset_i
 
-    , input [dma_data_width_p-1:0] dma_data_i
-    , input dma_data_v_i
-    , output logic dma_data_yumi_o
+    , input v_i
+    , input [lg_num_cache_lp-1:0] tag_i
+    , output logic ready_o
+
+    , input [num_cache_p-1:0][data_width_p-1:0] dma_data_i
+    , input [num_cache_p-1:0] dma_data_v_i
+    , output logic [num_cache_p-1:0] dma_data_yumi_o
 
     , output logic app_wdf_wren_o
-    , output logic [dma_data_width_p-1:0] app_wdf_data_o
+    , output logic [data_width_p-1:0] app_wdf_data_o
     , output logic [mask_width_lp-1:0] app_wdf_mask_o
     , output logic app_wdf_end_o
     , input app_wdf_rdy_i
   );
 
-  assign dma_data_yumi_o = dma_data_v_i & app_wdf_rdy_i;
-  assign app_wdf_wren_o = dma_data_v_i;
+
+  // tag FIFO
+  //
+  logic [lg_num_cache_lp-1:0] tag_fifo_data_lo;
+  logic tag_fifo_v_lo;
+  logic tag_fifo_yumi_li;
+
+  bsg_fifo_1r1w_small #(
+    .width_p(lg_num_cache_lp)
+    ,.els_p(num_cache_p*num_req_lp)
+  ) tag_fifo (
+    .clk_i(clk_i)
+    ,.reset_i(reset_i)
+    
+    ,.v_i(v_i)
+    ,.data_i(tag_i)
+    ,.ready_o(ready_o)
+
+    ,.v_o(tag_fifo_v_lo)
+    ,.data_o(tag_fifo_data_lo)
+    ,.yumi_i(tag_fifo_yumi_li)
+  );
+
+  // demux
+  //
+  logic [num_cache_p-1:0] cache_sel;
+
+  bsg_decode_with_v #(
+    .num_out_p(num_cache_p)
+  ) demux (
+    .i(tag_fifo_data_lo)
+    ,.v_i(tag_fifo_v_lo)
+    ,.o(cache_sel)
+  );
+
+  assign dma_data_yumi_o = cache_sel & dma_data_v_i & {num_cache_p{app_wdf_rdy_i}};
+  assign app_wdf_wren_o = tag_fifo_v_lo & dma_data_v_i[tag_fifo_data_lo];
   
   // burst counter
   //
@@ -57,24 +96,28 @@ module bsg_cache_to_dram_ctrl_tx
     ,.count_o(count_lo)
   );
 
-  wire take_word = app_wdf_wren_o & app_wdf_rdy_i;
+  logic take_word;
+  assign take_word = app_wdf_wren_o & app_wdf_rdy_i;
 
   always_comb begin
     if (count_lo == dram_ctrl_burst_len_p-1) begin
       clear_li = take_word;
       up_li = 1'b0;
       app_wdf_end_o = take_word;
+      tag_fifo_yumi_li = take_word;
     end
     else begin
       clear_li = 1'b0;
       up_li = take_word;
       app_wdf_end_o = 1'b0;
+      tag_fifo_yumi_li = 1'b0;
     end
   end
 
-  assign app_wdf_data_o = dma_data_i;
+  assign app_wdf_data_o = dma_data_i[tag_fifo_data_lo];
   assign app_wdf_mask_o = '0; // negative active! we always write the whole word.
 
+
 endmodule
 
 `BSG_ABSTRACT_MODULE(bsg_cache_to_dram_ctrl_tx)
diff --git a/bsg_cache/bsg_wormhole_to_cache_dma_stream.v b/bsg_cache/bsg_wormhole_to_cache_dma_stream.v
deleted file mode 100644
index f3e43861..00000000
--- a/bsg_cache/bsg_wormhole_to_cache_dma_stream.v
+++ /dev/null
@@ -1,325 +0,0 @@
-/**
- *    bsg_wormhole_to_cache_stream.v
- *
- *    This module converts a bsg_cache_dma wormhole link to an array of bsg_cache_dma interfaces.
- *    It can then be connected to other endpoints such as bsg_cache_to_axi or bsg_cache_to_test_dram.
- *
- */
-
-`include "bsg_defines.v"
-`include "bsg_noc_links.vh"
-`include "bsg_cache.vh"
-
-module bsg_wormhole_to_cache_dma_stream
- import bsg_noc_pkg::*;
- import bsg_cache_pkg::*;
- #(parameter `BSG_INV_PARAM(num_dma_p)
-   , parameter `BSG_INV_PARAM(dma_addr_width_p) // cache addr width (in bytes)
-   , parameter `BSG_INV_PARAM(dma_burst_len_p) // num of data beats in dma transfer
-
-   // flit width must match the cache dma width.
-   , parameter `BSG_INV_PARAM(wh_flit_width_p)
-   , parameter `BSG_INV_PARAM(wh_cid_width_p)
-   , parameter `BSG_INV_PARAM(wh_len_width_p)
-   , parameter `BSG_INV_PARAM(wh_cord_width_p)
-
-   // FIFO parameters
-   , parameter lg_num_dma_lp=`BSG_SAFE_CLOG2(num_dma_p)
-   , parameter count_width_lp=`BSG_SAFE_CLOG2(dma_burst_len_p)
-
-   , parameter wh_ready_and_link_sif_width_lp=`bsg_ready_and_link_sif_width(wh_flit_width_p)
-   , parameter dma_pkt_width_lp=`bsg_cache_dma_pkt_width(dma_addr_width_p)
-   , parameter dma_data_width_p=wh_flit_width_p
-   )
-  (
-    input clk_i
-    , input reset_i
-
-    , input [wh_ready_and_link_sif_width_lp-1:0] wh_link_sif_i
-    , input [lg_num_dma_lp-1:0] wh_dma_id_i
-    , output logic [wh_ready_and_link_sif_width_lp-1:0] wh_link_sif_o
-
-    // cache DMA
-    , output logic [dma_pkt_width_lp-1:0] dma_pkt_o
-    , output logic dma_pkt_v_o
-    , input dma_pkt_yumi_i
-    , output logic [lg_num_dma_lp-1:0] dma_pkt_id_o
-
-    , input [dma_data_width_p-1:0] dma_data_i
-    , input dma_data_v_i
-    , output logic dma_data_ready_and_o
-
-    , output logic [dma_data_width_p-1:0] dma_data_o
-    , output logic dma_data_v_o
-    , input dma_data_yumi_i
-    );
-
-
-  // structs
-  `declare_bsg_ready_and_link_sif_s(wh_flit_width_p,wh_ready_and_link_sif_s);
-  `declare_bsg_cache_dma_pkt_s(dma_addr_width_p);
-  `declare_bsg_cache_wh_header_flit_s(wh_flit_width_p,wh_cord_width_p,wh_len_width_p,wh_cid_width_p);
-
-
-  // cast wormhole links
-  wh_ready_and_link_sif_s wh_link_sif_in;
-  wh_ready_and_link_sif_s wh_link_sif_out;
-  assign wh_link_sif_in = wh_link_sif_i;
-  assign wh_link_sif_o = wh_link_sif_out;
-
-  // DMA pkt going out
-  bsg_cache_dma_pkt_s dma_pkt_out;
-  assign dma_pkt_o = dma_pkt_out;
-
-  // header flits coming in and going out
-  bsg_cache_wh_header_flit_s header_flit_in, header_flit_out;
-  assign header_flit_in = wh_link_sif_in.data;
-
-  // send FSM
-  // receives wh packets and cache dma pkts.
-  typedef enum logic [1:0] {
-    SEND_RESET,
-    SEND_READY,
-    SEND_DMA_PKT,
-    SEND_EVICT_DATA
-  } send_state_e;
-
-  send_state_e send_state_r, send_state_n;
-  logic write_not_read_r, write_not_read_n;
-  logic [lg_num_dma_lp-1:0] send_cache_id_r, send_cache_id_n;
-
-  logic send_clear_li;
-  logic send_up_li;
-  logic [count_width_lp-1:0] send_count_lo;
-  bsg_counter_clear_up #(
-    .max_val_p(dma_burst_len_p-1)
-    ,.init_val_p(0)
-  ) send_count (
-    .clk_i(clk_i)
-    ,.reset_i(reset_i)
-    ,.clear_i(send_clear_li)
-    ,.up_i(send_up_li)
-    ,.count_o(send_count_lo)
-  );
-
-  logic [wh_cord_width_p-1:0] src_cord_li, src_cid_li;
-  logic src_fifo_ready_lo, src_fifo_v_li;
-  logic [wh_cid_width_p-1:0] src_cord_lo, src_cid_lo;
-  logic src_fifo_v_lo, src_fifo_yumi_li;
-  bsg_fifo_1r1w_small #(
-    .width_p(wh_cord_width_p+wh_cid_width_p)
-    ,.els_p(num_dma_p)
-  ) src_fifo (
-    .clk_i(clk_i)
-    ,.reset_i(reset_i)
-
-    ,.data_i({src_cid_li, src_cord_li})
-    ,.v_i(src_fifo_v_li)
-    ,.ready_o(src_fifo_ready_lo)
-
-    ,.data_o({src_cid_lo, src_cord_lo})
-    ,.v_o(src_fifo_v_lo)
-    ,.yumi_i(src_fifo_yumi_li)
-  );
-
-  always_comb begin
-    send_state_n = send_state_r;
-    write_not_read_n = write_not_read_r;
-    send_cache_id_n = send_cache_id_r;
-    src_cord_li = '0;
-    src_cid_li = '0;
-    src_fifo_v_li = '0;
-
-    wh_link_sif_out.ready_and_rev = 1'b0;
-
-    send_clear_li = 1'b0;
-    send_up_li = 1'b0;
-    dma_pkt_v_o = '0;
-    dma_pkt_out = '0;
-    dma_pkt_id_o = '0;
-
-    dma_data_v_o = '0;
-    dma_data_o = '0;
-
-    case (send_state_r)
-      // coming out of reset
-      SEND_RESET: begin
-        send_state_n = SEND_READY;
-      end
-
-      // wait for a header flit.
-      // store the write_not_read, src_cord.
-      // save the cord and cid in a fifo.
-      SEND_READY: begin
-        wh_link_sif_out.ready_and_rev = src_fifo_ready_lo;
-        if (wh_link_sif_out.ready_and_rev & wh_link_sif_in.v) begin
-          write_not_read_n = header_flit_in.write_not_read;
-          src_cord_li = header_flit_in.src_cord;
-          src_cid_li = header_flit_in.src_cid;
-          src_fifo_v_li = 1'b1;
-          send_cache_id_n = wh_dma_id_i;
-          send_state_n = SEND_DMA_PKT;
-        end
-      end
-
-      // take the addr flit and send out the dma pkt.
-      // For read, return to SEND_READY.
-      // For write, move to SEND_EVICT_DATA to pass the evict data.
-      SEND_DMA_PKT: begin
-        dma_pkt_v_o = wh_link_sif_in.v;
-        dma_pkt_out.write_not_read = write_not_read_r;
-        dma_pkt_out.addr = dma_addr_width_p'(wh_link_sif_in.data);
-        dma_pkt_id_o = send_cache_id_r;
-
-        wh_link_sif_out.ready_and_rev = dma_pkt_yumi_i;
-        send_state_n = wh_link_sif_out.ready_and_rev
-          ? (write_not_read_r ? SEND_EVICT_DATA : SEND_READY)
-          : SEND_DMA_PKT;
-      end
-
-      // once all evict data has been passed along return to SEND_READY
-      SEND_EVICT_DATA: begin
-        dma_data_v_o = wh_link_sif_in.v;
-        dma_data_o = wh_link_sif_in.data;
-        if (dma_data_yumi_i) begin
-          wh_link_sif_out.ready_and_rev = 1'b1;
-          send_up_li = send_count_lo != dma_burst_len_p-1;
-          send_clear_li = send_count_lo == dma_burst_len_p-1;
-          send_state_n = send_clear_li
-            ? SEND_READY
-            : SEND_EVICT_DATA;
-        end
-      end
-
-    endcase
-
-  end
-
-
-
-  always_ff @ (posedge clk_i) begin
-    if (reset_i) begin
-      send_state_r <= SEND_RESET;
-      write_not_read_r <= 1'b0;
-      send_cache_id_r <= '0;
-    end
-    else begin
-      send_state_r <= send_state_n;
-      write_not_read_r <= write_not_read_n;
-      send_cache_id_r <= send_cache_id_n;
-    end
-  end
-
-
-
-  // receiver FSM
-  // receives dma_data_i and send them to the vcaches using wh link.
-  typedef enum logic [1:0] {
-    RECV_RESET,
-    RECV_HEADER,
-    RECV_FILL_DATA
-  } recv_state_e;
-
-  recv_state_e recv_state_r, recv_state_n;
-
-
-
-  logic recv_clear_li;
-  logic recv_up_li;
-  logic [count_width_lp-1:0] recv_count_lo;
-  bsg_counter_clear_up #(
-    .max_val_p(dma_burst_len_p-1)
-    ,.init_val_p(0)
-  ) recv_count (
-    .clk_i(clk_i)
-    ,.reset_i(reset_i)
-    ,.clear_i(recv_clear_li)
-    ,.up_i(recv_up_li)
-    ,.count_o(recv_count_lo)
-  );
-
-
-
-
-  always_comb begin
-
-    wh_link_sif_out.v = 1'b0;
-    wh_link_sif_out.data = '0;
-
-    recv_state_n = recv_state_r;
-
-    recv_clear_li = 1'b0;
-    recv_up_li = 1'b0;
-
-    header_flit_out.unused = '0;
-    header_flit_out.write_not_read = 1'b0; // doesn't matter
-    header_flit_out.src_cord = '0; // doesn't matter
-    header_flit_out.src_cid = '0; // doesn't matter
-    header_flit_out.len = dma_burst_len_p;
-    header_flit_out.cord = src_cord_lo;
-    header_flit_out.cid = src_cid_lo;
-
-    src_fifo_yumi_li = '0;
-
-    dma_data_ready_and_o = '0;
-
-    case (recv_state_r)
-
-      // coming out of reset
-      RECV_RESET: begin
-        recv_state_n = RECV_HEADER;
-      end
-
-      // Wait for dma_data_v_i to be 1.
-      // send out header to dest vcache
-      RECV_HEADER: begin
-        wh_link_sif_out.v = dma_data_v_i & src_fifo_v_lo;
-        wh_link_sif_out.data = header_flit_out;
-        if (wh_link_sif_in.ready_and_rev & wh_link_sif_out.v) begin
-          src_fifo_yumi_li = 1'b1;
-          recv_state_n = RECV_FILL_DATA;
-        end
-      end
-
-      // send the data flits to the vcache.
-      // once it's done, go back to RECV_HEADER.
-      RECV_FILL_DATA: begin
-        wh_link_sif_out.v = dma_data_v_i;
-        wh_link_sif_out.data = dma_data_i;
-        dma_data_ready_and_o = wh_link_sif_in.ready_and_rev;
-        if (dma_data_ready_and_o & dma_data_v_i) begin
-          recv_clear_li = (recv_count_lo == dma_burst_len_p-1);
-          recv_up_li = (recv_count_lo != dma_burst_len_p-1);
-          recv_state_n = recv_clear_li
-            ? RECV_HEADER
-            : RECV_FILL_DATA;
-        end
-      end
-
-    endcase
-  end
-
-
-  // synopsys sync_set_reset "reset_i"
-  always_ff @ (posedge clk_i) begin
-    if (reset_i) begin
-      recv_state_r <= RECV_RESET;
-    end
-    else begin
-      recv_state_r <= recv_state_n;
-    end
-  end
-
-  //synopsys translate_off
-  if (wh_flit_width_p != dma_data_width_p)
-    $error("WH flit width must be equal to DMA data width");
-  if (wh_flit_width_p < dma_addr_width_p)
-    $error("WH flit width must be larger than address width");
-  if (wh_len_width_p < `BSG_WIDTH(dma_burst_len_p+1))
-    $error("WH len width %d must be large enough to hold the dma transfer size %d", wh_len_width_p, `BSG_WIDTH(dma_burst_len_p+1));
-  //synopsys translate_on
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_wormhole_to_cache_dma_stream)
-
diff --git a/bsg_clk_gen/bsg_dly_line.v b/bsg_clk_gen/bsg_dly_line.v
index 3602bbea..f4f8bfd4 100644
--- a/bsg_clk_gen/bsg_dly_line.v
+++ b/bsg_clk_gen/bsg_dly_line.v
@@ -44,32 +44,29 @@ module bsg_dly_line
    bsg_clk_gen_osc_tag_payload_s fb_tag_r;
    wire  fb_we_r;
 
-   // note: delay line has to be already working in order
+   // note: oscillator has to be already working in order
    // for configuration state to pass through here
 
-   bsg_tag_client_unsync
-     #(.width_p($bits(bsg_clk_gen_osc_tag_payload_s))
-       ,.harden_p(1)
-       ) btc
-       (.bsg_tag_i(bsg_tag_i)
-        ,.data_async_r_o(fb_tag_r)
-        );
-
-   bsg_tag_client_unsync
-     #(.width_p(1)
-       ,.harden_p(1)
-       ) btc_trigger
-       (.bsg_tag_i(bsg_tag_trigger_i)
-        ,.data_async_r_o(fb_we_r)
-        );
+   bsg_tag_client #(.width_p($bits(bsg_clk_gen_osc_tag_payload_s))
+                    ,.harden_p(1)
+                    ) btc
+     (.bsg_tag_i     (bsg_tag_i)
+      ,.recv_clk_i   (clk_o)
+      ,.recv_new_r_o (fb_we_r)  // default is already in OSC flops
+      ,.recv_data_r_o(fb_tag_r)
+      );
 
    wire [1:0] cdt = fb_tag_r.cdt;
    wire [1:0] fdt = fb_tag_r.fdt;
    wire [num_adgs_p-1:0] adg_ctrl = fb_tag_r.adg;
 
    logic [4+num_adgs_p-1:0] ctrl_rrr;
-   always @(posedge fb_we_r)
-     ctrl_rrr <= {adg_ctrl, cdt, fdt};
+   always @(clk_o or async_reset_i)
+     if (async_reset_i)
+       ctrl_rrr <= '0;
+     else
+       if (fb_we_r)
+         ctrl_rrr <= {adg_ctrl, cdt, fdt};
 
    always
      begin
diff --git a/bsg_dmc/bsg_dmc.v b/bsg_dmc/bsg_dmc.v
index 17b7c33f..7e1bc975 100644
--- a/bsg_dmc/bsg_dmc.v
+++ b/bsg_dmc/bsg_dmc.v
@@ -4,7 +4,6 @@ module bsg_dmc
   import bsg_tag_pkg::*;
   import bsg_dmc_pkg::*;
  #(parameter  num_adgs_p         = 1
-  ,parameter  ds_width_p         = 2
   ,parameter `BSG_INV_PARAM( ui_addr_width_p    )
   ,parameter `BSG_INV_PARAM( ui_data_width_p    ) // data width of UI interface, can be 2^n while n = [3, log2(burst_data_width_p)]
   ,parameter `BSG_INV_PARAM( burst_data_width_p ) // data width of an outstanding read/write transaction, typically data width of a cache line
@@ -16,13 +15,15 @@ module bsg_dmc
   ,localparam dfi_mask_width_lp  = (dq_data_width_p >> 3) << 1
   ,localparam dq_group_lp        = dq_data_width_p >> 3)
   // Tag lines
-  (
-  input bsg_dmc_dly_tag_lines_s 	 dly_tag_lines_i
-  ,input bsg_dmc_cfg_tag_lines_s 	 cfg_tag_lines_i
-  ,input bsg_dmc_sys_tag_lines_s 	 sys_tag_lines_i
-  ,input bsg_dmc_osc_tag_lines_s 	 osc_tag_lines_i
+  (input bsg_tag_s                   async_reset_tag_i
+  ,input bsg_tag_s [dq_group_lp-1:0] bsg_dly_tag_i
+  ,input bsg_tag_s [dq_group_lp-1:0] bsg_dly_trigger_tag_i
+  ,input bsg_tag_s                   bsg_ds_tag_i
+  // 
+  ,input bsg_dmc_s                   dmc_p_i
   // Global asynchronous reset input, will be synchronized to each clock domain
   // Consistent with the reset signal defined in Xilinx UI interface
+  ,input                             sys_reset_i
   // User interface signals
   ,input       [ui_addr_width_p-1:0] app_addr_i
   ,input app_cmd_e                   app_cmd_i
@@ -45,10 +46,6 @@ module bsg_dmc
   ,output                            app_sr_active_o
   // Status signal
   ,output                            init_calib_complete_o
-  ,output logic                      transaction_in_progress_o
-  ,output logic                      stall_transactions_o
-  ,output logic						 refresh_in_progress_o
-  ,output logic                      test_mode_o
   // DDR interface signals
   // Physically compatible with (LP)DDR3/DDR2/DDR, but only (LP)DDR
   // protocal is logically implemented in the controller
@@ -80,21 +77,17 @@ module bsg_dmc
   ,input       [dq_data_width_p-1:0] ddr_dq_i
   // Clock interface signals
   ,input                             ui_clk_i
+  ,input                             dfi_clk_2x_i
+  ,output                            dfi_clk_1x_o
   //
   ,output                            ui_clk_sync_rst_o
-  ,input                             ext_dfi_clk_2x_i
-  ,output                            dfi_clk_2x_o
-  ,output                            dfi_clk_1x_o
-  ,output          [dq_group_lp-1:0] dqs_clk_o
-  ,output          [dq_group_lp-1:0] dqs_clk_dly_o
   // Reserved to be compatible with Xilinx IPs
   ,output                     [11:0] device_temp_o
 );
 
   wire                               dfi_clk_1x_lo;
-  wire								 async_reset;
-  wire								 dfi_clk_2x_lo;
 
+  wire                               sys_reset;
   wire                               ui_reset;
   wire                               dfi_reset;
 
@@ -117,44 +110,37 @@ module bsg_dmc
 
   wire             [dq_group_lp-1:0] dqs_p_li;
 
-  bsg_dmc_s 						 dmc_p_lo;
   assign device_temp_o = 12'd0;
 
-  assign dfi_clk_2x_o  = dfi_clk_2x_lo;
-  assign dfi_clk_1x_o  = dfi_clk_1x_lo;
-  assign dqs_clk_o     = ddr_dqs_p_i;
-  assign dqs_clk_dly_o = dqs_p_li;
-  
-  bsg_dmc_sys_cfg_gen
-					dmc_sys_cfg_gen
-					(
-                    .cfg_tag_lines_i(cfg_tag_lines_i)
-                    ,.sys_tag_lines_i(sys_tag_lines_i)
-					,.dfi_clk_1x_i(dfi_clk_1x_lo)
-					,.dmc_p_o(dmc_p_lo)
-					,.async_reset_o(async_reset)
-					,.stall_transactions_o(stall_transactions_o)
-					,.test_mode_o(test_mode_o)
-					);
-					 
   bsg_dmc_clk_rst_gen #
     (.num_adgs_p  ( num_adgs_p  )
-    ,.ds_width_p  ( ds_width_p  )
-    ,.dq_groups_p ( dq_group_lp ))
+    ,.num_lines_p ( dq_group_lp ))
   dmc_clk_rst_gen
     // tag lines
-    (
-     .dly_tag_lines_i       ( dly_tag_lines_i       )
-    ,.osc_tag_lines_i       ( osc_tag_lines_i       )
-    ,.dqs_clk_i             ( ddr_dqs_p_i           )
-    ,.dqs_clk_o             ( dqs_p_li              )
-    ,.ext_dfi_clk_2x_i      ( ext_dfi_clk_2x_i      )
-    ,.ui_clk_i              ( ui_clk_i              )
-    ,.ui_reset_o            ( ui_reset              )
-    ,.async_reset_i         ( async_reset           )
-    ,.dfi_reset_o           ( dfi_reset             )
-    ,.dfi_clk_2x_o          ( dfi_clk_2x_lo         )
-    ,.dfi_clk_1x_o          ( dfi_clk_1x_lo         ));
+    (.async_reset_tag_i     ( async_reset_tag_i     )
+    ,.bsg_dly_tag_i         ( bsg_dly_tag_i         )
+    ,.bsg_dly_trigger_tag_i ( bsg_dly_trigger_tag_i )
+    ,.bsg_ds_tag_i          ( bsg_ds_tag_i          )
+
+    ,.async_reset_o         ( sys_reset             )
+
+    ,.clk_i                 ( ddr_dqs_p_i           )
+    ,.clk_o                 ( dqs_p_li              )
+
+    ,.clk_2x_i              ( dfi_clk_2x_i          )
+    ,.clk_1x_o              ( dfi_clk_1x_lo         ));
+
+  assign dfi_clk_1x_o = dfi_clk_1x_lo;
+
+  bsg_sync_sync #(.width_p(1)) ui_reset_inst
+    (.oclk_i      ( ui_clk_i    )
+    ,.iclk_data_i ( sys_reset_i )
+    ,.oclk_data_o ( ui_reset    ));
+
+  bsg_sync_sync #(.width_p(1)) dfi_reset_inst
+    (.oclk_i      ( dfi_clk_1x_lo   )
+    ,.iclk_data_i ( sys_reset_i     )
+    ,.oclk_data_o ( dfi_reset       ));
 
   assign ui_clk_sync_rst_o = ui_reset;
 
@@ -169,9 +155,6 @@ module bsg_dmc
     // User interface clock and reset
     (.ui_clk_i              ( ui_clk_i              )
     ,.ui_clk_sync_rst_i     ( ui_reset              )
-	,.stall_transactions_i  (stall_transactions_o   )
-	,.refresh_in_progress_o (refresh_in_progress_o  )
-	,.transaction_in_progress_o (transaction_in_progress_o )
     // User interface signals
     ,.app_addr_i            ( app_addr_i            )
     ,.app_cmd_i             ( app_cmd_i             )
@@ -211,14 +194,14 @@ module bsg_dmc
     ,.dfi_rddata_i          ( dfi_rddata            )
     ,.dfi_rddata_valid_i    ( dfi_rddata_valid      )
     // Control and Status Registers
-    ,.dmc_p_i               ( dmc_p_lo               )
+    ,.dmc_p_i               ( dmc_p_i               )
     //
     ,.init_calib_complete_o ( init_calib_complete_o ));
 
   bsg_dmc_phy #(.dq_data_width_p(dq_data_width_p)) phy
     // DDR PHY interface clock and reset
     (.dfi_clk_1x_i        ( dfi_clk_1x_lo       )
-    ,.dfi_clk_2x_i        ( dfi_clk_2x_lo        )
+    ,.dfi_clk_2x_i        ( dfi_clk_2x_i        )
     ,.dfi_rst_i           ( dfi_reset           )
     // DFI interface signals
     ,.dfi_bank_i          ( dfi_bank            )
@@ -262,7 +245,7 @@ module bsg_dmc
     ,.dq_o                ( ddr_dq_o            )
     ,.dq_i                ( ddr_dq_i            )
     // Control and Status Registers
-    ,.dqs_sel_cal         ( dmc_p_lo.dqs_sel_cal ));
+    ,.dqs_sel_cal         ( dmc_p_i.dqs_sel_cal ));
 
 endmodule
 
diff --git a/bsg_dmc/bsg_dmc.vh b/bsg_dmc/bsg_dmc.vh
index 0b35f175..ddf32146 100644
--- a/bsg_dmc/bsg_dmc.vh
+++ b/bsg_dmc/bsg_dmc.vh
@@ -1,36 +1,14 @@
+
 `ifndef BSG_DMC_VH
 `define BSG_DMC_VH
 
   `include "bsg_defines.v"
 
-  // app_cmd_e for each command or data
-  // payload can be write data or additional commands
-  // addr width <= data+mask width. these zeros are padded for cmd trace payloads.
- `define declare_bsg_dmc_trace_entry_s(data_width_mp, addr_width_mp) \
-  	typedef struct packed { \
-      app_cmd_e app_cmd; \
-  	  union packed { \
-        struct packed { \
-          logic [data_width_mp+(data_width_mp>>3)-addr_width_mp-1:0] pad; \
-  	      logic [addr_width_mp - 1:0] addr; \
-        } cmd; \
-        struct packed { \
-          logic [(data_width_mp>>3) - 1:0] mask; \
-          logic [data_width_mp - 1:0] data; \
-        } wdata; \
-      } payload; \
-    } bsg_dmc_trace_entry_s;
-
   `define declare_app_cmd_afifo_entry_s(addr_width_mp) \
     typedef struct packed {           \
       app_cmd_e cmd;                  \
       logic [addr_width_mp-1:0] addr; \
     } app_cmd_afifo_entry_s;
 
-  `define bsg_dmc_trace_entry_width(data_width_mp, addr_width_mp) \
-    ($bits(app_cmd_e)+data_width_mp+(data_width_mp>>3))
-
-  `define app_cmd_afifo_entry_width(addr_width_mp) \
-    ($bits(app_cmd_e)+addr_width_mp)
-
 `endif
+
diff --git a/bsg_dmc/bsg_dmc_clk_rst_gen.v b/bsg_dmc/bsg_dmc_clk_rst_gen.v
index a093d39e..561acfba 100644
--- a/bsg_dmc/bsg_dmc_clk_rst_gen.v
+++ b/bsg_dmc/bsg_dmc_clk_rst_gen.v
@@ -4,47 +4,41 @@
 
 module bsg_dmc_clk_rst_gen
   import bsg_tag_pkg::bsg_tag_s;
-  import bsg_dmc_pkg::*;
  #(parameter num_adgs_p         = 2
-  ,parameter ds_width_p         = 2
-  ,parameter `BSG_INV_PARAM(dq_groups_p        ))
-  (
-  input bsg_dmc_dly_tag_lines_s         dly_tag_lines_i
-  ,input bsg_dmc_osc_tag_lines_s        osc_tag_lines_i    
+  ,parameter `BSG_INV_PARAM(num_lines_p        ))
+  (input bsg_tag_s                   async_reset_tag_i
+  ,input bsg_tag_s [num_lines_p-1:0] bsg_dly_tag_i
+  ,input bsg_tag_s [num_lines_p-1:0] bsg_dly_trigger_tag_i
+  ,input bsg_tag_s                   bsg_ds_tag_i
+  // asynchronous reset for dram controller
+  ,output                            async_reset_o
   // clock input and delayed clock output (for dqs), generating 90-degree phase
   // shift
-  ,input           [dq_groups_p-1:0]    dqs_clk_i
-  ,output          [dq_groups_p-1:0]    dqs_clk_o
+  ,input           [num_lines_p-1:0] clk_i
+  ,output          [num_lines_p-1:0] clk_o
   // 2x clock input from clock generator and 1x clock output
-  //
-  ,input                                ext_dfi_clk_2x_i
-  ,input                                ui_clk_i
-  ,input                                async_reset_i
-  ,output                               ui_reset_o
-  ,output                               dfi_reset_o
-  ,output                               dfi_clk_2x_o
-  ,output                               dfi_clk_1x_o);
+  ,input                             clk_2x_i
+  ,output                            clk_1x_o);
 
   localparam debug_level_lp = 0;
 
   genvar i;
 
-  logic dly_async_reset_r;
   bsg_tag_client_unsync #(.width_p(1)) btc_async_reset
-    (.bsg_tag_i      ( dly_tag_lines_i.async_reset )
-    ,.data_async_r_o ( dly_async_reset_r     ));
+    (.bsg_tag_i      ( async_reset_tag_i )
+    ,.data_async_r_o ( async_reset_o     ));
 
   // Clock Generator (CG) Instance
-  for(i=0;i<dq_groups_p;i++) begin: dly_lines
+  for(i=0;i<num_lines_p;i++) begin: dly_lines
     bsg_dly_line #(.num_adgs_p(num_adgs_p)) dly_line_inst
-      (.bsg_tag_i         ( dly_tag_lines_i.dly[i]         )
-      ,.bsg_tag_trigger_i ( dly_tag_lines_i.dly_trigger[i] )
-      ,.async_reset_i     ( dly_async_reset_r            )
-      ,.clk_i             ( dqs_clk_i[i]                 )
-      ,.clk_o             ( dqs_clk_o[i]                 ));
+      (.bsg_tag_i         ( bsg_dly_tag_i[i]         )
+      ,.bsg_tag_trigger_i ( bsg_dly_trigger_tag_i[i] )
+      ,.async_reset_i     ( async_reset_o            )
+      ,.clk_i             ( clk_i[i]                 )
+      ,.clk_o             ( clk_o[i]                 ));
   end
 
-  `declare_bsg_clk_gen_ds_tag_payload_s(ds_width_p)
+  `declare_bsg_clk_gen_ds_tag_payload_s(2)
 
   bsg_clk_gen_ds_tag_payload_s ds_tag_payload_r;
 
@@ -56,14 +50,14 @@ module bsg_dmc_clk_rst_gen
     (.width_p   ( $bits(bsg_clk_gen_ds_tag_payload_s) )
     ,.harden_p  ( 1                                   ))
   btc_ds
-    (.bsg_tag_i     ( dly_tag_lines_i.ds              )
+    (.bsg_tag_i     ( bsg_ds_tag_i         )
 
-    ,.recv_clk_i    ( dfi_clk_2x_o             )
+    ,.recv_clk_i    ( clk_2x_i             )
     ,.recv_new_r_o  ( ds_tag_payload_new_r )   // we don't require notification
     ,.recv_data_r_o ( ds_tag_payload_r     ));
 
   if (debug_level_lp > 1)
-  always_ff @(negedge dfi_clk_2x_o) begin
+  always_ff @(negedge clk_2x_i) begin
     if (ds_tag_payload_new_r)
       $display("## bsg_clk_gen downsampler received configuration state: %b",ds_tag_payload_r);
   end
@@ -74,55 +68,15 @@ module bsg_dmc_clk_rst_gen
   // we can turn it off by holding reset high to save power.
   //
   bsg_counter_clock_downsample #
-    (.width_p  ( ds_width_p )
+    (.width_p  ( 2 )
     ,.harden_p ( 1 ))
   clk_gen_ds_inst
-    (.clk_i   ( dfi_clk_2x_o               )
+    (.clk_i   ( clk_2x_i               )
     ,.reset_i ( ds_tag_payload_r.reset )
-    ,.val_i   ( ds_tag_payload_r.val   )
-    ,.clk_r_o ( dfi_clk_1x_o               ));
-
-  logic osc_async_reset_r;
-
-  bsg_tag_client_unsync #( .width_p(1) )
-    osc_async_reset
-      (.bsg_tag_i(osc_tag_lines_i.async_reset)
-      ,.data_async_r_o(osc_async_reset_r)
-      );
-
-  logic [1:0] sel_tag_payload_r;
-
-  bsg_tag_client_unsync #( .width_p(2) )
-    osc_sel
-      (.bsg_tag_i(osc_tag_lines_i.sel)
-      ,.data_async_r_o(sel_tag_payload_r)
-      );
-
-  bsg_clk_gen #(.downsample_width_p(ds_width_p)
-               ,.num_adgs_p(num_adgs_p)
-               ,.version_p(2)
-               )
-  clk_gen_inst
-      (.async_osc_reset_i     (osc_async_reset_r)
-      ,.bsg_osc_tag_i         (osc_tag_lines_i.osc)
-      ,.bsg_osc_trigger_tag_i (osc_tag_lines_i.osc_trigger)
-      ,.bsg_ds_tag_i          (osc_tag_lines_i.ds)
-      ,.ext_clk_i             (ext_dfi_clk_2x_i)
-      ,.select_i              (sel_tag_payload_r)
-      ,.clk_o                 (dfi_clk_2x_o)
-      );
-
-  bsg_sync_sync #(.width_p(1)) ui_reset_inst
-    (.oclk_i      ( ui_clk_i      )
-    ,.iclk_data_i ( async_reset_i )
-    ,.oclk_data_o ( ui_reset_o    ));
-
-  bsg_sync_sync #(.width_p(1)) dfi_reset_inst
-    (.oclk_i      ( dfi_clk_1x_o      )
-    ,.iclk_data_i ( async_reset_i     )
-    ,.oclk_data_o ( dfi_reset_o       ));
-
+    ,.val_i   ( 2'd0                   )
+    ,.clk_r_o ( clk_1x_o               ));
 
 endmodule
 
 `BSG_ABSTRACT_MODULE(bsg_dmc_clk_rst_gen)
+
diff --git a/bsg_dmc/bsg_dmc_controller.v b/bsg_dmc/bsg_dmc_controller.v
index fb1774cd..7dc737fc 100644
--- a/bsg_dmc/bsg_dmc_controller.v
+++ b/bsg_dmc/bsg_dmc_controller.v
@@ -15,10 +15,6 @@ module bsg_dmc_controller
   // User interface clock and reset
   (input                                ui_clk_i
   ,input                                ui_clk_sync_rst_i
-
-  ,input								stall_transactions_i
-  ,output logic							refresh_in_progress_o
-  ,output logic                         transaction_in_progress_o
   // User interface signals
   ,input          [ui_addr_width_p-1:0] app_addr_i
   ,input app_cmd_e                      app_cmd_i
@@ -326,9 +322,9 @@ module bsg_dmc_controller
       refr_tick <= 0;
     else if(cstate == IDLE && nstate == REFR) begin
       if(|open_bank)
-        refr_tick <= 2;
-      else
         refr_tick <= 1;
+      else
+        refr_tick <= 0;
     end
     else if(cstate == REFR && refr_tick != 0 && push)
       refr_tick <= refr_tick - 1;
@@ -339,11 +335,11 @@ module bsg_dmc_controller
       ldst_tick <= 0;
     else if(cstate == IDLE && nstate == LDST) begin
       if(open_bank[bank_addr] && open_row[bank_addr] == row_addr)
-        ldst_tick <= 1;
+        ldst_tick <= 0;
       else if(open_bank[bank_addr])
-        ldst_tick <= 3;
-      else
         ldst_tick <= 2;
+      else
+        ldst_tick <= 1;
     end
     else if(cstate == LDST && ldst_tick != 0 && push)
       ldst_tick <= ldst_tick - 1;
@@ -356,29 +352,27 @@ module bsg_dmc_controller
       INIT: begin
         push = cmd_sfifo_ready;
         case(init_tick)
-          'd5: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.addr = 16'h400; end
-          'd4: begin cmd_sfifo_wdata.cmd = REF; cmd_sfifo_wdata.addr = 16'h0; end
+          'd4: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.addr = 16'h400; end
           'd3: begin cmd_sfifo_wdata.cmd = REF; cmd_sfifo_wdata.addr = 16'h0; end
-          'd2: begin cmd_sfifo_wdata.cmd = LMR; cmd_sfifo_wdata.addr = {8'h0, dmc_p_i.tcas, 4'($clog2(dfi_burst_length_lp << 1))}; cmd_sfifo_wdata.ba = 4'h0; end
-          'd1: begin cmd_sfifo_wdata.cmd = LMR; cmd_sfifo_wdata.addr = 16'h0; cmd_sfifo_wdata.ba = 4'h2; end
-          'd0: begin cmd_sfifo_wdata.cmd = NOP; end
+          'd2: begin cmd_sfifo_wdata.cmd = REF; cmd_sfifo_wdata.addr = 16'h0; end
+          'd1: begin cmd_sfifo_wdata.cmd = LMR; cmd_sfifo_wdata.addr = {8'h0, dmc_p_i.tcas, 4'($clog2(dfi_burst_length_lp << 1))}; cmd_sfifo_wdata.ba = 4'h0; end
+          'd0: begin cmd_sfifo_wdata.cmd = LMR; cmd_sfifo_wdata.addr = 16'h0; cmd_sfifo_wdata.ba = 4'h2; end
           default: cmd_sfifo_wdata.cmd = DESELECT;
         endcase
       end
       REFR: begin
         push = cmd_sfifo_ready;
         case(refr_tick)
-          'd2: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.addr = 16'h400; end
-          'd1: begin cmd_sfifo_wdata.cmd = REF; end
-          'd0: begin cmd_sfifo_wdata.cmd = NOP; end
+          'd1: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.addr = 16'h400; end
+          'd0: begin cmd_sfifo_wdata.cmd = REF; end
         endcase
       end
       LDST: begin
         push = cmd_sfifo_ready;
         case(ldst_tick)
-          'd3: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.ba = bank_addr; cmd_sfifo_wdata.addr = open_row[bank_addr]; end
-          'd2: begin cmd_sfifo_wdata.cmd = ACT; cmd_sfifo_wdata.ba = bank_addr; cmd_sfifo_wdata.addr = row_addr; end
-          'd1: begin
+          'd2: begin cmd_sfifo_wdata.cmd = PRE; cmd_sfifo_wdata.ba = bank_addr; cmd_sfifo_wdata.addr = open_row[bank_addr]; end
+          'd1: begin cmd_sfifo_wdata.cmd = ACT; cmd_sfifo_wdata.ba = bank_addr; cmd_sfifo_wdata.addr = row_addr; end
+          'd0: begin
                  cmd_sfifo_wdata.ba = bank_addr;
                  cmd_sfifo_wdata.addr = {col_addr[14:10], ap, col_addr[9:0]};
                  if(cmd_afifo_rdata.cmd[0])
@@ -386,7 +380,6 @@ module bsg_dmc_controller
                  else
                    cmd_sfifo_wdata.cmd = WRITE;
                end
-          'd0: begin cmd_sfifo_wdata.cmd = NOP; end
         endcase
       end
     endcase
@@ -434,7 +427,7 @@ module bsg_dmc_controller
     ,.yumi_i             ( cmd_sfifo_rinc     ));
 
   always_comb begin
-    if(cmd_sfifo_valid && !stall_transactions_i)
+    if(cmd_sfifo_valid)
       case(c_cmd)
 	LMR:   shoot = cmd_tick >= dmc_p_i.tmrd;
 	REF:   shoot = cmd_tick >= dmc_p_i.trfc;
@@ -442,27 +435,23 @@ module bsg_dmc_controller
 	ACT:   case(n_cmd)
                  PRE:     shoot = cmd_tick >= dmc_p_i.tras;
                  ACT:     shoot = cmd_tick >= dmc_p_i.trrd;
-                 WRITE:   shoot = (cmd_tick >= dmc_p_i.trcd) & (cmd_rd_tick >= dmc_p_i.tcas+dfi_burst_length_lp-1) & (cmd_act_tick >= dmc_p_i.tras) & (&tx_sipo_valid_lo);
-                 READ:    shoot = (cmd_tick >= dmc_p_i.trcd) & (cmd_wr_tick >= dmc_p_i.twtr) & (cmd_act_tick >= dmc_p_i.tras);
-	         	 default: shoot = 1'b1;
-             endcase
-    WRITE: case(n_cmd)
+                 WRITE:   shoot = (cmd_tick >= dmc_p_i.trcd) & (cmd_rd_tick >= dmc_p_i.tcas+dfi_burst_length_lp-1) & (&tx_sipo_valid_lo);
+                 READ:    shoot = (cmd_tick >= dmc_p_i.trcd) & (cmd_wr_tick >= dmc_p_i.twtr);
+	         default: shoot = 1'b1;
+               endcase
+        WRITE: case(n_cmd)
                  PRE:     shoot = (cmd_tick >= dmc_p_i.twr) & (cmd_act_tick >= dmc_p_i.tras);
-				 // if write is followed by refresh, it means we are writing with auto precharge. But we still have to wait for tras after activate and (twr + trp) for internal precharge to have completed. So timing condition below applies for either n_cmd = precharge or refresh			
-                 REF:     shoot = (cmd_tick >= dmc_p_i.twr + dmc_p_i.trp) & (cmd_act_tick >= dmc_p_i.tras) ;			
-                 WRITE:   shoot = (ap) ? ((cmd_tick >= dfi_burst_length_lp-1) & (&tx_sipo_valid_lo) && cmd_tick >= dmc_p_i.trp) : ((cmd_tick >= dfi_burst_length_lp-1) & (&tx_sipo_valid_lo)) ;
-                 READ:    shoot = (ap) ? (cmd_tick >= dmc_p_i.twtr && cmd_tick >= dmc_p_i.trp) : cmd_tick >= dmc_p_i.twtr ;
-                 ACT:     shoot = (cmd_act_tick >= dmc_p_i.trc) & (cmd_tick >= dmc_p_i.twr + dmc_p_i.trp) & (cmd_tick >= dmc_p_i.trrd);
-	             default: shoot = 1'b1;
+                 WRITE:   shoot = (cmd_tick >= dfi_burst_length_lp-1) & (&tx_sipo_valid_lo);
+                 READ:    shoot = cmd_tick >= dmc_p_i.twtr;
+                 ACT:     shoot = (cmd_act_tick >= dmc_p_i.trc) & (cmd_tick >= dmc_p_i.twr + dmc_p_i.trp);
+	         default: shoot = 1'b1;
                endcase
-    READ:  case(n_cmd)
+        READ:  case(n_cmd)
                  PRE:     shoot = (cmd_tick >= dmc_p_i.trtp) & (cmd_act_tick >= dmc_p_i.tras);
-				 // if read is followed by refresh, it means we are reading with auto precharge. But we still have to wait for trtp after read and tras after activate. So timing condition below applies for either n_cmd = precharge or refresh			
-                 REF:     shoot = (cmd_tick >= dmc_p_i.trtp + dmc_p_i.trp) & (cmd_act_tick >= dmc_p_i.tras);			
-                 WRITE:   shoot = (ap) ?  ( (cmd_tick >= dmc_p_i.tcas + dmc_p_i.trp + dfi_burst_length_lp-1) & (&tx_sipo_valid_lo) ): ((cmd_tick >= dmc_p_i.tcas + dfi_burst_length_lp-1) & (&tx_sipo_valid_lo));
+                 WRITE:   shoot = (cmd_tick >= dmc_p_i.tcas+dfi_burst_length_lp-1) & (&tx_sipo_valid_lo);
                  READ:    shoot = cmd_tick >= dfi_burst_length_lp-1;
-                 ACT:     shoot = (cmd_act_tick >= dmc_p_i.trc) & (cmd_tick >= dmc_p_i.trtp + dmc_p_i.trp) & (cmd_tick >= dmc_p_i.trrd) & (cmd_tick >= dmc_p_i.trrd);
-	             default: shoot = 1'b1;
+                 ACT:     shoot = (cmd_act_tick >= dmc_p_i.trc) & (cmd_tick >= dmc_p_i.trtp + dmc_p_i.trp);
+	         default: shoot = 1'b1;
                endcase
 	default: shoot = 1'b1;
       endcase
@@ -509,12 +498,27 @@ module bsg_dmc_controller
   always_ff @(posedge dfi_clk_i) begin
     if(dfi_clk_sync_rst_i)
       c_cmd <= NOP;
-    else if(shoot && n_cmd != NOP)
+    else if(shoot)
       c_cmd <= n_cmd;
   end
 
   assign n_cmd = cmd_sfifo_rdata.cmd;
 
+  always_ff @(posedge dfi_clk_i) begin
+    if(dfi_clk_sync_rst_i) begin
+      cwd_tick <= 0;
+      cwd_valid <= 0;
+    end
+    else if(shoot && cmd_sfifo_rdata[23:20] == WRITE) begin
+      cwd_tick <= dmc_p_i.tcas - 2;
+      cwd_valid <= 1;
+    end
+    else if(cwd_valid) begin
+      cwd_tick <= cwd_tick - 1;
+      if(cwd_tick == 0) cwd_valid <= 0;
+    end
+  end
+
   always_ff @(posedge dfi_clk_i) begin
     if(dfi_clk_sync_rst_i) begin
       wburst_tick <= 0;
@@ -718,7 +722,7 @@ module bsg_dmc_controller
     ,.data_o  ( rx_piso_data_lo    )
     ,.yumi_i  ( rx_piso_yumi_li    ));
 
-  logic [`BSG_WIDTH(ui_burst_length_lp)-1:0] rd_cnt;
+  logic [7:0] rd_cnt;
 
   always_ff @(posedge ui_clk_i) begin
     if(ui_clk_sync_rst_i)
@@ -731,23 +735,6 @@ module bsg_dmc_controller
     end
   end
 
-  logic [`BSG_WIDTH(cmd_sfifo_depth_p)-1:0] txn_cnt;
-  bsg_counter_up_down #
-    (.max_val_p(cmd_sfifo_depth_p)
-    ,.init_val_p(0)
-    ,.max_step_p(1)
-    ,.disable_overflow_warning_p(1))
-  txn_counter
-    (.clk_i(ui_clk_i)
-     ,.reset_i(ui_clk_sync_rst_i)
-     ,.up_i((app_rdy_o & app_en_i))
-     ,.down_i((app_wdf_end_i & app_wdf_rdy_o) || (app_rd_data_end_o))
-     ,.count_o(txn_cnt)
-     );
-  assign transaction_in_progress_o = (txn_cnt != '0);
-
-  assign refresh_in_progress_o = (c_cmd == REF);
-
   assign app_rd_data_valid_o = rx_piso_valid_lo;
   assign app_rd_data_o       = rx_piso_data_lo;
   assign app_rd_data_end_o   = rx_piso_valid_lo && (rd_cnt == ui_burst_length_lp - 1);
diff --git a/bsg_dmc/bsg_dmc_pkg.v b/bsg_dmc/bsg_dmc_pkg.v
index f2432c9c..2a347734 100644
--- a/bsg_dmc/bsg_dmc_pkg.v
+++ b/bsg_dmc/bsg_dmc_pkg.v
@@ -1,7 +1,5 @@
 
 package bsg_dmc_pkg;
-  import bsg_tag_pkg::*;
-
   typedef struct packed {
     logic [15:0] trefi;
     logic  [3:0] tmrd;
@@ -23,17 +21,11 @@ package bsg_dmc_pkg;
     logic [15:0] init_cycles;
   } bsg_dmc_s;
 
-  typedef enum logic [3:0]
-    {RP = 4'b0011 // read with auto precharge
-    ,WP = 4'b0010 // write with auto precharge
-    ,RD = 4'b0001 // read
-    ,WR = 4'b0000 // write
-
-    // Only used in trace debug module
-    ,TEX = 4'b1000 // execute commands in trace fifo
-    ,TWD = 4'b1001 // write data, non-terminating
-    ,TWT = 4'b1010 // write data, terminating
-    ,TNP = 4'b1111 // NOP, do nothing
+  typedef enum logic [2:0]
+    {RP = 3'b011 // read with auto precharge
+    ,WP = 3'b010 // write with auto precharge
+    ,RD = 3'b001 // read
+    ,WR = 3'b000 // write
   } app_cmd_e;
 
   typedef enum logic [3:0]
@@ -54,46 +46,4 @@ package bsg_dmc_pkg;
     logic [2:0] ba;
     logic [15:0] addr;
   } dfi_cmd_sfifo_entry_s;
-
-  localparam bsg_dmc_tag_client_width_gp = 8;
-
-  typedef struct packed {
-    bsg_tag_s         ds;
-    bsg_tag_s [3:0]   dly_trigger;
-    bsg_tag_s [3:0]   dly;
-    bsg_tag_s         async_reset;
-  } bsg_dmc_dly_tag_lines_s;
-  localparam tag_dmc_dly_local_els_gp = $bits(bsg_dmc_dly_tag_lines_s)/$bits(bsg_tag_s);
-
-  typedef struct packed {
-    bsg_tag_s [1:0] init_cycles;
-    bsg_tag_s bank_pos_bank_width;
-    bsg_tag_s row_width_col_width;
-    bsg_tag_s dqs_sel_cal_tcas;
-    bsg_tag_s trtp_twtr;
-    bsg_tag_s twr_trcd;
-    bsg_tag_s trrd_tras;
-    bsg_tag_s trp_trc;
-    bsg_tag_s trfc_tmrd;
-    bsg_tag_s [1:0] trefi;
-  } bsg_dmc_cfg_tag_lines_s;
-  localparam tag_dmc_cfg_local_els_gp = $bits(bsg_dmc_cfg_tag_lines_s)/$bits(bsg_tag_s);
-
-  typedef struct packed {
-    bsg_tag_s test_mode;
-    bsg_tag_s stall_transactions;
-    bsg_tag_s async_reset;
-  } bsg_dmc_sys_tag_lines_s;
-  localparam tag_dmc_sys_local_els_gp = $bits(bsg_dmc_sys_tag_lines_s)/$bits(bsg_tag_s);
-
-  // TODO: Align with clk gen lines
-  typedef struct packed {
-    bsg_tag_s sel;
-    bsg_tag_s ds;
-    bsg_tag_s osc_trigger;
-    bsg_tag_s osc;
-    bsg_tag_s async_reset;
-  } bsg_dmc_osc_tag_lines_s;
-  localparam tag_dmc_osc_local_els_gp = $bits(bsg_dmc_osc_tag_lines_s)/$bits(bsg_tag_s);
-
 endpackage // bsg_dmc_pkg
diff --git a/bsg_dmc/bsg_dmc_sys_cfg_gen.v b/bsg_dmc/bsg_dmc_sys_cfg_gen.v
deleted file mode 100644
index 63342ba4..00000000
--- a/bsg_dmc/bsg_dmc_sys_cfg_gen.v
+++ /dev/null
@@ -1,167 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////////////////////////
-//    		BASEJUMP STL
-//
-//       MODULE: bsg_dmc_sys_cfg_gen
-//  DESCRIPTION: Part of the bsg_dmc hierarchy. Input: chip side tag liens, Output: decoded tag values, DFI 2x clock
-//    AUTHOR(S): Akash Suresh, akashs3@uw.edu
-// ORGANIZATION: Bespoke Silicon Group, University of Washington
-//      CREATED: 01/26/22
-///////////////////////////////////////////////////////////////////////////////////////////////////
-module bsg_dmc_sys_cfg_gen
-						import bsg_tag_pkg::*;
-						import bsg_dmc_pkg::*;
-						(
-						input  bsg_dmc_cfg_tag_lines_s cfg_tag_lines_i
-						,input bsg_dmc_sys_tag_lines_s sys_tag_lines_i
-						,input dfi_clk_1x_i
-						,output bsg_dmc_s dmc_p_o
-						,output async_reset_o
-						,output logic stall_transactions_o
-						,output logic test_mode_o
-						);
-
-    for (genvar i = 0; i < 2; i++)
-      begin : trefi
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.trefi[i] )
-           ,.recv_clk_i    ( dfi_clk_1x_i             )
-           ,.recv_new_r_o  (                          )
-           ,.recv_data_r_o ( dmc_p_o.trefi[i*bsg_dmc_tag_client_width_gp+:bsg_dmc_tag_client_width_gp] )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : trfc_tmrd
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.trfc_tmrd    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                 )
-           ,.recv_new_r_o  (                              )
-           ,.recv_data_r_o ( {dmc_p_o.trfc, dmc_p_o.tmrd} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : trp_trc
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.trp_trc    )
-           ,.recv_clk_i    ( dfi_clk_1x_i               )
-           ,.recv_new_r_o  (                            )
-           ,.recv_data_r_o ( {dmc_p_o.trp, dmc_p_o.trc} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : trrd_tras
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.trrd_tras    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                 )
-           ,.recv_new_r_o  (                              )
-           ,.recv_data_r_o ( {dmc_p_o.trrd, dmc_p_o.tras} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : twr_trcd
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.twr_trcd    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                )
-           ,.recv_new_r_o  (                             )
-           ,.recv_data_r_o ( {dmc_p_o.twr, dmc_p_o.trcd} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : trtp_twtr
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.trtp_twtr    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                 )
-           ,.recv_new_r_o  (                              )
-           ,.recv_data_r_o ( {dmc_p_o.trtp, dmc_p_o.twtr} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : dqs_sel_cal_tcas
-        // DQS sel cal is only 3 bits
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp-1))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.dqs_sel_cal_tcas    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                        )
-           ,.recv_new_r_o  (                                     )
-           ,.recv_data_r_o ( {dmc_p_o.dqs_sel_cal, dmc_p_o.tcas} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : row_width_col_width
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.row_width_col_width    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                           )
-           ,.recv_new_r_o  (                                        )
-           ,.recv_data_r_o ( {dmc_p_o.row_width, dmc_p_o.col_width} )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : bank_pos_bank_width
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.bank_pos_bank_width    )
-           ,.recv_clk_i    ( dfi_clk_1x_i                           )
-           ,.recv_new_r_o  (                                        )
-           ,.recv_data_r_o ( {dmc_p_o.bank_pos, dmc_p_o.bank_width} )
-           );
-      end
-
-    for (genvar i = 0; i < 2; i++)
-      begin : init_cycles
-        bsg_tag_client #(.width_p(bsg_dmc_tag_client_width_gp))
-         btc
-          (.bsg_tag_i      ( cfg_tag_lines_i.init_cycles[i]         )
-           ,.recv_clk_i    ( dfi_clk_1x_i                           )
-           ,.recv_new_r_o  (                                        )
-           ,.recv_data_r_o ( dmc_p_o.init_cycles[i*bsg_dmc_tag_client_width_gp+:bsg_dmc_tag_client_width_gp] )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : async_reset
-        bsg_tag_client #(.width_p(1))
-         btc
-          (.bsg_tag_i      ( sys_tag_lines_i.async_reset            )
-           ,.recv_clk_i    ( dfi_clk_1x_i                           )
-           ,.recv_new_r_o  (                                        )
-           ,.recv_data_r_o ( async_reset_o                          )
-           );
-      end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : stall_transactions
-        bsg_tag_client #(.width_p(1))
-         btc
-          (.bsg_tag_i      ( sys_tag_lines_i.stall_transactions     )
-           ,.recv_clk_i    ( dfi_clk_1x_i                           )
-           ,.recv_new_r_o  (                                        )
-           ,.recv_data_r_o ( stall_transactions_o                   )
-           );
-       end
-
-    for (genvar i = 0; i < 1; i++)
-      begin : test_mode
-        bsg_tag_client #(.width_p(1))
-         btc
-          (.bsg_tag_i      ( sys_tag_lines_i.test_mode     )
-           ,.recv_clk_i    ( dfi_clk_1x_i                  )
-           ,.recv_new_r_o  (                               )
-           ,.recv_data_r_o ( test_mode_o                   )
-           );
-      end
-
-endmodule
diff --git a/bsg_dmc/bsg_dmc_xilinx_ui_trace_replay.v b/bsg_dmc/bsg_dmc_xilinx_ui_trace_replay.v
deleted file mode 100644
index cbfd15da..00000000
--- a/bsg_dmc/bsg_dmc_xilinx_ui_trace_replay.v
+++ /dev/null
@@ -1,168 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////////////////////////
-//    		BASEJUMP STL
-//
-//       MODULE: bsg_dmc_xilinx_ui_trace_replay
-//  DESCRIPTION: Takes the DMC cmd, addr, wdata, wmask trace packet and converts into XILINX UI interface to feed to DMC;
-//  			 And converts UI read interface signals to trace packet to forward to FPGA
-//    AUTHOR(S): Akash Suresh, akashs3@uw.edu
-// ORGANIZATION: Bespoke Silicon Group, University of Washington
-//      CREATED: 01/07/22
-///////////////////////////////////////////////////////////////////////////////////////////////////
-
-`include "bsg_defines.v"
-
-module bsg_dmc_xilinx_ui_trace_replay
-	import bsg_dmc_pkg::*;
-	#(	parameter `BSG_INV_PARAM( data_width_p),
-		parameter `BSG_INV_PARAM( addr_width_p),
-		parameter `BSG_INV_PARAM( burst_len_p),
-        parameter `BSG_INV_PARAM( tfifo_depth_p),
-        parameter `BSG_INV_PARAM( rfifo_depth_p),
-
-		localparam trace_data_width_lp = `bsg_dmc_trace_entry_width(data_width_p, addr_width_p)
-	)
-	( 	input 									clk_i,
-		input									reset_i,
-
-        // Trace data from producer
-		output logic     					    ready_o,
-		input [trace_data_width_lp -1 :0] 		data_i,
-		input 									v_i,
-
-        // Read data to consumer
-		output logic [data_width_p -1 :0]	    data_o,
-		output logic							v_o,
-        input                                   yumi_i,
-
-   		// xilinx user interface
-   		output logic [addr_width_p-1:0]        	app_addr_o,
-   		output app_cmd_e				    	app_cmd_o,
-   		output logic                       		app_en_o,
-   		input                              		app_rdy_i,
-   		output logic                       		app_wdf_wren_o,
-   		output logic [data_width_p-1:0]			app_wdf_data_o,
-   		output logic [(data_width_p>>3)-1:0] 	app_wdf_mask_o,
-   		output logic                   			app_wdf_end_o,
-   		input                              		app_wdf_rdy_i,
-   		input                              		app_rd_data_valid_i,
-   		input [data_width_p-1:0] 		      	app_rd_data_i,
-   		input                              		app_rd_data_end_i
-	);
-
-    enum {e_fill, e_drain} state_n, state_r;
-    wire is_fill = (state_r == e_fill);
-    wire is_drain = (state_r == e_drain);
-
-    `declare_bsg_dmc_trace_entry_s(data_width_p, addr_width_p);
-
-    // Only enqueue onto fifo if it's an app_cmd
-    bsg_dmc_trace_entry_s trace_data_li;
-    logic trace_ready_lo, trace_v_li;
-    bsg_dmc_trace_entry_s trace_data_lo;
-    logic trace_v_lo, trace_yumi_li;
-	assign trace_data_li = data_i;
-    bsg_fifo_1r1w_small
-    				#(.width_p($bits(bsg_dmc_trace_entry_s))
-    				,.els_p(tfifo_depth_p)
-                    ,.harden_p(1)
-    				) trace_fifo
-    				(.clk_i  (clk_i)
-    				,.reset_i(reset_i)
-    				
-    				,.data_i (trace_data_li)
-    				,.v_i    (trace_v_li)
-    				,.ready_o(trace_ready_lo)
-    				
-    				,.v_o    (trace_v_lo)
-    				,.data_o (trace_data_lo)
-    				,.yumi_i (trace_yumi_li)
-    				);
-
-    logic read_data_credit;
-    bsg_fifo_1r1w_small_credit_on_input
-                    #(.width_p(data_width_p)
-                    ,.els_p(rfifo_depth_p)
-                    ,.harden_p(1)
-                    ) read_data_fifo
-                    (.clk_i  (clk_i)
-                    ,.reset_i(reset_i)
-
-                    ,.data_i (app_rd_data_i)
-                    ,.v_i    (app_rd_data_valid_i)
-                    ,.credit_o(read_data_credit)
-
-                    ,.v_o    (v_o)
-                    ,.data_o (data_o)
-                    ,.yumi_i (yumi_i)
-                    );
-
-    logic [`BSG_WIDTH(rfifo_depth_p)-1:0] read_credit;
-    bsg_flow_counter #(.els_p(rfifo_depth_p), .count_free_p(1)) fc
-      (.clk_i(clk_i)
-       ,.reset_i(reset_i)
-
-       ,.v_i(app_rd_data_valid_i)
-       ,.ready_i(1'b1)
-       ,.yumi_i(read_data_credit)
-
-       ,.count_o(read_credit)
-       );
-    wire read_avail = (read_credit >= burst_len_p);
-
-    wire trace_is_write = trace_data_lo.app_cmd inside {WP, WR};
-    wire trace_is_wdata = trace_data_lo.app_cmd inside {TWD, TWT};
-    wire trace_is_wdone = trace_data_lo.app_cmd inside {TWT};
-    wire trace_is_read = trace_data_lo.app_cmd inside {RP, RD};
-    wire trace_is_nop = trace_data_lo.app_cmd inside {TNP};
-    always_comb begin
-      state_n = state_r;
-
-      ready_o = '0;
-
-      app_en_o = '0;
-      app_cmd_o = trace_data_lo.app_cmd;
-      app_addr_o = trace_data_lo.payload.cmd.addr;
-      app_wdf_data_o = trace_data_lo.payload.wdata.data;
-      app_wdf_mask_o = trace_data_lo.payload.wdata.mask;
-      app_wdf_wren_o = '0;
-      app_wdf_end_o = '0;
-
-      trace_v_li = '0;
-      trace_yumi_li = '0;
-
-      // TODO: If trace fifo is full before drain command, we can get into a bad state.
-      //   How to recover?
-      case(state_r)
-        e_fill: begin
-          ready_o = trace_ready_lo;
-          trace_v_li = v_i & (trace_data_li.app_cmd != TEX);
-
-          state_n = (v_i & (trace_data_li.app_cmd == TEX)) ? e_drain : e_fill;
-        end
-        e_drain: begin
-          app_en_o = trace_v_lo & (trace_is_write | (trace_is_read & read_avail));
-
-          app_wdf_wren_o = trace_v_lo & trace_is_wdata;
-          app_wdf_end_o = trace_v_lo & trace_is_wdone;
-
-          trace_yumi_li = trace_v_lo & ((app_rdy_i & app_en_o) || (app_wdf_wren_o & app_wdf_rdy_i) || (trace_is_nop));
-
-          // Transition to fill once the fifo is empty
-          state_n = (trace_v_lo == '0) ? e_fill : e_drain;
-        end
-        default: begin end
-      endcase
-    end
-
-    // synopsys sync_set_reset "reset_i"
-    always_ff @(posedge clk_i) begin
-      if (reset_i)
-        state_r <= e_fill;
-      else
-        state_r <= state_n;
-    end
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_dmc_xilinx_ui_trace_replay)
-
diff --git a/bsg_mem/bsg_mem_1r1w_sync_banked.v b/bsg_mem/bsg_mem_1r1w_sync_banked.v
deleted file mode 100644
index 5e1bd285..00000000
--- a/bsg_mem/bsg_mem_1r1w_sync_banked.v
+++ /dev/null
@@ -1,166 +0,0 @@
-/**
- *  bsg_mem_1r1w_sync_banked.v
- *
- *  This module has the same interface/functionality as
- *  bsg_mem_1r1w_sync.
- *
- *  This module can be used for breaking a big SRAM block into
- *  smaller blocks. This might be useful, if the SRAM generator does not
- *  support sizes of SRAM that are too wide or too deep.
- *  It is also useful for power and delay perspective, since only one depth
- *  bank is activated while reading or writing.
- *
- *
- *  - width_p : width of the total memory
- *  - els_p : depth of the total memory
- *
- *  - num_width_bank_p : Number of banks for the memory's width. width_p has
- *  to be a multiple of this number.
- *  - num_depth_bank_p : Number of banks for the memory's depth. els_p has to
- *  be a multiple of this number.
- *
- */
-
-
-`include "bsg_defines.v"
-
-module bsg_mem_1r1w_sync_banked 
-  #(parameter `BSG_INV_PARAM(width_p)
-    , parameter `BSG_INV_PARAM(els_p)
-    , parameter read_write_same_addr_p=0
-
-    , parameter num_width_bank_p=1
-    , parameter num_depth_bank_p=1
-
-    , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-
-    , parameter bank_depth_lp=(els_p/num_depth_bank_p)
-    , parameter bank_addr_width_lp=`BSG_SAFE_CLOG2(bank_depth_lp)
-    , parameter depth_bank_idx_width_lp=`BSG_SAFE_CLOG2(num_depth_bank_p)
-    , parameter bank_width_lp=(width_p/num_width_bank_p)
-  )
-  (
-    input clk_i
-    , input reset_i
-
-    , input w_v_i
-    , input [addr_width_lp-1:0] w_addr_i
-    , input [width_p-1:0] w_data_i
-
-    , input r_v_i
-    , input [addr_width_lp-1:0] r_addr_i
-    , output logic [width_p-1:0] r_data_o
-  );
-
-
-  if (num_depth_bank_p==1) begin: db1
-
-    for (genvar i = 0; i < num_width_bank_p; i++) begin: wb
-
-      bsg_mem_1r1w_sync #(
-        .width_p(bank_width_lp)
-        ,.els_p(bank_depth_lp)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) bank (
-        .clk_i(clk_i)
-        ,.reset_i(reset_i)
-        ,.w_v_i(w_v_i)
-        ,.w_addr_i(w_addr_i)
-        ,.w_data_i(w_data_i[bank_width_lp*i+:bank_width_lp])
-        ,.r_v_i(r_v_i)
-        ,.r_addr_i(r_addr_i)
-        ,.r_data_o(r_data_o[bank_width_lp*i+:bank_width_lp])
-      );
-
-    end
-
-  end
-  else begin: dbn
-
-    logic [num_depth_bank_p-1:0] bank_r_v_li, bank_w_v_li;
-    logic [num_depth_bank_p-1:0][width_p-1:0] bank_r_data_lo;
-   
-    wire [depth_bank_idx_width_lp-1:0] depth_bank_r_idx_li = r_addr_i[0+:depth_bank_idx_width_lp];
-    wire [bank_addr_width_lp-1:0] bank_r_addr_li = r_addr_i[depth_bank_idx_width_lp+:bank_addr_width_lp];
-
-    wire [depth_bank_idx_width_lp-1:0] depth_bank_w_idx_li = w_addr_i[0+:depth_bank_idx_width_lp];
-    wire [bank_addr_width_lp-1:0] bank_w_addr_li = w_addr_i[depth_bank_idx_width_lp+:bank_addr_width_lp];
-
-    bsg_decode_with_v #(
-      .num_out_p(num_depth_bank_p)
-    ) demux_r_v (
-      .i(depth_bank_r_idx_li)
-      ,.v_i(r_v_i)
-      ,.o(bank_r_v_li)
-    );
-
-    bsg_decode_with_v #(
-      .num_out_p(num_depth_bank_p)
-    ) demux_w_v (
-      .i(w_depth_bank_w_idx_li)
-      ,.v_i(w_v_i)
-      ,.o(bank_w_v_li)
-    );
-    
-    for (genvar i = 0; i < num_width_bank_p; i++) begin: wb
-      for (genvar j = 0; j < num_depth_bank_p; j++) begin: db
-
-        bsg_mem_1r1w_sync #(
-          .width_p(bank_width_lp)
-          ,.els_p(bank_depth_lp)
-          ,.read_write_same_addr_p(read_write_same_addr_p)
-        ) bank (
-          .clk_i(clk_i)
-          ,.reset_i(reset_i)
-
-          ,.w_v_i(w_v_i)
-          ,.w_addr_i(bank_w_addr_li)
-          ,.w_data_i(w_data_i[i*bank_width_lp+:bank_width_lp])
-          ,.r_v_i(bank_r_v_li[j])
-          ,.r_addr_i(bank_r_addr_li)
-          ,.r_data_o(bank_r_data_lo[j][i*bank_width_lp+:bank_width_lp])
-        );
-
-      end
-    end
-
-    logic [depth_bank_idx_width_lp-1:0] depth_bank_r_idx_r;
-
-    bsg_dff_en #(
-      .width_p(depth_bank_idx_width_lp)
-    ) depth_bank_idx_dff (
-      .clk_i(clk_i)
-      ,.en_i(r_v_i)
-      ,.data_i(depth_bank_r_idx_li)
-      ,.data_o(depth_bank_r_idx_r)
-    );
-
-    bsg_mux #(
-      .els_p(num_depth_bank_p)
-      ,.width_p(width_p)
-    ) data_out_mux (
-      .data_i(bank_r_data_lo)
-      ,.sel_i(depth_bank_r_idx_r)
-      ,.data_o(r_data_o)
-    );
-
-  end
-
-
-  // synopsys translate_off
-
-  initial begin
-    assert(els_p % num_depth_bank_p == 0)
-      else $error("[BSG_ERROR] num_depth_bank_p does not divide even with els_p. %m");
-
-    assert(width_p % num_width_bank_p == 0)
-      else $error("[BSG_ERROR] num_width_bank_p does not divide even with width_p. %m");
-  end
-  
-  // synopsys translate_on
-  
-
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_1r1w_sync_banked)
diff --git a/bsg_mem/bsg_mem_2rw_sync.v b/bsg_mem/bsg_mem_2rw_sync.v
deleted file mode 100644
index 9abd5bd6..00000000
--- a/bsg_mem/bsg_mem_2rw_sync.v
+++ /dev/null
@@ -1,98 +0,0 @@
-
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p=0
-                         , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p=1
-                         , parameter disable_collision_warning_p=0
-                         , parameter enable_clock_gating_p=0
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire clk_lo;
-
-   if (enable_clock_gating_p)
-     begin
-       bsg_clkgate_optional icg
-         (.clk_i( clk_i )
-         ,.en_i( a_v_i | b_v_i )
-         ,.bypass_i( 1'b0 )
-         ,.gated_clock_o( clk_lo )
-         );
-     end
-   else
-     begin
-       assign clk_lo = clk_i;
-     end
-
-   bsg_mem_2rw_sync_synth
-     #(.width_p(width_p)
-       ,.els_p(els_p)
-       ,.read_write_same_addr_p(read_write_same_addr_p)
-       ,.harden_p(harden_p)
-       ) synth
-       (.clk_i (clk_lo)
-       ,.reset_i
-       ,.a_data_i
-       ,.a_addr_i
-       ,.a_v_i
-       ,.a_w_i
-       ,.b_data_i
-       ,.b_addr_i
-       ,.b_v_i
-       ,.b_w_i
-       ,.a_data_o
-       ,.b_data_o
-       );
-
-   // synopsys translate_off
-
-   always_ff @(negedge clk_lo)
-   begin
-     if (a_v_i === 1)
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (a_addr_i < els_p))
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", a_addr_i, els_p, reset_i, a_v_i, clk_lo);
-
-     if (b_v_i === 1)
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (b_addr_i < els_p))
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", b_addr_i, els_p, reset_i, b_v_i, clk_lo);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i ^ b_w_i))) && !read_write_same_addr_p && !disable_collision_warning_p)
-         else $error("%m: Attempt to read and write same address reset_i %b, %x <= %x",reset_i, a_addr_i,a_data_i);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i & b_w_i))))
-         else $error("%m: Attempt to write and write same address reset_i %b, %x <= %x",reset_i, a_addr_i,a_data_i);
-   end
-
-   initial
-     begin
-        $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);
-
-       	if (disable_collision_warning_p)
-          $display("## %m %L: disable_collision_warning_p is set; you should not have this on unless you have broken code. fix it!\n");
-     end
-
-  // synopsys translate_on
-
-   
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync)
-
diff --git a/bsg_mem/bsg_mem_2rw_sync_mask_write_bit.v b/bsg_mem/bsg_mem_2rw_sync_mask_write_bit.v
deleted file mode 100644
index 66a0b5b5..00000000
--- a/bsg_mem/bsg_mem_2rw_sync_mask_write_bit.v
+++ /dev/null
@@ -1,98 +0,0 @@
-
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync_mask_write_bit #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p=0
-                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p=1
-                         , parameter disable_collision_warning_p=0
-                         , parameter enable_clock_gating_p=0
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [width_p-1:0]        a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [width_p-1:0]        b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire clk_lo;
-
-   if (enable_clock_gating_p)
-     begin
-       bsg_clkgate_optional icg
-         (.clk_i( clk_i )
-         ,.en_i( a_v_i | b_v_i )
-         ,.bypass_i( 1'b0 )
-         ,.gated_clock_o( clk_lo )
-         );
-     end
-   else
-     begin
-       assign clk_lo = clk_i;
-     end
-
-   bsg_mem_2rw_sync_mask_write_bit_synth
-     #(.width_p(width_p)
-       ,.els_p(els_p)
-       ) synth
-       (.clk_i (clk_lo)
-       ,.reset_i
-       ,.a_data_i
-       ,.a_w_mask_i
-       ,.a_addr_i
-       ,.a_v_i
-       ,.a_w_i
-       ,.b_data_i
-       ,.b_w_mask_i
-       ,.b_addr_i
-       ,.b_v_i
-       ,.b_w_i
-       ,.a_data_o
-       ,.b_data_o
-       );
-
-   // synopsys translate_off
-
-   always_ff @(negedge clk_lo)
-     if (a_v_i | b_v_i) begin
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (a_addr_i < els_p))
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", a_addr_i, els_p, reset_i, a_v_i, clk_lo);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (b_addr_i < els_p))
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", b_addr_i, els_p, reset_i, b_v_i, clk_lo);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i ^ b_w_i))) && !read_write_same_addr_p && !disable_collision_warning_p)
-         else $error("%m: Attempt to read and write same address reset_i %b, %x <= %x (mask %x), %x <= %x (mask %x)",reset_i, a_addr_i,a_data_i,a_w_mask_i, b_addr_i, b_data_i, b_w_mask_i);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i & b_w_i))))
-         else $error("%m: Attempt to write and write same address reset_i %b, %x <= %x (mask %x), %x <= %x (mask %x)",reset_i, a_addr_i,a_data_i,a_w_mask_i, b_addr_i, b_data_i, b_w_mask_i);
-     end
-
-   initial
-     begin
-        $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);
-
-       	if (disable_collision_warning_p)
-          $display("## %m %L: disable_collision_warning_p is set; you should not have this on unless you have broken code. fix it!\n");
-     end
-
-  // synopsys translate_on
-
-   
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_bit)
-
diff --git a/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_synth.v b/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_synth.v
deleted file mode 100644
index 720ee059..00000000
--- a/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_synth.v
+++ /dev/null
@@ -1,112 +0,0 @@
-
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync_mask_write_bit_synth #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p = 0
-                         , parameter disable_collision_warning_p = 0
-                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p = 1
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [width_p-1:0]        a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [width_p-1:0]        b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire                   unused = reset_i;
-
-   if (width_p == 0)
-    begin: z
-      wire unused0 = &{clk_i, a_data_i, a_w_mask_i, a_addr_i, a_v_i, a_w_i};
-      wire unused1 = &{clk_i, b_data_i, b_w_mask_i, b_addr_i, b_v_i, b_w_i};
-      assign a_data_o = '0;
-      assign b_data_o = '0;
-    end
-   else
-    begin: nz
-
-   logic [width_p-1:0]    mem [els_p-1:0];
-
-   // this treats the ram as an array of registers for which the
-   // read addr is latched on the clock, the write
-   // is done on the clock edge, and actually multiplexing
-   // of the registers for reading is done after the clock edge.
-
-   // logically, this means that reads happen in time after
-   // the writes, and "simultaneous" reads and writes to the
-   // register file are allowed -- IF read_write_same_addr is set.
-
-   // note that this behavior is generally incompatible with
-   // hardened 1r1w rams, so it's better not to take advantage
-   // of it if not necessary
-
-   // we explicitly 'X out the read address if valid is not set
-   // to avoid accidental use of data when the valid signal was not
-   // asserted. without this, the output of the register file would
-   // "auto-update" based on new writes to the ram, a spooky behavior
-   // that would never correspond to that of a hardened ram.
-
-   logic [addr_width_lp-1:0] a_addr_r, b_addr_r;
-
-   always_ff @(posedge clk_i)
-     begin
-        if (a_v_i)
-            a_addr_r <= a_addr_i;
-        else
-            a_addr_r <= 'X;
-          
-        if (b_v_i)
-            b_addr_r <= b_addr_i;
-        else
-            b_addr_r <= 'X;
-
-        // if addresses match and this is forbidden, then nuke the read address
-
-        if (a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i || b_w_i) && !read_write_same_addr_p)
-          begin
-             if (!disable_collision_warning_p)
-               begin
-                 $error("X'ing matched read addresses %x %x (%m)",a_addr_i, b_addr_i);
-               end
-             a_addr_r <= 'X;
-             b_addr_r <= 'X;
-          end
-        // synopsys translate_on
-
-     end
-
-   assign a_data_o = mem[a_addr_r];
-   assign b_data_o = mem[b_addr_r];
-
-
-   genvar                       i;
-   for (i = 0; i < width_p; i=i+1)
-     begin
-	always_ff @(posedge clk_i)
-      begin
-
-	  if (a_v_i & a_w_i && a_w_mask_i[i])
-            mem[a_addr_i][i] <= a_data_i[i];
-	  if (b_v_i & b_w_i && b_w_mask_i[i])
-            mem[b_addr_i][i] <= b_data_i[i];
-      end
-     end
-  end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_bit_synth)
-
diff --git a/bsg_mem/bsg_mem_2rw_sync_mask_write_byte.v b/bsg_mem/bsg_mem_2rw_sync_mask_write_byte.v
deleted file mode 100644
index f15f2211..00000000
--- a/bsg_mem/bsg_mem_2rw_sync_mask_write_byte.v
+++ /dev/null
@@ -1,100 +0,0 @@
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync_mask_write_byte #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p=0
-                         , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p=1
-                         , parameter disable_collision_warning_p=0
-                         , parameter enable_clock_gating_p=0
-                         , parameter write_mask_width_lp=(width_p>>3)
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [write_mask_width_lp-1:0] a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [write_mask_width_lp-1:0] b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire clk_lo;
-
-   if (enable_clock_gating_p)
-     begin
-       bsg_clkgate_optional icg
-         (.clk_i( clk_i )
-         ,.en_i( a_v_i | b_v_i )
-         ,.bypass_i( 1'b0 )
-         ,.gated_clock_o( clk_lo )
-         );
-     end
-   else
-     begin
-       assign clk_lo = clk_i;
-     end
-
-   bsg_mem_2rw_sync_mask_write_byte_synth
-     #(.width_p(width_p)
-       ,.els_p(els_p)
-       ,.read_write_same_addr_p(read_write_same_addr_p)
-       ,.harden_p(harden_p)
-       ) synth
-       (.clk_i (clk_lo)
-       ,.reset_i
-       ,.a_data_i
-       ,.a_w_mask_i
-       ,.a_addr_i
-       ,.a_v_i
-       ,.a_w_i
-       ,.b_data_i
-       ,.b_w_mask_i
-       ,.b_addr_i
-       ,.b_v_i
-       ,.b_w_i
-       ,.a_data_o
-       ,.b_data_o
-       );
-
-   // synopsys translate_off
-
-   always_ff @(negedge clk_lo)
-     if (a_v_i || b_v_i) begin
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (a_addr_i < els_p) || ~a_v_i)
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", a_addr_i, els_p, reset_i, a_v_i, clk_lo);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (a_addr_i < els_p) || ~b_v_i)
-         else $error("Invalid address %x to %m of size %x (reset_i = %b, v_i = %b, clk_lo=%b)\n", b_addr_i, els_p, reset_i, b_v_i, clk_lo);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i ^ b_w_i))) && !read_write_same_addr_p && !disable_collision_warning_p)
-         else $error("%m: Attempt to read and write same address reset_i %b, %x <= %x (mask %x), %x <= %x (mask %x)",reset_i, a_addr_i,a_data_i,a_w_mask_i, b_addr_i,b_data_i,b_w_mask_i);
-
-       assert ((reset_i === 'X) || (reset_i === 1'b1) || (~(a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i & b_w_i))))
-         else $error("%m: Attempt to write and write same address reset_i %b, %x <= %x (mask %x), %x <= %x (mask %x)",reset_i, a_addr_i,a_data_i,a_w_mask_i, b_addr_i,b_data_i,b_w_mask_i);
-     end
-        
-   initial
-     begin
-        $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);
-
-       	if (disable_collision_warning_p)
-          $display("## %m %L: disable_collision_warning_p is set; you should not have this on unless you have broken code. fix it!\n");
-     end
-
-  // synopsys translate_on
-
-   
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_byte)
-
diff --git a/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_synth.v b/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_synth.v
deleted file mode 100644
index 98f9ca6c..00000000
--- a/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_synth.v
+++ /dev/null
@@ -1,70 +0,0 @@
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync_mask_write_byte_synth #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p=0
-                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p = 1
-                         , parameter disable_collision_warning_p=0     
-                         , parameter write_mask_width_lp=(width_p>>3)              
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [write_mask_width_lp-1:0] a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [write_mask_width_lp-1:0] b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire                   unused = reset_i;
-
-   if (width_p == 0)
-    begin: z
-      wire unused0 = &{clk_i, a_data_i, a_w_mask_i, a_addr_i, a_v_i, a_w_i};
-      wire unused1 = &{clk_i, b_data_i, b_w_mask_i, b_addr_i, b_v_i, b_w_i};
-      assign a_data_o = '0;
-      assign b_data_o = '0;
-    end
-   else
-    begin: nz
-
-  genvar i;
-  for(i=0; i<write_mask_width_lp; i=i+1)
-  begin: bk
-    bsg_mem_2rw_sync #( .width_p      (8)
-                        ,.els_p        (els_p)
-                        ,.addr_width_lp(addr_width_lp)
-                        ,.disable_collision_warning_p(disable_collision_warning_p)
-                        ,.harden_p(harden_p)
-                      ) mem_2rw_sync
-                      ( .clk_i  (clk_i)
-                       ,.reset_i(reset_i)
-                       ,.a_data_i (a_data_i[(i*8)+:8])
-                       ,.a_addr_i (a_addr_i)
-                       ,.a_v_i    (a_v_i & (a_w_i ? a_w_mask_i[i] : 1'b1))
-                       ,.a_w_i    (a_w_i & a_w_mask_i[i])
-                       ,.a_data_o (a_data_o[(i*8)+:8])
-                       ,.b_data_i (b_data_i[(i*8)+:8])
-                       ,.b_addr_i (b_addr_i)
-                       ,.b_v_i    (b_v_i & (b_w_i ? b_w_mask_i[i] : 1'b1))
-                       ,.b_w_i    (b_w_i & b_w_mask_i[i])
-                       ,.b_data_o (b_data_o[(i*8)+:8])
-                      );
-  end
-    end
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_byte_synth)
-
diff --git a/bsg_mem/bsg_mem_2rw_sync_synth.v b/bsg_mem/bsg_mem_2rw_sync_synth.v
deleted file mode 100644
index bbef47ff..00000000
--- a/bsg_mem/bsg_mem_2rw_sync_synth.v
+++ /dev/null
@@ -1,105 +0,0 @@
-
-`include "bsg_defines.v"
-
-module bsg_mem_2rw_sync_synth #( parameter `BSG_INV_PARAM(width_p )
-                         , parameter `BSG_INV_PARAM(els_p )
-                         , parameter read_write_same_addr_p=0
-                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
-                         , parameter harden_p = 1
-                         , parameter disable_collision_warning_p=0                   
-                         )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [width_p-1:0]        a_data_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [width_p-1:0]        b_data_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [width_p-1:0] a_data_o
-  , output logic [width_p-1:0] b_data_o
-  );
-
-   wire                   unused = reset_i;
-
-   if (width_p == 0)
-    begin: z
-      wire unused0 = &{clk_i, a_data_i, a_addr_i, a_v_i, a_w_i};
-      wire unused1 = &{clk_i, b_data_i, b_addr_i, b_v_i, b_w_i};
-      assign a_data_o = '0;
-      assign b_data_o = '0;
-    end
-   else
-    begin: nz
-
-   logic [width_p-1:0]    mem [els_p-1:0];
-
-   // this treats the ram as an array of registers for which the
-   // read addr is latched on the clock, the write
-   // is done on the clock edge, and actually multiplexing
-   // of the registers for reading is done after the clock edge.
-
-   // logically, this means that reads happen in time after
-   // the writes, and "simultaneous" reads and writes to the
-   // register file are allowed -- IF read_write_same_addr is set.
-
-   // note that this behavior is generally incompatible with
-   // hardened 1r1w rams, so it's better not to take advantage
-   // of it if not necessary
-
-   // we explicitly 'X out the read address if valid is not set
-   // to avoid accidental use of data when the valid signal was not
-   // asserted. without this, the output of the register file would
-   // "auto-update" based on new writes to the ram, a spooky behavior
-   // that would never correspond to that of a hardened ram.
-
-   logic [addr_width_lp-1:0] a_addr_r, b_addr_r;
-
-   always_ff @(posedge clk_i)
-     begin
-        if (a_v_i)
-            a_addr_r <= a_addr_i;
-        else
-            a_addr_r <= 'X;
-          
-        if (b_v_i)
-            b_addr_r <= b_addr_i;
-        else
-            b_addr_r <= 'X;
-
-        // synopsys translate_off
-        // if addresses match and this is forbidden, then nuke the read address
-
-        if (a_addr_i == b_addr_i && a_v_i && b_v_i && (a_w_i || b_w_i) && !read_write_same_addr_p)
-          begin
-             if (!disable_collision_warning_p)
-               begin
-                 $error("X'ing matched read address %x (%m)",a_addr_i);
-               end
-             a_addr_r <= 'X;
-             b_addr_r <= 'X;
-          end
-        // synopsys translate_on
-
-     end
-
-   assign a_data_o = mem[a_addr_r];
-   assign b_data_o = mem[b_addr_r];
-
-	always_ff @(posedge clk_i)
-    begin
-	  if (a_v_i & a_w_i)
-            mem[a_addr_i] <= a_data_i;
-	  if (b_v_i & b_w_i)
-            mem[b_addr_i] <= b_data_i;
-    end
-  end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_synth)
-
diff --git a/bsg_misc/bsg_clkmux.v b/bsg_misc/bsg_clkmux.v
deleted file mode 100644
index 165c6364..00000000
--- a/bsg_misc/bsg_clkmux.v
+++ /dev/null
@@ -1,25 +0,0 @@
-`include "bsg_defines.v"
-module bsg_clkmux #(`BSG_INV_PARAM(width_p)
-                 , `BSG_INV_PARAM(els_p)
-                 , harden_p = 0
-                 , script_p = 0
-                 , lg_els_lp=`BSG_SAFE_CLOG2(els_p)
-                 )
-   (
-    input [els_p-1:0][width_p-1:0] data_i
-    ,input [lg_els_lp-1:0] sel_i
-    ,output data_o
-    );
-
-   if (els_p == 1)
-     begin
-      assign data_o = data_i;
-      wire unused = sel_i;
-     end
-   else
-     assign data_o = data_i[sel_i];
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_clkmux)
-
diff --git a/bsg_misc/bsg_counter_up_down.v b/bsg_misc/bsg_counter_up_down.v
index 621fe984..2c33a9bb 100644
--- a/bsg_misc/bsg_counter_up_down.v
+++ b/bsg_misc/bsg_counter_up_down.v
@@ -26,7 +26,6 @@
 module bsg_counter_up_down #( parameter `BSG_INV_PARAM(max_val_p    )
                                      , parameter `BSG_INV_PARAM(init_val_p   )
                                      , parameter `BSG_INV_PARAM(max_step_p   )
-                                     , disable_overflow_warning_p = 0
 
                                      //localpara
                                      , parameter step_width_lp =
@@ -60,9 +59,9 @@ always_ff @(posedge clk_i)
 
 //synopsys translate_off
   always_ff @ (negedge clk_i) begin
-	  if (!disable_overflow_warning_p && (count_o==max_val_p) & up_i & ~down_i  & (reset_i === 1'b0))
+	  if ((count_o==max_val_p) & up_i & ~down_i  & (reset_i === 1'b0))
 		  $display("%m error: counter overflow at time %t", $time);
-	  if (!disable_overflow_warning_p && (count_o==0)          & down_i & ~up_i & (reset_i === 1'b0))
+	  if ((count_o==0)          & down_i & ~up_i & (reset_i === 1'b0))
 		  $display("%m error: counter underflow at time %t", $time);
   end
 //synopsys translate_on
diff --git a/bsg_test/bsg_nonsynth_clock_gen.v b/bsg_test/bsg_nonsynth_clock_gen.v
index bd6b800d..bb0bf428 100644
--- a/bsg_test/bsg_nonsynth_clock_gen.v
+++ b/bsg_test/bsg_nonsynth_clock_gen.v
@@ -2,6 +2,8 @@
 // this helps with x prop mode in VCS
 `include "bsg_defines.v"
 
+`timescale 1ps/1ps
+
 module bsg_nonsynth_clock_gen
   #(parameter `BSG_INV_PARAM(cycle_time_p))
    (output bit o);
diff --git a/bsg_test/bsg_nonsynth_dpi_clock_gen.v b/bsg_test/bsg_nonsynth_dpi_clock_gen.v
index f0928ad7..9fcb4674 100644
--- a/bsg_test/bsg_nonsynth_dpi_clock_gen.v
+++ b/bsg_test/bsg_nonsynth_dpi_clock_gen.v
@@ -39,14 +39,12 @@ module bsg_nonsynth_dpi_clock_gen
    import "DPI-C" function int bsg_dpi_clock_gen_register(input longint cycle_time_p, input string hierarchy);
    localparam longint cycle_time_lp = {32'b0, cycle_time_p[31:0]};
    
-   `ifndef VERILATOR
    if(cycle_time_p % 2 != 0)
      $fatal(1, "BSG ERROR (%M): cycle_time_p must be divisible by 2");
    
    if(cycle_time_p <= 0)
      $fatal(1, "BSG ERROR (%M): cycle_time_p must be greater than 0");
-   `endif  
-
+   
    initial begin
       $display("BSG INFO: bsg_nonsynth_dpi_clock_gen (initial begin)");
       $display("BSG INFO:     Instantiation: %M");
diff --git a/hard/common/bsg_mem/.gitignore b/hard/common/bsg_mem/.gitignore
deleted file mode 100644
index 39c60c5a..00000000
--- a/hard/common/bsg_mem/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-*.v
diff --git a/hard/common/bsg_mem/Makefile b/hard/common/bsg_mem/Makefile
deleted file mode 100644
index 0b08c80f..00000000
--- a/hard/common/bsg_mem/Makefile
+++ /dev/null
@@ -1,17 +0,0 @@
-
-all:
-	python bsg_mem_generator.py memgen.json 1rw  0 > bsg_mem_1rw_sync.v
-	python bsg_mem_generator.py memgen.json 1rw  1 > bsg_mem_1rw_sync_mask_write_bit.v
-	python bsg_mem_generator.py memgen.json 1rw  8 > bsg_mem_1rw_sync_mask_write_byte.v
-	python bsg_mem_generator.py memgen.json 2rw  0 > bsg_mem_2rw_sync.v
-	python bsg_mem_generator.py memgen.json 2rw  1 > bsg_mem_2rw_sync_mask_write_bit.v
-	python bsg_mem_generator.py memgen.json 2rw  8 > bsg_mem_2rw_sync_mask_write_byte.v
-	python bsg_mem_generator.py memgen.json 1r1w 0 > bsg_mem_1r1w_sync.v
-	python bsg_mem_generator.py memgen.json 1r1w 1 > bsg_mem_1r1w_sync_mask_write_bit.v
-	python bsg_mem_generator.py memgen.json 1r1w 8 > bsg_mem_1r1w_sync_mask_write_byte.v
-	python bsg_mem_generator.py memgen.json 2r1w 0 > bsg_mem_2r1w_sync.v
-	python bsg_mem_generator.py memgen.json 3r1w 0 > bsg_mem_3r1w_sync.v
-
-clean:
-	rm *.v
-
diff --git a/hard/common/bsg_mem/README.md b/hard/common/bsg_mem/README.md
deleted file mode 100644
index 92fc174b..00000000
--- a/hard/common/bsg_mem/README.md
+++ /dev/null
@@ -1,22 +0,0 @@
-# BSG Hardened SRAM Wrapper Generator
-The portability layer for BaseJump STL relies on 1:1 swapping of RTL modules for their hardened
-equivalents. 
-
-All in all, there are 3 components to swapping out hardened SRAMs:
-- The SRAM macro headers. These are header files which define the mapping of a generic bsg\_mem port list to a foundry-specific SRAM macro. We assume a naming convention of <node>\_d<depth>\_w<width>\_<tag>\_<type>, although this is not necessary as long as the scheme is consistent. BaseJump STL users who wish to use this portability layer must first create a set of SRAM macro headers corresponding to their specific memory compilers.
-- The SRAM wrapper. This is a module which is pin identical to the synthesizable RTL implementation of the memory. For instance, bsg\_mem/bsg\_mem\_1rw\_sync.v contains only a synthesizable 1-port RAM HDL implementation found in bsg\_mem/bsg\_mem\_1rw\_sync\_synth.v. Our goal is to maintain this behavior for SRAMs which are too small or inconvenient to be hardened, while swapping out the definition for a hardened SRAM macro for specific implementations. We accomplish this by generating a wrapper which contains macros choosing which RAM widths and depths should be substituted. For instance,
-
-            `bsg_mem_1rw_sync_macro(512, 64, 2) else
-
-      will result in a 512x64 (mux 2) RAM taking the place of any instantiated 512x64 RAMs in the chip. The fallthrough default case is to synthesize the RAM.
-
-- The actual hardened SRAM macro. These should be named as per the scheme in the bsg\_mem\_\*.vh macro headers and their .lib / .v views should be accessible to the CAD tools as needed.
-
-Because the SRAMs generated depends on each project's requirements, it is most convenient if this wrapper is generated as well. We provide a generic generator script in this directory which can be used to generate a set of these SRAM wrappers which is process agnostic (The process information is included based on the .vh macro headers). The input to this generator script (bsg\_mem\_generator.py) is a json file. We have a sample memgen.json in this directory. This same memgen.json can be used for feeding the SRAM generator itself, which is useful for keeping front-end and back-end in sync. An example line from the memgen.json is:
-
-        {"ports": "1rw" , "width":  128, "depth": 1024, "mux": 2, "type": "1rf", mask: 1, "adbanks": 2, "awbanks": 2},
-
-## Sample Usage
-        python bsg_mem_generator.py <memgen.json> <ports> <mask>
-	    python bsg_mem_generator.py memgen.json 1rw  0 > bsg_mem_1rw_sync.v
-
diff --git a/hard/common/bsg_mem/bsg_mem_generator.py b/hard/common/bsg_mem/bsg_mem_generator.py
deleted file mode 100755
index e3f03649..00000000
--- a/hard/common/bsg_mem/bsg_mem_generator.py
+++ /dev/null
@@ -1,796 +0,0 @@
-#!/usr/bin/python
-from __future__ import print_function
-
-import argparse
-import json
-import os
-
-bsg_mem_1r1w_sync_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_1r1w_sync_macros.vh"
-
-  module bsg_mem_1r1w_sync
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-    (
-      input clk_i
-      , input reset_i
-
-      , input w_v_i
-      , input [addr_width_lp-1:0] w_addr_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_data_i
-
-      , input r_v_i
-      , input [addr_width_lp-1:0] r_addr_i
-
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r_data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1r1w_sync_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_1r1w_sync)
-"""
-
-bsg_mem_1r1w_sync_mask_write_bit_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_1r1w_sync_mask_write_bit_macros.vh"
-
-  module bsg_mem_1r1w_sync_mask_write_bit
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-    (
-      input clk_i
-      , input reset_i
-
-      , input w_v_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_mask_i
-      , input [addr_width_lp-1:0] w_addr_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_data_i
-
-      , input r_v_i
-      , input [addr_width_lp-1:0] r_addr_i
-
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r_data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1r1w_sync_mask_write_bit_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_1r1w_sync_mask_write_bit)
-"""
-
-bsg_mem_1r1w_sync_mask_write_byte_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_1r1w_sync_mask_write_byte_macros.vh"
-
-  module bsg_mem_1r1w_sync_mask_write_byte
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter write_mask_width_lp=width_p>>3
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-    (
-      input clk_i
-      , input reset_i
-
-      , input w_v_i
-      , input [`BSG_SAFE_MINUS(write_mask_width_lp,1):0] w_mask_i
-      , input [addr_width_lp-1:0] w_addr_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_data_i
-
-      , input r_v_i
-      , input [addr_width_lp-1:0] r_addr_i
-
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r_data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1r1w_sync_mask_write_byte_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_1r1w_sync_mask_write_byte)
-"""
-
-bsg_mem_1rw_sync_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_1rw_sync_macros.vh"
-
-module bsg_mem_1rw_sync #(parameter `BSG_INV_PARAM(width_p)
-                          , parameter `BSG_INV_PARAM(els_p)
-                          , parameter latch_last_read_p=0
-                          , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-                          , parameter verbose_if_synth_p=0
-                          , parameter enable_clock_gating_p=0
-                          , parameter harden_p=1
-                          )
-   (input   clk_i
-    , input reset_i
-    , input [`BSG_SAFE_MINUS(width_p,1):0] data_i
-    , input [addr_width_lp-1:0] addr_i
-    , input v_i
-    , input w_i
-    , output logic [`BSG_SAFE_MINUS(width_p,1):0]  data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (latch_last_read_p && !{latch_last_read_en})
-        $error("BSG ERROR: latch_last_read_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1rw_sync_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.latch_last_read_p(latch_last_read_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-endmodule
-"""
-
-bsg_mem_1rw_sync_mask_write_bit_template = """
-
-  `include "bsg_defines.v"
-  `include "bsg_mem_1rw_sync_mask_write_bit_macros.vh"
-
-module bsg_mem_1rw_sync_mask_write_bit #(parameter `BSG_INV_PARAM(width_p)
-                          , parameter `BSG_INV_PARAM(els_p)
-                          , parameter latch_last_read_p=0
-                          , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-                          , parameter enable_clock_gating_p=0
-                          , parameter harden_p=1
-                          )
-   (input   clk_i
-    , input reset_i
-    , input [`BSG_SAFE_MINUS(width_p,1):0] data_i
-    , input [addr_width_lp-1:0] addr_i
-    , input v_i
-    , input [`BSG_SAFE_MINUS(width_p,1):0] w_mask_i
-    , input w_i
-    , output logic [`BSG_SAFE_MINUS(width_p,1):0]  data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (latch_last_read_p && !{latch_last_read_en})
-        $error("BSG ERROR: latch_last_read_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1rw_sync_mask_write_bit_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.latch_last_read_p(latch_last_read_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-endmodule
-"""
-
-bsg_mem_1rw_sync_mask_write_byte_template = """
-
-  `include "bsg_defines.v"
-  `include "bsg_mem_1rw_sync_mask_write_byte_macros.vh"
-
-module bsg_mem_1rw_sync_mask_write_byte #(parameter `BSG_INV_PARAM(data_width_p)
-                          , parameter `BSG_INV_PARAM(els_p)
-                          , parameter latch_last_read_p=0
-                          , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-                          , parameter write_mask_width_lp=data_width_p>>3
-                          , parameter enable_clock_gating_p=0
-                          , parameter harden_p=1
-                          )
-   (input   clk_i
-    , input reset_i
-    , input [`BSG_SAFE_MINUS(data_width_p,1):0] data_i
-    , input [addr_width_lp-1:0] addr_i
-    , input v_i
-    , input [`BSG_SAFE_MINUS(write_mask_width_lp,1):0] write_mask_i
-    , input w_i
-    , output logic [`BSG_SAFE_MINUS(data_width_p,1):0]  data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (latch_last_read_p && !{latch_last_read_en})
-        $error("BSG ERROR: latch_last_read_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_1rw_sync_mask_write_byte_synth #(
-        .data_width_p(data_width_p)
-        ,.els_p(els_p)
-        ,.latch_last_read_p(latch_last_read_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating data_width_p=%d, els_p=%d (%m)", data_width_p, els_p);
-        end
-    //synopsys translate_on
-endmodule
-"""
-
-bsg_mem_2r1w_sync_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_2r1w_sync_macros.vh"
-
-  module bsg_mem_2r1w_sync
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter enable_clock_gating_p=0
-    )
-    (
-      input clk_i
-      , input reset_i
-
-      , input w_v_i
-      , input [addr_width_lp-1:0] w_addr_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_data_i
-
-      , input r0_v_i
-      , input [addr_width_lp-1:0] r0_addr_i
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r0_data_o
-
-      , input r1_v_i
-      , input [addr_width_lp-1:0] r1_addr_i
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r1_data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_2r1w_sync_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_2r1w_sync)
-"""
-
-bsg_mem_2rw_sync_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_2rw_sync_macros.vh"
-
-  module bsg_mem_2rw_sync
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] a_data_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] b_data_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] a_data_o
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] b_data_o
-  );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_2rw_sync_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync)
-"""
-
-bsg_mem_2rw_sync_mask_write_bit_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_2rw_sync_mask_write_bit_macros.vh"
-
-  module bsg_mem_2rw_sync_mask_write_bit
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] a_data_i
-  , input [`BSG_SAFE_MINUS(width_p,1):0] a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] b_data_i
-  , input [`BSG_SAFE_MINUS(width_p,1):0] b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] a_data_o
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] b_data_o
-  );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_2rw_sync_mask_write_bit_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_bit)
-"""
-
-bsg_mem_2rw_sync_mask_write_byte_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_2rw_sync_mask_write_byte_macros.vh"
-
-  module bsg_mem_2rw_sync_mask_write_byte
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter write_mask_width_lp=data_width_p>>3
-      , parameter harden_p=1
-      , parameter disable_collision_warning_p=0
-      , parameter enable_clock_gating_p=0
-    )
-  ( input                      clk_i
-  , input                      reset_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] a_data_i
-  , input [`BSG_SAFE_MINUS(write_mask_width_lp,1):0] a_w_mask_i
-  , input [addr_width_lp-1:0]  a_addr_i
-  , input                      a_v_i
-  , input                      a_w_i
-
-  , input [`BSG_SAFE_MINUS(width_p,1):0] b_data_i
-  , input [`BSG_SAFE_MINUS(write_mask_width_lp,1):0] b_w_mask_i
-  , input [addr_width_lp-1:0]  b_addr_i
-  , input                      b_v_i
-  , input                      b_w_i
-
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] a_data_o
-  , output logic [`BSG_SAFE_MINUS(width_p,1):0] b_data_o
-  );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-      if (disable_collision_warning_p && !{disable_collision_warning_en})
-        $warning("BSG ERROR: disable_collision_warning_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_2rw_sync_mask_write_byte_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_2rw_sync_mask_write_byte)
-"""
-
-bsg_mem_3r1w_sync_template = """
-  `include "bsg_defines.v"
-  `include "bsg_mem_3r1w_sync_macros.vh"
-
-  module bsg_mem_3r1w_sync
-    #(parameter `BSG_INV_PARAM(width_p)
-      , parameter `BSG_INV_PARAM(els_p)
-      , parameter read_write_same_addr_p=0
-      , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
-      , parameter harden_p=1
-      , parameter enable_clock_gating_p=0
-    )
-    (
-      input clk_i
-      , input reset_i
-
-      , input w_v_i
-      , input [addr_width_lp-1:0] w_addr_i
-      , input [`BSG_SAFE_MINUS(width_p,1):0] w_data_i
-
-      , input r0_v_i
-      , input [addr_width_lp-1:0] r0_addr_i
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r0_data_o
-
-      , input r1_v_i
-      , input [addr_width_lp-1:0] r1_addr_i
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r1_data_o
-
-      , input r2_v_i
-      , input [addr_width_lp-1:0] r2_addr_i
-      , output logic [`BSG_SAFE_MINUS(width_p,1):0] r2_data_o
-    );
-
-    // synopsys translate_off
-    initial begin
-      if (read_write_same_addr_p && !{read_write_same_addr_en})
-        $error("BSG ERROR: read_write_same_addr_p is set but unsupported");
-      if (enable_clock_gating_p && !{enable_clock_gating_en})
-        $error("BSG ERROR: enable_clock_gating_p is set but unsupported");
-    end
-    // synopsys translate_on
-
-    if (0) begin end else
-    // Hardened macro selections
-    {sram_cfg}
-      begin: notmacro
-      bsg_mem_3r1w_sync_synth #(
-        .width_p(width_p)
-        ,.els_p(els_p)
-        ,.read_write_same_addr_p(read_write_same_addr_p)
-      ) synth (.*);
-    end
-
-    //synopsys translate_off
-      initial
-        begin
-           $display("## %L: instantiating width_p=%d, els_p=%d (%m)", width_p, els_p);
-        end
-    //synopsys translate_on
-
-  endmodule
-
-  `BSG_ABSTRACT_MODULE(bsg_mem_3r1w_sync)
-"""
-
-
-def print_ram(
-    memgen_json,
-    ports,
-    mask,
-    read_write_same_addr_en,
-    enable_clock_gating_en,
-    disable_collision_warning_en,
-    latch_last_read_en,
-):
-    fid = open(memgen_json, "r")
-    memgen_json = json.load(fid)
-    fid.close()
-
-    memgen_defaults = {
-        # Necessary
-        "ports": "xrxw",
-        "type": "xrf",
-        "width": -1,
-        "depth": -1,
-        # Defaults
-        "mask": 0,
-        "adbanks": 1,
-        "awbanks": 1,
-        "mux": "",
-        "seg": "",
-        "tag": "",
-    }
-
-    if int(mask) == 0:
-        maskstr = ""
-    elif int(mask) == 1:
-        maskstr = "_mask_write_bit"
-    elif int(mask) == 8:
-        maskstr = "_mask_write_byte"
-
-    template = globals()[
-        "bsg_mem_{ports}_sync{maskstr}_template".format(ports=ports, maskstr=maskstr)
-    ]
-
-    memgen_cfg = ""
-    for m in memgen_json["memories"]:
-        c = memgen_defaults.copy()
-        c.update(m)
-
-        if c["ports"] != ports:
-            continue
-
-        # Default tag is m<mux><seg> e.g. m2s, m2f
-        if c["tag"] == "":
-            if c["mux"] != "":
-                c["tag"] += "m{mux}".format(mux=c["mux"])
-            if c["seg"] != "":
-                c["tag"] += "s{seg}".format(seg=c["seg"])
-
-        if int(c["adbanks"]) != 1 or int(c["awbanks"]) != 1:
-            memgen_cfg += "\t`bsg_mem_{ports}_sync{maskstr}_banked_macro({depth},{width},{awbanks},{adbanks}) else\n".format(
-                ports=ports,
-                maskstr=maskstr,
-                depth=c["depth"],
-                width=c["width"],
-                awbanks=c["awbanks"],
-                adbanks=c["adbanks"],
-            )
-
-        memgen_cfg += "\t`bsg_mem_{ports}_sync{maskstr}_{_type}_macro({depth},{width},{tag}) else\n".format(
-            ports=ports,
-            maskstr=maskstr,
-            depth=c["depth"] / c["adbanks"],
-            width=c["width"] / c["awbanks"],
-            tag=c["tag"],
-            _type=c["type"],
-        )
-
-    print(
-        template.format(
-            sram_cfg=memgen_cfg,
-            read_write_same_addr_en=read_write_same_addr_en,
-            enable_clock_gating_en=enable_clock_gating_en,
-            disable_collision_warning_en=disable_collision_warning_en,
-            latch_last_read_en=latch_last_read_en,
-        )
-    )
-
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser()
-    parser.add_argument("memgen_json", help="The memgen.json file to parse")
-    parser.add_argument("ports", help="The xryw port configuration for the SRAM")
-    parser.add_argument("mask", help="The SRAM mask")
-    parser.add_argument(
-        "--read_write_same_addr_en",
-        action="store_true",
-        help="Whether to enable read_write_same_addr_p",
-    )
-    parser.add_argument(
-        "--enable_clock_gating_en",
-        action="store_true",
-        help="Whether to enable enable_clock_gating_p",
-    )
-    parser.add_argument(
-        "--disable_collision_warning_en",
-        action="store_true",
-        help="Whether to enable disable_collision_warning_p",
-    )
-    parser.add_argument(
-        "--latch_last_read_en",
-        action="store_false",
-        help="Whether to enable latch_last_read_p",
-    )
-    args = parser.parse_args()
-    read_write_same_addr_en = "(1'b1)" if args.read_write_same_addr_en else "(1'b0)"
-    enable_clock_gating_en = "(1'b1)" if args.enable_clock_gating_en else "(1'b0)"
-    disable_collision_warning_en = "(1'b1)" if args.disable_collision_warning_en else "(1'b0)"
-    latch_last_read_en = "(1'b1)" if args.latch_last_read_en else "(1'b0)"
-
-    print_ram(
-        args.memgen_json,
-        args.ports,
-        args.mask,
-        read_write_same_addr_en,
-        enable_clock_gating_en,
-        disable_collision_warning_en,
-        latch_last_read_en,
-    )
diff --git a/hard/common/bsg_mem/memgen.json b/hard/common/bsg_mem/memgen.json
deleted file mode 100644
index 2dabf6c1..00000000
--- a/hard/common/bsg_mem/memgen.json
+++ /dev/null
@@ -1,17 +0,0 @@
-{ "memories": [
-  {"ports": "1r1w", "width":   64, "depth":  512, "mux": 2, "type": "2rf"  },
-  {"ports": "1r1w", "width":   32, "depth": 1024, "mux": 2, "type": "2rf"  },
-  {"ports": "1r1w", "width":   64, "depth":  512, "mux": 2, "type": "2rf"   , "mask": 1},
-  {"ports": "1r1w", "width":   32, "depth": 1024, "mux": 2, "type": "2sram" , "mask": 1},
-  {"ports": "1r1w", "width":   64, "depth":  512, "mux": 2, "type": "2rf"   , "mask": 8},
-  {"ports": "1r1w", "width":   32, "depth": 1024, "mux": 2, "type": "2sram" , "mask": 8},
-  {"ports": "1rw" , "width":  128, "depth": 1024, "mux": 2, "type": "1rf"   , "adbanks": 2, "awbanks": 2},
-  {"ports": "1rw" , "width":   32, "depth":  128, "mux": 2, "type": "1sram"},
-  {"ports": "1rw" , "width":  128, "depth": 1024, "mux": 2, "type": "1rf"   , "mask": 1 , "adbanks": 2, "awbanks": 2},
-  {"ports": "1rw" , "width":   32, "depth":  128, "mux": 2, "type": "1sram" , "mask": 1},
-  {"ports": "1rw" , "width":  128, "depth": 1024, "mux": 2, "type": "1rf"   , "mask": 8 , "adbanks": 2, "awbanks": 2},
-  {"ports": "1rw" , "width":   32, "depth":  128, "mux": 2, "type": "1sram" , "mask": 8},
-  {"ports": "2r1w", "width":   64, "depth":   32, "mux": 2, "type": "2sram"},
-  {"ports": "3r1w", "width":   66, "depth":   32, "mux": 2, "type": "2sram"}
-  ]
-}
diff --git a/hard/generic/bsg_mem/Makefile b/hard/generic/bsg_mem/Makefile
deleted file mode 100644
index 47037b60..00000000
--- a/hard/generic/bsg_mem/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-
-all:
-	python bsg_mem_func_generator.py ../../common/bsg_mem/memgen.json > bsg_mem_func.v
-
-clean:
-	rm bsg_mem_func.v
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_macros.vh b/hard/generic/bsg_mem/bsg_mem_1r1w_sync_macros.vh
deleted file mode 100644
index f24917ab..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_1R1W_SYNC_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MACROS_VH
-
-`define bsg_mem_1r1w_2rf_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bit,tag)
-`define bsg_mem_1r1w_2sram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bits,tag)
-`define bsg_mem_1r1w_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bits,tag)
-
-`define bsg_mem_1r1w_sync_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_1r1w_sync_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh b/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh
deleted file mode 100644
index b694f67b..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_1R1W_SYNC_MASK_WRITE_BIT_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MASK_WRITE_BIT_MACROS_VH
-
-`define bsg_mem_1r1w_sync_mask_write_bit_2rf_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bits,tag)
-`define bsg_mem_1r1w_sync_mask_write_bit_2sram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bits,tag)
-`define bsg_mem_1r1w_sync_mask_write_bit_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_macro(words,bits,tag)
-
-`define bsg_mem_1r1w_sync_mask_write_bit_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_1r1w_sync_mask_write_bit_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh b/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh
deleted file mode 100644
index 63703037..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_1R1W_SYNC_MASK_WRITE_BYTE_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MASK_WRITE_BYTE_MACROS_VH
-
-`define bsg_mem_1r1w_sync_mask_write_byte_sync_mask_write_bit_2rf_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_1r1w_sync_mask_write_byte_sync_mask_write_bit_2sram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_1r1w_sync_mask_write_byte_sync_mask_write_bit_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits,tag)
-
-`define bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)         \
-    begin: macro                                             \
-      bsg_mem_1r1w_sync_mask_write_byte_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1rw_sync_macros.vh b/hard/generic/bsg_mem/bsg_mem_1rw_sync_macros.vh
deleted file mode 100644
index 708bf5fe..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1rw_sync_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_1RW_SYNC_MACROS_VH
-`define BSG_MEM_1RW_SYNC_MACROS_VH
-
-`define bsg_mem_1rw_sync_2rf_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_2sram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_macro(words,bits,tag)
-
-`define bsg_mem_1rw_sync_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      bsg_mem_1rw_sync_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end: macro
-
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh b/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
deleted file mode 100644
index d0252123..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,39 +0,0 @@
-
-`ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS
-`define BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS
-
-`define bsg_mem_1rw_sync_mask_write_bit_2rf_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_bit_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_mask_write_bit_2sram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_bit_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_mask_write_bit_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_bit_macro(words,bits,tag)
-
-`define bsg_mem_1rw_sync_mask_write_bit_macro(words,bits,tag) \
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_1rw_sync_mask_write_bit_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end: macro
-
-`define bsg_mem_1rw_sync_mask_write_bit_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && width_p == bits) begin: macro \
-    bsg_mem_1rw_sync_mask_write_bit_banked #(                     \
-      .width_p(width_p)                                                     \
-      ,.els_p(els_p)                                                        \
-      ,.latch_last_read_p(latch_last_read_p)                                \
-      ,.num_width_bank_p(wbank)                                             \
-      ,.num_depth_bank_p(dbank)                                             \
-    ) bmem (                                                                \
-      .clk_i(clk_i)                                                         \
-      ,.reset_i(reset_i)                                                    \
-      ,.v_i(v_i)                                                            \
-      ,.w_i(w_i)                                                            \
-      ,.addr_i(addr_i)                                                      \
-      ,.data_i(data_i)                                                      \
-      ,.w_mask_i(w_mask_i)                                                  \
-      ,.data_o(data_o)                                                      \
-    );                                                                      \
-  end: macro
-
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh b/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
deleted file mode 100644
index dd373335..00000000
--- a/hard/generic/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,39 +0,0 @@
-
-`ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS
-`define BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS
-
-`define bsg_mem_1rw_sync_mask_write_byte_2rf_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_mask_write_byte_2sram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_1rw_sync_mask_write_byte_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits,tag)
-
-`define bsg_mem_1rw_sync_mask_write_byte_macro(words,bits,tag) \
-  if (harden_p && els_p == words && data_width_p == bits)      \
-    begin: macro                                               \
-      bsg_mem_1rw_sync_mask_write_byte_w``bits``_d``words``_``tag``_hard (.*); \
-    end: macro
-
-`define bsg_mem_1rw_sync_mask_write_byte_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && data_width_p == bits) begin: macro        \
-      bsg_mem_1rw_sync_mask_write_byte_banked #(                              \
-        .data_width_p(data_width_p)                                           \
-        ,.els_p(els_p)                                                        \
-        ,.latch_last_read_p(latch_last_read_p)                                \
-        ,.num_width_bank_p(wbank)                                             \
-        ,.num_depth_bank_p(dbank)                                             \
-      ) bmem (                                                                \
-        .clk_i(clk_i)                                                         \
-        ,.reset_i(reset_i)                                                    \
-        ,.v_i(v_i)                                                            \
-        ,.w_i(w_i)                                                            \
-        ,.addr_i(addr_i)                                                      \
-        ,.data_i(data_i)                                                      \
-        ,.write_mask_i(write_mask_i)                                          \
-        ,.data_o(data_o)                                                      \
-      );                                                                      \
-    end: macro
-
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_2r1w_sync_macros.vh b/hard/generic/bsg_mem/bsg_mem_2r1w_sync_macros.vh
deleted file mode 100644
index 664c6003..00000000
--- a/hard/generic/bsg_mem/bsg_mem_2r1w_sync_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_2R1W_SYNC_MACROS_VH
-`define BSG_MEM_2R1W_SYNC_MACROS_VH
-
-`define bsg_mem_2r1w_sync_2rf_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_macro(words,bits,tag)
-`define bsg_mem_2r1w_sync_2sram_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_macro(words,bits,tag)
-`define bsg_mem_2r1w_sync_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_macro(words,bits,tag)
-
-`define bsg_mem_2r1w_sync_macro(words,bits,tag)      \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      bsg_mem_2r1w_sync_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end: macro
-
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_2rw_sync_macros.vh b/hard/generic/bsg_mem/bsg_mem_2rw_sync_macros.vh
deleted file mode 100644
index 5569a951..00000000
--- a/hard/generic/bsg_mem/bsg_mem_2rw_sync_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_2RW_SYNC_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MACROS_VH
-
-`define bsg_mem_2rw_sync_2rf_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_macro(words,bits,tag)
-`define bsg_mem_2rw_sync_2sram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_macro(words,bits,tag)
-`define bsg_mem_2rw_sync_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_macro(words,bits,tag)
-
-`define bsg_mem_2rw_sync_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_2rw_sync_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh b/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh
deleted file mode 100644
index 39b24815..00000000
--- a/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_2RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-
-`define bsg_mem_2rw_sync_mask_write_bit_2rf_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_bit_macro(words,bits,tag)
-`define bsg_mem_2rw_sync_mask_write_bit_2sram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_bit_macro(words,bits,tag)
-`define bsg_mem_2rw_sync_mask_write_bit_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_bit_macro(words,bits,tag)
-
-`define bsg_mem_2rw_sync_mask_write_bit_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_2rw_sync_mask_write_bit_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh b/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh
deleted file mode 100644
index 5e4cdaee..00000000
--- a/hard/generic/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_2RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-
-`define bsg_mem_2r1w_sync_mask_write_byte_2rf_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_2r1w_sync_mask_write_byte_2sram_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_mask_write_byte_macro(words,bits,tag)
-`define bsg_mem_2r1w_sync_mask_write_byte_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_2r1w_sync_mask_write_byte_macro(words,bits,tag)
-
-`define bsg_mem_2rw_sync_mask_write_byte_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      bsg_mem_2rw_sync_mask_write_byte_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end
-      
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_3r1w_sync_macros.vh b/hard/generic/bsg_mem/bsg_mem_3r1w_sync_macros.vh
deleted file mode 100644
index 9c9e1a99..00000000
--- a/hard/generic/bsg_mem/bsg_mem_3r1w_sync_macros.vh
+++ /dev/null
@@ -1,19 +0,0 @@
-
-`ifndef BSG_MEM_3R1W_SYNC_MACROS
-`define BSG_MEM_3R1W_SYNC_MACROS
-
-`define bsg_mem_3r1w_sync_2rf_macro(words,bits,tag) \
-  `bsg_mem_3r1w_sync_macro(words,bits,tag)
-`define bsg_mem_3r1w_sync_2sram_macro(words,bits,tag) \
-  `bsg_mem_3r1w_sync_macro(words,bits,tag)
-`define bsg_mem_3r1w_sync_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_3r1w_sync_macro(words,bits,tag)
-
-`define bsg_mem_3r1w_sync_macro(words,bits,tag)      \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      bsg_mem_3r1w_sync_w``bits``_d``words``_``tag``_hard mem (.*); \
-    end: macro
-
-`endif
-
diff --git a/hard/generic/bsg_mem/bsg_mem_func_generator.py b/hard/generic/bsg_mem/bsg_mem_func_generator.py
deleted file mode 100755
index abb86262..00000000
--- a/hard/generic/bsg_mem/bsg_mem_func_generator.py
+++ /dev/null
@@ -1,66 +0,0 @@
-#!/usr/bin/python
-from __future__ import print_function
-
-import argparse
-import json
-
-
-def print_hard(cfg,):
-    print(
-        """
-  module bsg_mem_{ports}_sync{maskstr}_w{width_p}_d{depth_p}_m{tag_p}_hard;
-      bsg_mem_{ports}_sync{maskstr}_synth #(
-        .width_p({width_p})
-        ,.els_p({depth_p})
-      ) func (.*);
-  endmodule
-  
-  """.format(
-            ports=cfg["ports"],
-            maskstr=cfg["maskstr"],
-            width_p=cfg["width"] / cfg["awbanks"],
-            depth_p=cfg["depth"] / cfg["adbanks"],
-            tag_p=cfg["tag"],
-        )
-    )
-
-
-def create_rams(memgen_json):
-    fid = open(memgen_json, "r")
-    memgen_json = json.load(fid)
-    fid.close()
-
-    memgen_defaults = {
-        # Necessary
-        "ports": "xrxw",
-        "type": "xrf",
-        "width": -1,
-        "depth": -1,
-        "tag": -1,
-        # Defaults
-        "mask": 0,
-        "adbanks": 1,
-        "awbanks": 1,
-    }
-
-    memgen_cfg = ""
-    for m in memgen_json["memories"]:
-        c = memgen_defaults.copy()
-        c.update(m)
-        if c["mask"] == 8:
-            c["maskstr"] = "_mask_write_byte"
-        elif c["mask"] == 1:
-            c["maskstr"] = "_mask_write_bit"
-        else:
-            c["maskstr"] = ""
-        print_hard(c)
-
-    return memgen_cfg
-
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser()
-    parser.add_argument("memgen_json", help="The memgen.json file to parse")
-    args = parser.parse_args()
-
-    create_rams(args.memgen_json)
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync.v b/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync.v
new file mode 100644
index 00000000..6eabf8fe
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync.v
@@ -0,0 +1,60 @@
+
+`include "bsg_mem_1r1w_sync_macros.vh"
+
+module bsg_mem_1r1w_sync
+  #(parameter `BSG_INV_PARAM(width_p)
+    , parameter `BSG_INV_PARAM(els_p)
+    , parameter read_write_same_addr_p=0
+    , parameter addr_width_lp=`BSG_SAFE_CLOG2(els_p)
+    , parameter harden_p=1
+    , parameter disable_collision_warning_p=0
+    , parameter enable_clock_gating_p=0
+  )
+  (
+    input clk_i
+    , input reset_i
+    
+    , input w_v_i
+    , input [addr_width_lp-1:0] w_addr_i
+    , input [width_p-1:0] w_data_i
+
+    , input r_v_i
+    , input [addr_width_lp-1:0] r_addr_i
+    
+    , output logic [width_p-1:0] r_data_o
+  );
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_1r1w_sync_macro(32,92,1) else
+    begin: notmacro
+    bsg_mem_1r1w_sync_synth #(
+      .width_p(width_p)
+      ,.els_p(els_p)
+      ,.read_write_same_addr_p(read_write_same_addr_p)
+    ) synth (.*); 
+  end
+
+   //synopsys translate_off
+   initial
+     begin
+        $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)",width_p,els_p,read_write_same_addr_p,harden_p);
+     end
+
+   always_ff @(negedge clk_i)
+     if (w_v_i)
+       begin
+          assert ((reset_i === 'X) || (reset_i === 1'b1) || (w_addr_i < els_p))
+            else $error("Invalid address %x to %m of size %x\n", w_addr_i, els_p);
+
+          assert ((reset_i === 'X) || (reset_i === 1'b1) || ~(r_addr_i == w_addr_i && w_v_i && r_v_i && !read_write_same_addr_p && !disable_collision_warning_p))
+            else
+              begin
+                 $error("X'ing matched read address %x (%m)",r_addr_i);
+              end
+       end
+   //synopsys translate_on
+
+
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_1r1w_sync)
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync_macros.vh
index fbc93777..61cb9802 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_1r1w_sync_macros.vh
@@ -2,31 +2,10 @@
 `ifndef BSG_MEM_1R1W_SYNC_MACROS_VH
 `define BSG_MEM_1R1W_SYNC_MACROS_VH
 
-`define bsg_mem_1r1w_sync_2rf_macro(words,bits,tag)\
+`define bsg_mem_1r1w_sync_macro(words,bits,mux)\
   if (harden_p && els_p == words && width_p == bits)          \
     begin: macro                                              \
-    gf14_1r1w_d``words``_w``bits``_``tag``_2rf               \
-      mem (                                                   \
-      .CLKA   (clk_i)                                         \
-      ,.CLKB  (clk_i)                                         \
-      ,.CENA  (~r_v_i)                                        \
-      ,.AA    (r_addr_i)                                      \
-      ,.QA    (r_data_o)                                      \
-      ,.CENB  (~w_v_i)                                        \
-      ,.AB    (w_addr_i)                                      \
-      ,.DB    (w_data_i)                                      \
-      ,.EMAA  (3'b011)                                        \
-      ,.EMAB  (3'b011)                                        \
-      ,.EMASA (1'b0)                                          \
-      ,.STOV  (1'b0)                                          \
-      ,.RET1N (1'b1)                                          \
-    );                                                        \
-  end
-
-`define bsg_mem_1r1w_sync_2sram_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-    gf14_1r1w_d``words``_w``bits``_``tag``_2sram             \
+    gf14_1r1w_d``words``_w``bits``_m``mux                     \
       mem (                                                   \
       .CLKA   (clk_i)                                         \
       ,.CLKB  (clk_i)                                         \
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync.v b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync.v
new file mode 100644
index 00000000..9b5c9c41
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync.v
@@ -0,0 +1,79 @@
+
+`include "bsg_mem_1rw_sync_macros.vh"
+
+module bsg_mem_1rw_sync #( parameter `BSG_INV_PARAM(width_p )
+                         , parameter `BSG_INV_PARAM(els_p )
+                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
+                         // whether to substitute a 1r1w
+                         , parameter substitute_1r1w_p = 1
+                         , parameter harden_p = 1
+                         , parameter latch_last_read_p = 1
+                         )
+  ( input                     clk_i
+  , input                     reset_i
+
+  , input [width_p-1:0]       data_i
+  , input [addr_width_lp-1:0] addr_i
+  , input                     v_i
+  , input                     w_i
+
+  , output logic [width_p-1:0]  data_o
+  );
+
+  wire unused = reset_i;
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_1rw_sync_macro(512,64,4) else
+  `bsg_mem_1rw_sync_macro(256,96,2) else
+  `bsg_mem_1rw_sync_macro(1024,46,4) else
+  `bsg_mem_1rw_sync_macro(16,32,2) else
+  `bsg_mem_1rw_sync_macro(64,49,4) else
+
+  // no hardened version found
+    begin : z
+      // we substitute a 1r1w macro
+      // fixme: theoretically there may be
+      // a more efficient way to generate a 1rw synthesized ram
+      if (substitute_1r1w_p)
+        begin: s1r1w
+          logic [width_p-1:0] data_lo;
+        
+          bsg_mem_1r1w #( .width_p(width_p)
+                        , .els_p(els_p)
+                        , .read_write_same_addr_p(0)
+                        )
+            mem
+              (.w_clk_i   (clk_i)
+              ,.w_reset_i(reset_i)
+              ,.w_v_i    (v_i & w_i)
+              ,.w_addr_i (addr_i)
+              ,.w_data_i (data_i)
+              ,.r_addr_i (addr_i)
+              ,.r_v_i    (v_i & ~w_i)
+              ,.r_data_o (data_lo)
+              );
+          
+          // register output data to convert sync to async
+          always_ff @(posedge clk_i) begin
+            data_o <= data_lo;
+          end
+        end // block: s1r1w
+      else
+        begin: notmacro
+          bsg_mem_1rw_sync_synth # (.width_p(width_p), .els_p(els_p), .latch_last_read_p(latch_last_read_p))
+            synth
+              (.*);
+        end // block: notmacro
+      end // block: z
+
+
+  // synopsys translate_off
+  initial
+    begin
+      $display("## %L: instantiating width_p=%d, els_p=%d, substitute_1r1w_p=%d (%m)",width_p,els_p,substitute_1r1w_p);
+    end
+  // synopsys translate_on
+
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_1rw_sync)
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_macros.vh
index cb60c95a..e8c48bf6 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_macros.vh
@@ -2,10 +2,10 @@
 `ifndef BSG_MEM_1RW_SYNC_MACROS_VH
 `define BSG_MEM_1RW_SYNC_MACROS_VH
 
-`define bsg_mem_1rw_sync_1rf_macro(words,bits,tag)       \
+`define bsg_mem_1rw_sync_macro(words,bits,mux)       \
   if (harden_p && els_p == words && width_p == bits) \
     begin: macro                                     \
-      gf14_1rw_d``words``_w``bits``_``tag``_1rf     \
+      gf14_1rw_d``words``_w``bits``_m``mux           \
         mem                                          \
           ( .CLK   ( clk_i  )                        \
           , .A     ( addr_i )                        \
@@ -21,43 +21,5 @@
           );                                         \
     end: macro
 
-`define bsg_mem_1rw_sync_1sram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      gf14_1rw_d``words``_w``bits``_``tag``_1sram   \
-        mem                                          \
-          ( .CLK   ( clk_i  )                        \
-          , .A     ( addr_i )                        \
-          , .D     ( data_i )                        \
-          , .Q     ( data_o )                        \
-          , .CEN   ( ~v_i   )                        \
-          , .GWEN  ( ~w_i   )                        \
-          , .RET1N ( 1'b1   )                        \
-          , .STOV  ( 1'b0   )                        \
-          , .EMA   ( 3'b011 )                        \
-          , .EMAW  ( 2'b01  )                        \
-          , .EMAS  ( 1'b0   )                        \
-          );                                         \
-    end: macro
-
-`define bsg_mem_1rw_sync_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && width_p == bits) begin: macro \
-    bsg_mem_1rw_sync_banked #(                                              \
-      .width_p(width_p)                                                     \
-      ,.els_p(els_p)                                                        \
-      ,.latch_last_read_p(latch_last_read_p)                                \
-      ,.num_width_bank_p(wbank)                                             \
-      ,.num_depth_bank_p(dbank)                                             \
-    ) bmem (                                                                \
-      .clk_i(clk_i)                                                         \
-      ,.reset_i(reset_i)                                                    \
-      ,.v_i(v_i)                                                            \
-      ,.w_i(w_i)                                                            \
-      ,.addr_i(addr_i)                                                      \
-      ,.data_i(data_i)                                                      \
-      ,.data_o(data_o)                                                      \
-    );                                                                      \
-  end: macro
-
 `endif
 
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit.v b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit.v
new file mode 100644
index 00000000..203a323b
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit.v
@@ -0,0 +1,59 @@
+
+`include "bsg_mem_1rw_sync_mask_write_bit_macros.vh"
+
+module bsg_mem_1rw_sync_mask_write_bit #( parameter `BSG_INV_PARAM(width_p )
+                                        , parameter `BSG_INV_PARAM(els_p )
+                                        , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
+                                        , parameter harden_p = 1
+                                        , parameter latch_last_read_p = 1
+                                        )
+  ( input                       clk_i
+  , input                       reset_i
+  , input [width_p-1:0]         data_i
+  , input [addr_width_lp-1:0]   addr_i
+  , input                       v_i
+  , input [width_p-1:0]         w_mask_i
+  , input                       w_i
+  , output logic [width_p-1:0]  data_o
+  );
+
+  wire unused = reset_i;
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_1rw_sync_mask_write_bit_macro( 64,15,4) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro( 64, 7,4) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(256,48,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(256,30,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(256,4,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(256,34,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(512,4,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(512,32,4) else
+  `bsg_mem_1rw_sync_mask_write_bit_macro(128,152,2) else
+
+  `bsg_mem_1rw_sync_mask_write_bit_macro(64,58,2) else
+  `bsg_mem_1rw_sync_mask_write_bit_banked_macro(64,116,2,1) else
+  
+    begin: notmacro
+      bsg_mem_1rw_sync_mask_write_bit_synth #(.width_p(width_p), .els_p(els_p), .latch_last_read_p(latch_last_read_p))
+        synth
+          (.*);
+    end // block: notmacro
+
+  // synopsys translate_off
+  always_ff @(posedge clk_i)
+    begin
+      if (v_i)
+        assert (addr_i < els_p)
+          else $error("Invalid address %x to %m of size %x\n", addr_i, els_p);
+    end
+
+  initial
+    begin
+      $display("## %L: instantiating width_p=%d, els_p=%d (%m)",width_p,els_p);
+    end
+// synopsys translate_on
+
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_1rw_sync_mask_write_bit)
+
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
index 5c4100ee..3c4f7782 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
@@ -2,30 +2,10 @@
 `ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS
 `define BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS
 
-`define bsg_mem_1rw_sync_mask_write_bit_1rf_macro(words,bits,tag) \
+`define bsg_mem_1rw_sync_mask_write_bit_macro(words,bits,mux) \
   if (harden_p && els_p == words && width_p == bits)          \
     begin: macro                                              \
-      gf14_1rw_d``words``_w``bits``_``tag``_bit_1rf          \
-        mem                                                   \
-          ( .CLK   ( clk_i     )                              \
-          , .A     ( addr_i    )                              \
-          , .D     ( data_i    )                              \
-          , .Q     ( data_o    )                              \
-          , .CEN   ( ~v_i      )                              \
-          , .GWEN  ( ~w_i      )                              \
-          , .WEN   ( ~w_mask_i )                              \
-          , .RET1N ( 1'b1      )                              \
-          , .STOV  ( 1'b0      )                              \
-          , .EMA   ( 3'b011    )                              \
-          , .EMAW  ( 2'b01     )                              \
-          , .EMAS  ( 1'b0      )                              \
-          );                                                  \
-    end: macro
-
-`define bsg_mem_1rw_sync_mask_write_bit_1sram_macro(words,bits,tag) \
-  if (harden_p && els_p == words && width_p == bits)          \
-    begin: macro                                              \
-      gf14_1rw_d``words``_w``bits``_``tag``_bit_1sram        \
+      gf14_1rw_d``words``_w``bits``_m``mux``_bit              \
         mem                                                   \
           ( .CLK   ( clk_i     )                              \
           , .A     ( addr_i    )                              \
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte.v b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte.v
new file mode 100644
index 00000000..f92be881
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte.v
@@ -0,0 +1,55 @@
+
+`include "bsg_mem_1rw_sync_mask_write_byte_macros.vh"
+
+module bsg_mem_1rw_sync_mask_write_byte #( parameter `BSG_INV_PARAM(els_p )
+                                         , parameter `BSG_INV_PARAM(data_width_p )
+                                         , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
+                                         , parameter write_mask_width_lp = data_width_p>>3
+                                         , parameter harden_p = 1
+                                         , parameter latch_last_read_p = 1
+                                         )
+
+  ( input                           clk_i
+  , input                           reset_i
+  , input                           v_i
+  , input                           w_i
+  , input [addr_width_lp-1:0]       addr_i
+  , input [data_width_p-1:0]        data_i
+  , input [write_mask_width_lp-1:0] write_mask_i
+  , output logic [data_width_p-1:0] data_o
+  );
+
+  wire unused = reset_i;
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_1rw_sync_mask_write_byte_macro(512,64,2) else
+  `bsg_mem_1rw_sync_mask_write_byte_macro(1024,32,4) else
+  `bsg_mem_1rw_sync_mask_write_byte_macro(2048,64,4) else
+  `bsg_mem_1rw_sync_mask_write_byte_macro(4096,64,4) else
+  `bsg_mem_1rw_sync_mask_write_byte_macro(1024,32,4) else
+  `bsg_mem_1rw_sync_mask_write_byte_banked_macro(1024,256,8,1) else
+  // no hardened version found
+    begin : notmacro
+      bsg_mem_1rw_sync_mask_write_byte_synth #(.data_width_p(data_width_p), .els_p(els_p), .latch_last_read_p(latch_last_read_p))
+        synth
+          (.*);
+    end // block: notmacro
+
+
+  // synopsys translate_off
+  always_comb
+    begin
+      assert (data_width_p % 8 == 0)
+        else $error("data width should be a multiple of 8 for byte masking");
+    end
+
+  initial
+    begin
+      $display("## bsg_mem_1rw_sync_mask_write_byte: instantiating data_width_p=%d, els_p=%d (%m)",data_width_p,els_p);
+    end
+  // synopsys translate_on
+   
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_1rw_sync_mask_write_byte)
+
diff --git a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
index 16d47968..34b70ab9 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
@@ -2,7 +2,7 @@
 `ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS
 `define BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS
 
-`define bsg_mem_1rw_sync_mask_write_byte_1rf_macro(words,bits,tag) \
+`define bsg_mem_1rw_sync_mask_write_byte_macro(words,bits,mux) \
   if (harden_p && els_p == words && data_width_p == bits)      \
     begin: macro                                               \
       wire [data_width_p-1:0] wen;                             \
@@ -10,7 +10,7 @@
       for(j = 0; j < write_mask_width_lp; j++)                 \
         assign wen[8*j+:8] = {8{write_mask_i[j]}};             \
                                                                \
-      gf14_1rw_d``words``_w``bits``_``tag``_byte_1rf          \
+      gf14_1rw_d``words``_w``bits``_m``mux``_byte              \
         mem                                                    \
           ( .CLK   ( clk_i  )                                  \
           , .A     ( addr_i )                                  \
@@ -27,32 +27,6 @@
           );                                                   \
     end: macro
 
-`define bsg_mem_1rw_sync_mask_write_byte_1sram_macro(words,bits,tag) \
-  if (harden_p && els_p == words && data_width_p == bits)      \
-    begin: macro                                               \
-      wire [data_width_p-1:0] wen;                             \
-      genvar j;                                                \
-      for(j = 0; j < write_mask_width_lp; j++)                 \
-        assign wen[8*j+:8] = {8{write_mask_i[j]}};             \
-                                                               \
-      gf14_1rw_d``words``_w``bits``_``tag``_byte_1sram        \
-        mem                                                    \
-          ( .CLK   ( clk_i  )                                  \
-          , .A     ( addr_i )                                  \
-          , .D     ( data_i )                                  \
-          , .Q     ( data_o )                                  \
-          , .CEN   ( ~v_i   )                                  \
-          , .GWEN  ( ~w_i   )                                  \
-          , .WEN   ( ~wen   )                                  \
-          , .RET1N ( 1'b1   )                                  \
-          , .STOV  ( 1'b0   )                                  \
-          , .EMA   ( 3'b011 )                                  \
-          , .EMAW  ( 2'b01  )                                  \
-          , .EMAS  ( 1'b0   )                                  \
-          );                                                   \
-    end: macro
-
-
 `define bsg_mem_1rw_sync_mask_write_byte_banked_macro(words,bits,wbank,dbank) \
   if (harden_p && els_p == words && data_width_p == bits) begin: macro        \
       bsg_mem_1rw_sync_mask_write_byte_banked #(                              \
diff --git a/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync.v b/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync.v
new file mode 100644
index 00000000..ed17af25
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync.v
@@ -0,0 +1,96 @@
+
+`include "bsg_mem_2r1w_sync_macros.vh"
+
+module bsg_mem_2r1w_sync #( parameter `BSG_INV_PARAM(width_p )
+                          , parameter `BSG_INV_PARAM(els_p )
+                          , parameter read_write_same_addr_p = 0
+                          , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
+                          , parameter harden_p = 1
+                          , parameter substitute_2r1w_p = 0
+                          )
+  ( input clk_i
+  , input reset_i
+  
+  , input                     w_v_i
+  , input [addr_width_lp-1:0] w_addr_i
+  , input [width_p-1:0]       w_data_i
+  
+  , input                      r0_v_i
+  , input [addr_width_lp-1:0]  r0_addr_i
+  , output logic [width_p-1:0] r0_data_o
+  
+  , input                      r1_v_i
+  , input [addr_width_lp-1:0]  r1_addr_i
+  , output logic [width_p-1:0] r1_data_o
+  );
+
+  wire unused = reset_i;
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_2r1w_sync_macro(32,64,1) else
+  //`bsg_mem_2r1w_sync_macro(32,32,2) else
+
+  // no hardened version found
+    begin : z
+      if (substitute_2r1w_p)
+        begin: s2r1w
+          logic [width_p-1:0] r0_data_lo, r1_data_lo;
+
+          bsg_mem_2r1w #( .width_p(width_p)
+                        , .els_p(els_p)
+                        , .read_write_same_addr_p(0)
+                        )
+            mem
+              (.w_clk_i   (clk_i)
+              ,.w_reset_i(reset_i)
+              
+              ,.w_v_i    (w_v_i & w_v_i)
+              ,.w_addr_i (w_addr_i)
+              ,.w_data_i (w_data_i)
+              
+              ,.r0_v_i   (r0_v_i & ~r0_v_i)
+              ,.r0_addr_i(r0_addr_i)
+              ,.r0_data_o(r0_data_lo)
+              
+              ,.r1_v_i   (r1_v_i & ~r1_v_i)
+              ,.r1_addr_i(r1_addr_i)
+              ,.r1_data_o(r1_data_lo)
+              );
+
+          // register output data to convert sync to async
+          always_ff @(posedge clk_i) begin
+            r0_data_o <= r0_data_lo;
+            r1_data_o <= r1_data_lo;
+          end
+        end // block: s1r1w
+      else
+        begin: notmacro
+          bsg_mem_2r1w_sync_synth #(.width_p(width_p), .els_p(els_p), .read_write_same_addr_p(read_write_same_addr_p))
+            synth
+              (.*);
+        end // block: notmacro
+    end // block: z
+
+  //synopsys translate_off
+  always_ff @(posedge clk_i)
+    if (w_v_i)
+    begin
+      assert (w_addr_i < els_p)
+        else $error("Invalid address %x to %m of size %x\n", w_addr_i, els_p);
+
+      assert (~(r0_addr_i == w_addr_i && w_v_i && r0_v_i && !read_write_same_addr_p))
+        else $error("%m: port 0 Attempt to read and write same address");
+
+      assert (~(r1_addr_i == w_addr_i && w_v_i && r1_v_i && !read_write_same_addr_p))
+        else $error("%m: port 1 Attempt to read and write same address");
+    end
+
+  initial
+    begin
+      $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)",width_p,els_p,read_write_same_addr_p,harden_p);
+    end
+  //synopsys translate_on
+
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_2r1w_sync)
diff --git a/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync_macros.vh
index ccf6806c..8a45c5b2 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_2r1w_sync_macros.vh
@@ -2,10 +2,10 @@
 `ifndef BSG_MEM_2R1W_SYNC_MACROS_VH
 `define BSG_MEM_2R1W_SYNC_MACROS_VH
 
-`define bsg_mem_2r1w_sync_2rf_macro(words,bits,tag)      \
+`define bsg_mem_2r1w_sync_macro(words,bits,mux)      \
   if (harden_p && els_p == words && width_p == bits) \
     begin: macro                                     \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2rf    \
+      gf14_1r1w_d``words``_w``bits``_m``mux          \
         mem0                                         \
           ( .CLKA  ( clk_i     )                     \
           , .CLKB  ( clk_i     )                     \
@@ -21,44 +21,7 @@
           , .STOV  ( 1'b0      )                     \
           , .RET1N ( 1'b1      )                     \
           );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2rf    \
-        mem1                                         \
-          ( .CLKA  ( clk_i     )                     \
-          , .CLKB  ( clk_i     )                     \
-          , .CENA  ( ~r1_v_i   )                     \
-          , .AA    ( r1_addr_i )                     \
-          , .QA    ( r1_data_o )                     \
-          , .CENB  ( ~w_v_i    )                     \
-          , .AB    ( w_addr_i  )                     \
-          , .DB    ( w_data_i  )                     \
-          , .EMAA  ( 3'b011    )                     \
-          , .EMAB  ( 3'b011    )                     \
-          , .EMASA ( 1'b0      )                     \
-          , .STOV  ( 1'b0      )                     \
-          , .RET1N ( 1'b1      )                     \
-          );                                         \
-    end: macro
-
-`define bsg_mem_2r1w_sync_2sram_macro(words,bits,tag) \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2sram  \
-        mem0                                         \
-          ( .CLKA  ( clk_i     )                     \
-          , .CLKB  ( clk_i     )                     \
-          , .CENA  ( ~r0_v_i   )                     \
-          , .AA    ( r0_addr_i )                     \
-          , .QA    ( r0_data_o )                     \
-          , .CENB  ( ~w_v_i    )                     \
-          , .AB    ( w_addr_i  )                     \
-          , .DB    ( w_data_i  )                     \
-          , .EMAA  ( 3'b011    )                     \
-          , .EMAB  ( 3'b011    )                     \
-          , .EMASA ( 1'b0      )                     \
-          , .STOV  ( 1'b0      )                     \
-          , .RET1N ( 1'b1      )                     \
-          );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2sram  \
+      gf14_1r1w_d``words``_w``bits``_m``mux          \
         mem1                                         \
           ( .CLKA  ( clk_i     )                     \
           , .CLKB  ( clk_i     )                     \
diff --git a/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync.v b/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync.v
new file mode 100644
index 00000000..07545d0d
--- /dev/null
+++ b/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync.v
@@ -0,0 +1,68 @@
+
+`include "bsg_mem_3r1w_sync_macros.vh"
+
+module bsg_mem_3r1w_sync #( parameter `BSG_INV_PARAM(width_p )
+                          , parameter `BSG_INV_PARAM(els_p )
+                          , parameter read_write_same_addr_p = 0
+                          , parameter addr_width_lp = `BSG_SAFE_CLOG2(els_p)
+                          , parameter harden_p = 1
+                          )
+  ( input clk_i
+  , input reset_i
+
+  , input                     w_v_i
+  , input [addr_width_lp-1:0] w_addr_i
+  , input [width_p-1:0]       w_data_i
+
+  , input                      r0_v_i
+  , input [addr_width_lp-1:0]  r0_addr_i
+  , output logic [width_p-1:0] r0_data_o
+
+  , input                      r1_v_i
+  , input [addr_width_lp-1:0]  r1_addr_i
+  , output logic [width_p-1:0] r1_data_o
+
+  , input                      r2_v_i
+  , input [addr_width_lp-1:0]  r2_addr_i
+  , output logic [width_p-1:0] r2_data_o
+  );
+
+  wire unused = reset_i;
+
+  // TODO: Define more hardened macro configs here
+  `bsg_mem_3r1w_sync_macro(32,64,1) else
+  //`bsg_mem_3r1w_sync_macro(32,32,2) else
+
+  // no hardened version found
+   begin: notmacro
+     bsg_mem_3r1w_sync_synth #(.width_p(width_p), .els_p(els_p), .read_write_same_addr_p(read_write_same_addr_p))
+      synth
+       (.*);
+   end // block: notmacro
+
+  //synopsys translate_off
+  always_ff @(negedge clk_i)
+    if (w_v_i)
+    begin
+      assert (w_addr_i < els_p)
+        else $error("Invalid address %x to %m of size %x\n", w_addr_i, els_p);
+
+      assert (~(r0_addr_i == w_addr_i && r0_v_i && !read_write_same_addr_p))
+        else $error("%m: port 0 Attempt to read and write same address");
+
+      assert (~(r1_addr_i == w_addr_i && r1_v_i && !read_write_same_addr_p))
+        else $error("%m: port 1 Attempt to read and write same address");
+
+      assert (~(r2_addr_i == w_addr_i && r2_v_i && !read_write_same_addr_p))
+        else $error("%m: port 2 Attempt to read and write same address");
+    end
+
+  initial
+    begin
+      $display("## %L: instantiating width_p=%d, els_p=%d, read_write_same_addr_p=%d, harden_p=%d (%m)",width_p,els_p,read_write_same_addr_p,harden_p);
+    end
+  //synopsys translate_on
+
+endmodule
+
+`BSG_ABSTRACT_MODULE(bsg_mem_3r1w_sync)
diff --git a/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync_macros.vh b/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync_macros.vh
index 1ad2f58c..8ba389ac 100644
--- a/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync_macros.vh
+++ b/hard/gf_14/bsg_mem/bsg_mem_3r1w_sync_macros.vh
@@ -2,10 +2,10 @@
 `ifndef BSG_MEM_3R1W_SYNC_MACROS
 `define BSG_MEM_3R1W_SYNC_MACROS
 
-`define bsg_mem_3r1w_sync_2rf_macro(words,bits,tag)  \
+`define bsg_mem_3r1w_sync_macro(words,bits,mux)      \
   if (harden_p && els_p == words && width_p == bits) \
     begin: macro                                     \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2rf    \
+      gf14_1r1w_d``words``_w``bits``_m``mux          \
         mem0                                         \
           ( .CLKA  ( clk_i     )                     \
           , .CLKB  ( clk_i     )                     \
@@ -21,7 +21,7 @@
           , .STOV  ( 1'b0      )                     \
           , .RET1N ( 1'b1      )                     \
           );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2rf    \
+      gf14_1r1w_d``words``_w``bits``_m``mux          \
         mem1                                         \
           ( .CLKA  ( clk_i     )                     \
           , .CLKB  ( clk_i     )                     \
@@ -37,60 +37,7 @@
           , .STOV  ( 1'b0      )                     \
           , .RET1N ( 1'b1      )                     \
           );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2rf    \
-        mem2                                         \
-          ( .CLKA  ( clk_i     )                     \
-          , .CLKB  ( clk_i     )                     \
-          , .CENA  ( ~r2_v_i   )                     \
-          , .AA    ( r2_addr_i )                     \
-          , .QA    ( r2_data_o )                     \
-          , .CENB  ( ~w_v_i    )                     \
-          , .AB    ( w_addr_i  )                     \
-          , .DB    ( w_data_i  )                     \
-          , .EMAA  ( 3'b011    )                     \
-          , .EMAB  ( 3'b011    )                     \
-          , .EMASA ( 1'b0      )                     \
-          , .STOV  ( 1'b0      )                     \
-          , .RET1N ( 1'b1      )                     \
-          );                                         \
-    end: macro
-
-`define bsg_mem_3r1w_sync_2sram_macro(words,bits,tag)\
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2sram  \
-        mem0                                         \
-          ( .CLKA  ( clk_i     )                     \
-          , .CLKB  ( clk_i     )                     \
-          , .CENA  ( ~r0_v_i   )                     \
-          , .AA    ( r0_addr_i )                     \
-          , .QA    ( r0_data_o )                     \
-          , .CENB  ( ~w_v_i    )                     \
-          , .AB    ( w_addr_i  )                     \
-          , .DB    ( w_data_i  )                     \
-          , .EMAA  ( 3'b011    )                     \
-          , .EMAB  ( 3'b011    )                     \
-          , .EMASA ( 1'b0      )                     \
-          , .STOV  ( 1'b0      )                     \
-          , .RET1N ( 1'b1      )                     \
-          );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2sram  \
-        mem1                                         \
-          ( .CLKA  ( clk_i     )                     \
-          , .CLKB  ( clk_i     )                     \
-          , .CENA  ( ~r1_v_i   )                     \
-          , .AA    ( r1_addr_i )                     \
-          , .QA    ( r1_data_o )                     \
-          , .CENB  ( ~w_v_i    )                     \
-          , .AB    ( w_addr_i  )                     \
-          , .DB    ( w_data_i  )                     \
-          , .EMAA  ( 3'b011    )                     \
-          , .EMAB  ( 3'b011    )                     \
-          , .EMASA ( 1'b0      )                     \
-          , .STOV  ( 1'b0      )                     \
-          , .RET1N ( 1'b1      )                     \
-          );                                         \
-      gf14_1r1w_d``words``_w``bits``_``tag``_2sram  \
+      gf14_1r1w_d``words``_w``bits``_m``mux          \
         mem2                                         \
           ( .CLKA  ( clk_i     )                     \
           , .CLKB  ( clk_i     )                     \
diff --git a/hard/tsmc_28/bsg_async/bsg_launch_sync_sync.v b/hard/tsmc_28/bsg_async/bsg_launch_sync_sync.v
deleted file mode 100644
index f1abdac7..00000000
--- a/hard/tsmc_28/bsg_async/bsg_launch_sync_sync.v
+++ /dev/null
@@ -1,297 +0,0 @@
-// MBT 7/24/2014
-//
-// This is a launch/synchronization complex.
-// The launch flop prevents combinational glitching.
-// The two sync flops reduce probability of metastability.
-// See MBT's note on async design and CDC.
-//
-// The three flops should be don't touched in synopsys
-// and abutted in physical design to reduce chances of metastability.
-//
-// Use of reset is optional; it can be used to hold a known value during reset
-// if for instance, the value is coming off chip.
-//
-
-// the code is structured this way because synopsys's
-// support for hierarchical placement groups appears
-// not to work for parameterized modules.
-// so we must have a non-parameterized module
-// in order to abut the three registers, which
-// have two different clocks.
-//
-// DWP 02/09/2022
-//   Ported from hard/gf_14/bsg_async/bsg_sync_sync.v
-
-// ASYNC RESET: iclk cannot toggle at deassertion of reset
-`include "bsg_defines.v"
-
-`define bsg_launch_sync_sync_unit(EDGE,bits)                            \
-                                                                        \
-module bsg_launch_sync_sync_``EDGE``_``bits``_unit                      \
-  (input iclk_i                                                         \
-   , input iclk_reset_i                                                 \
-   , input oclk_i                                                       \
-   , input  [bits-1:0] iclk_data_i                                      \
-   , output [bits-1:0] iclk_data_o                                      \
-   , output [bits-1:0] oclk_data_o                                      \
-   );                                                                   \
-                                                                        \
-   genvar i;                                                            \
-                                                                        \
-   logic [bits-1:0] bsg_SYNC_LNCH_r;                                    \
-   assign iclk_data_o = bsg_SYNC_LNCH_r;                                \
-                                                                        \
-   always_ff @(EDGE iclk_i)                                             \
-     begin                                                              \
-        if (iclk_reset_i)                                               \
-          bsg_SYNC_LNCH_r <= {bits{1'b0}};                              \
-        else                                                            \
-          bsg_SYNC_LNCH_r <= iclk_data_i;                               \
-     end                                                                \
-                                                                        \
-   for (i = 0; i < bits; i = i + 1)                                  \
-     begin : bss_unit                                                   \
-       bsg_sync_sync_unit bss1                                          \
-        (.oclk_i(oclk_i)                                                \
-         ,.iclk_data_i(iclk_data_i[i])                                  \
-         ,.oclk_data_o(oclk_data_o[i])                                  \
-         );                                                             \
-     end                                                                \
-endmodule
-
-`define bsg_launch_sync_sync_async_reset_unit(EDGE,bits)                \
-                                                                        \
-module bsg_launch_sync_sync_async_reset_``EDGE``_``bits``_unit          \
-  (input iclk_i                                                         \
-   , input iclk_reset_i                                                 \
-   , input oclk_i                                                       \
-   , input  [bits-1:0] iclk_data_i                                      \
-   , output [bits-1:0] iclk_data_o                                      \
-   , output [bits-1:0] oclk_data_o                                      \
-   );                                                                   \
-                                                                        \
-   genvar i;                                                            \
-                                                                        \
-   logic [bits-1:0] bsg_SYNC_LNCH_r;                                    \
-   assign iclk_data_o = bsg_SYNC_LNCH_r;                                \
-                                                                        \
-   always_ff @(EDGE iclk_i or posedge iclk_reset_i)                     \
-     begin : BSG_NO_CLOCK_GATE_1                                        \
-        if (iclk_reset_i)                                               \
-          bsg_SYNC_LNCH_r <= {bits{1'b0}};                              \
-        else                                                            \
-          bsg_SYNC_LNCH_r <= iclk_data_i;                               \
-     end                                                                \
-                                                                        \
-   logic [bits-1:0] bsg_SYNC_1_r;                                       \
-   logic [bits-1:0] bsg_SYNC_2_r;                                       \
-                                                                        \
-   assign oclk_data_o = bsg_SYNC_2_r;                                   \
-                                                                        \
-   for (i = 0; i < bits; i++)                                           \
-     begin : BSG_NO_CLOCK_GATE_2                                        \
-       bsg_sync_sync_async_reset_unit bss1                              \
-        (.oclk_i(oclk_i)                                                \
-         ,.iclk_reset_i(iclk_reset_i)                                   \
-         ,.iclk_data_i(iclk_data_i)                                     \
-         ,.oclk_data_o(oclk_data_o)                                     \
-         );                                                             \
-     end                                                                \
-endmodule
-
-// bsg_launch_sync_sync_posedge_1_unit
-`bsg_launch_sync_sync_unit(posedge,1)
-`bsg_launch_sync_sync_unit(posedge,2)
-`bsg_launch_sync_sync_unit(posedge,3)
-`bsg_launch_sync_sync_unit(posedge,4)
-`bsg_launch_sync_sync_unit(posedge,5)
-`bsg_launch_sync_sync_unit(posedge,6)
-`bsg_launch_sync_sync_unit(posedge,7)
-`bsg_launch_sync_sync_unit(posedge,8)
-
-// bsg_launch_sync_sync_negedge_1_unit
-`bsg_launch_sync_sync_unit(negedge,1)
-`bsg_launch_sync_sync_unit(negedge,2)
-`bsg_launch_sync_sync_unit(negedge,3)
-`bsg_launch_sync_sync_unit(negedge,4)
-`bsg_launch_sync_sync_unit(negedge,5)
-`bsg_launch_sync_sync_unit(negedge,6)
-`bsg_launch_sync_sync_unit(negedge,7)
-`bsg_launch_sync_sync_unit(negedge,8)
-
-// bsg_launch_sync_sync_async_reset_posedge_1_unit
-`bsg_launch_sync_sync_async_reset_unit(posedge,1)
-`bsg_launch_sync_sync_async_reset_unit(posedge,2)
-`bsg_launch_sync_sync_async_reset_unit(posedge,3)
-`bsg_launch_sync_sync_async_reset_unit(posedge,4)
-`bsg_launch_sync_sync_async_reset_unit(posedge,5)
-`bsg_launch_sync_sync_async_reset_unit(posedge,6)
-`bsg_launch_sync_sync_async_reset_unit(posedge,7)
-`bsg_launch_sync_sync_async_reset_unit(posedge,8)
-
-// bsg_launch_sync_sync_async_reset_negedge_1_unit
-`bsg_launch_sync_sync_async_reset_unit(negedge,1)
-`bsg_launch_sync_sync_async_reset_unit(negedge,2)
-`bsg_launch_sync_sync_async_reset_unit(negedge,3)
-`bsg_launch_sync_sync_async_reset_unit(negedge,4)
-`bsg_launch_sync_sync_async_reset_unit(negedge,5)
-`bsg_launch_sync_sync_async_reset_unit(negedge,6)
-`bsg_launch_sync_sync_async_reset_unit(negedge,7)
-`bsg_launch_sync_sync_async_reset_unit(negedge,8)
-
-// warning: if you make this != 8, you need
-// to modify other parts of this code
-
-`define blss_max_block 8
-
-// handle trailer bits
-`define blss_if_clause(EDGE,num) if ((width_p % `blss_max_block) == num) begin: z            \
-                                     bsg_launch_sync_sync_``EDGE``_``num``_unit blss \
-                                        (.iclk_i                                     \
-                                         ,.iclk_reset_i                              \
-                                         ,.oclk_i                                    \
-                                         ,.iclk_data_i(iclk_data_i[width_p-1-:num])  \
-                                         ,.iclk_data_o(iclk_data_o[width_p-1-:num])  \
-                                         ,.oclk_data_o(oclk_data_o[width_p-1-:num])  \
-                                         ); end
-										 
-`define blssar_if_clause(EDGE,num) if ((width_p % `blss_max_block) == num) begin: z          \
-                         bsg_launch_sync_sync_async_reset_``EDGE``_``num``_unit blss \
-                                        (.iclk_i                                     \
-                                         ,.iclk_reset_i                              \
-                                         ,.oclk_i                                    \
-                                         ,.iclk_data_i(iclk_data_i[width_p-1-:num])  \
-                                         ,.iclk_data_o(iclk_data_o[width_p-1-:num])  \
-                                         ,.oclk_data_o(oclk_data_o[width_p-1-:num])  \
-                                         ); end
-
-module bsg_launch_sync_sync #(parameter `BSG_INV_PARAM(width_p)
-                              , parameter use_negedge_for_launch_p = 0
-                              , parameter use_async_reset_p = 0)
-   (input iclk_i
-    , input iclk_reset_i
-    , input oclk_i
-    , input  [width_p-1:0] iclk_data_i
-    , output [width_p-1:0] iclk_data_o // after launch flop
-    , output [width_p-1:0] oclk_data_o // after sync flops
-    );
-
-// synopsys translate_off
-
-/*   initial
-     begin
-        $display("%m: instantiating blss of size %d",width_p);
-     end
- */
-   initial assert (iclk_reset_i !== 'z)
-     else
-       begin
-          $error("%m iclk_reset should be connected");
-          $finish();
-       end
-
-// synopsys translate_on
-
-   genvar i;
-
-   if (use_async_reset_p == 0) begin: sync
-
-   if (use_negedge_for_launch_p)
-     begin: n
-        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)
-          begin : maxb
-             bsg_launch_sync_sync_negedge_8_unit blss
-                 (.iclk_i
-                  ,.iclk_reset_i
-                  ,.oclk_i
-                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])
-                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  );
-          end
-
-        `blss_if_clause(negedge,1) else
-          `blss_if_clause(negedge,2) else
-            `blss_if_clause(negedge,3) else
-              `blss_if_clause(negedge,4) else
-                `blss_if_clause(negedge,5) else
-                  `blss_if_clause(negedge,6) else
-                    `blss_if_clause(negedge,7)
-     end
-   else
-     begin: p
-        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)
-          begin : maxb
-             bsg_launch_sync_sync_posedge_8_unit blss
-                 (.iclk_i
-                  ,.iclk_reset_i
-                  ,.oclk_i
-                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])
-                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  );
-          end
-
-        `blss_if_clause(posedge,1) else
-          `blss_if_clause(posedge,2) else
-            `blss_if_clause(posedge,3) else
-              `blss_if_clause(posedge,4) else
-                `blss_if_clause(posedge,5) else
-                  `blss_if_clause(posedge,6) else
-                    `blss_if_clause(posedge,7)
-     end
-
-   end 
-   else begin: async
-
-   if (use_negedge_for_launch_p)
-     begin: n
-        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)
-          begin : maxb
-             bsg_launch_sync_sync_async_reset_negedge_8_unit blss
-                 (.iclk_i
-                  ,.iclk_reset_i
-                  ,.oclk_i
-                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])
-                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  );
-          end
-
-        `blssar_if_clause(negedge,1) else
-          `blssar_if_clause(negedge,2) else
-            `blssar_if_clause(negedge,3) else
-              `blssar_if_clause(negedge,4) else
-                `blssar_if_clause(negedge,5) else
-                  `blssar_if_clause(negedge,6) else
-                    `blssar_if_clause(negedge,7)
-     end
-   else
-     begin: p
-        for (i = 0; i < (width_p/`blss_max_block); i = i + 1)
-          begin : maxb
-             bsg_launch_sync_sync_async_reset_posedge_8_unit blss
-                 (.iclk_i
-                  ,.iclk_reset_i
-                  ,.oclk_i
-                  ,.iclk_data_i(iclk_data_i[i*`blss_max_block+:`blss_max_block])
-                  ,.iclk_data_o(iclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  ,.oclk_data_o(oclk_data_o[i*`blss_max_block+:`blss_max_block])
-                  );
-          end
-
-        `blssar_if_clause(posedge,1) else
-          `blssar_if_clause(posedge,2) else
-            `blssar_if_clause(posedge,3) else
-              `blssar_if_clause(posedge,4) else
-                `blssar_if_clause(posedge,5) else
-                  `blssar_if_clause(posedge,6) else
-                    `blssar_if_clause(posedge,7)
-     end
-
-   end
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_launch_sync_sync)
-
diff --git a/hard/tsmc_28/bsg_async/bsg_sync_sync.v b/hard/tsmc_28/bsg_async/bsg_sync_sync.v
deleted file mode 100644
index 5567a900..00000000
--- a/hard/tsmc_28/bsg_async/bsg_sync_sync.v
+++ /dev/null
@@ -1,97 +0,0 @@
-
-// MBT 7/24/2014
-//
-// bsg_sync_sync
-//
-// This is just two synchronization flops.
-//
-// We use the rp placement flop from synopsys.
-// Fixme: move this into asic-specific components.
-//
-// DWP 02/09/2022
-//   Ported from hard/gf_14/bsg_async/bsg_sync_sync.v
-//
-
-`define bsg_sync_sync_unit(width_p)                             \
-                                                                \
-module bsg_sync_sync_``width_p``_unit                           \
-  (                                                             \
-   input oclk_i                                                 \
-   , input  [width_p-1:0] iclk_data_i                           \
-   , output [width_p-1:0] oclk_data_o // after sync flops       \
-   );                                                           \
-                                                                \
-  genvar i;                                                     \
-                                                                \
-   for (i = 0; i < width_p; i = i + 1)                          \
-     begin : bss_unit                                           \
-       bsg_sync_sync_unit bss1                                  \
-        (.oclk_i(oclk_i)                                        \
-         ,.iclk_data_i(iclk_data_i[i])                          \
-         ,.oclk_data_o(oclk_data_o[i])                          \
-         );                                                     \
-     end                                                        \
-                                                                \
-endmodule
-
-
-`bsg_sync_sync_unit(1)
-`bsg_sync_sync_unit(2)
-`bsg_sync_sync_unit(3)
-`bsg_sync_sync_unit(4)
-`bsg_sync_sync_unit(5)
-`bsg_sync_sync_unit(6)
-`bsg_sync_sync_unit(7)
-`bsg_sync_sync_unit(8)
-
-// warning: if you make this != 8, you need to modify other
-// parts of this code.
-
-`define bss_max_block 8
-
-`define bss_if_clause(num) if ((width_p % `bss_max_block) == num) begin: z\
-                            bsg_sync_sync_``num``_unit bss                \
-                              (.oclk_i                                    \
-                               ,.iclk_data_i(iclk_data_i[width_p-1-:num]) \
-                               ,.oclk_data_o(oclk_data_o[width_p-1-:num]) \
-                               ); end
-
-
-module bsg_sync_sync #(parameter `BSG_INV_PARAM(width_p ))
-   (
-      input oclk_i
-    , input  [width_p-1:0] iclk_data_i
-    , output [width_p-1:0] oclk_data_o // after sync flops
-    );
-
-   genvar   i;
-
-   // synopsys translate_off
- /*
-   initial
-     begin
-        $display("%m: instantiating bss of size %d",width_p);
-     end
-  */
-   // synopsys translate_on
-
-   for (i = 0; i < (width_p/`bss_max_block); i = i + 1)
-     begin : maxb
-        bsg_sync_sync_8_unit bss8
-            (.oclk_i
-             ,.iclk_data_i(iclk_data_i[i*`bss_max_block+:`bss_max_block])
-             ,.oclk_data_o(oclk_data_o[i*`bss_max_block+:`bss_max_block])
-             );
-     end
-
-   `bss_if_clause(1) else
-     `bss_if_clause(2) else
-       `bss_if_clause(3) else
-         `bss_if_clause(4) else
-           `bss_if_clause(5) else
-             `bss_if_clause(6) else
-               `bss_if_clause(7)
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_sync_sync)
diff --git a/hard/tsmc_28/bsg_async/bsg_sync_sync_async_reset_unit.v b/hard/tsmc_28/bsg_async/bsg_sync_sync_async_reset_unit.v
deleted file mode 100644
index 85e93d53..00000000
--- a/hard/tsmc_28/bsg_async/bsg_sync_sync_async_reset_unit.v
+++ /dev/null
@@ -1,28 +0,0 @@
-
-module bsg_sync_sync_async_reset_unit
- (input oclk_i
-  , input iclk_reset_i
-  , input iclk_data_i
-  , output oclk_data_o // after sync flops
-  );
-
-  logic bsg_SYNC_1_r, bsg_SYNC_2_r;
-
-  DFCNQD4BWP7T30P140ULVT hard_sync_int1
-   (.CP(oclk_i)
-   ,.CDN(~iclk_reset_i)
-   ,.D(iclk_data_i)
-   ,.Q(bsg_SYNC_1_r)
-   );
-
-  DFCNQD4BWP7T30P140ULVT hard_sync_int2
-   (.CP(oclk_i)
-   ,.CDN(~iclk_reset_i)
-   ,.D(bsg_SYNC_1_r)
-   ,.Q(bsg_SYNC_2_r)
-   );
-
-  assign oclk_data_o = bsg_SYNC_2_r;
-
-endmodule
-
diff --git a/hard/tsmc_28/bsg_async/bsg_sync_sync_unit.v b/hard/tsmc_28/bsg_async/bsg_sync_sync_unit.v
deleted file mode 100644
index 1274f789..00000000
--- a/hard/tsmc_28/bsg_async/bsg_sync_sync_unit.v
+++ /dev/null
@@ -1,25 +0,0 @@
-
-module bsg_sync_sync_unit
- (input oclk_i
-  , input iclk_data_i
-  , output oclk_data_o // after sync flops
-  );
-
-  logic bsg_SYNC_1_r, bsg_SYNC_2_r;
-
-  DFQD4BWP7T30P140ULVT hard_sync_int1_BSG_SYNC
-   (.CP(oclk_i)
-   ,.D(iclk_data_i)
-   ,.Q(bsg_SYNC_1_r)
-   );
-
-  DFQD4BWP7T30P140ULVT hard_sync_int2_BSG_SYNC
-   (.CP(oclk_i)
-   ,.D(bsg_SYNC_1_r)
-   ,.Q(bsg_SYNC_2_r)
-   );
-
-  assign oclk_data_o = bsg_SYNC_2_r;
-
-endmodule
-
diff --git a/hard/tsmc_28/bsg_clk_gen/README.verification b/hard/tsmc_28/bsg_clk_gen/README.verification
deleted file mode 100755
index d8588364..00000000
--- a/hard/tsmc_28/bsg_clk_gen/README.verification
+++ /dev/null
@@ -1,24 +0,0 @@
-This clock generator is intended to be able to change the frequency as the chip operates without glitches or short pulses.
-
-* Verification using SDF and gate-level simulation
-
-After the system has gone through place-and-route, it's important to check the timing corners in the circuit. The default tester tests the worst-case transition, which
-occurs when transitioning from the fastest frequency to the closest frequency.
-
-In gate-level simulation, this can be view by looking at clk_gen_osc_inst/adt/sel_r_reg_0, and finding the part in the test where the clock goes from fastest to slowest.
-Measure the distance between the D input and the CK signal. Typically D will fall shortly before CK rises, indicating a setup time condition that needs to be verified.
-This time can be compared against the negedge setup time for the same gate in the .SDF file.
-
-The other potential race is in the mux4i of the adt. The select lines should transition in a way that the output does not glitch. Currently the select lines transition
-from 3 (D)->2 (C)->0(A) after the D is already zero, C is hardwired to 0, and then A has just transitioned to 0.
-
-In practice, if the chip exhibits this race in the real world, it can be avoid by transitioning to an intermediate frequency before going to the slowest frequency.
-
-* Verification using Spice
-
-True transistor-level extraction-based spice is the best way to verify the circuit, although it takes a long time.  The simulation-based model in the spice directory
-can be used to eyeball frequency ranges.
-
-
-
-
diff --git a/hard/tsmc_28/bsg_clk_gen/bsg_clk_gen_osc.v b/hard/tsmc_28/bsg_clk_gen/bsg_clk_gen_osc.v
deleted file mode 100755
index 7dfe18d9..00000000
--- a/hard/tsmc_28/bsg_clk_gen/bsg_clk_gen_osc.v
+++ /dev/null
@@ -1,182 +0,0 @@
-// bsg_clk_gen_osc
-//
-// new settings are delivered via bsg_tag_i
-//
-// the clock is designed to be atomically updated
-// between any of its values without glitching.
-//
-// the order of components is:
-//
-// ADT, CDT, FDT  --> feedback (and buffer to outside world)
-//
-// All three stages invert their outputs.
-//
-// All of the modules have delay circuits that clock their config
-// flops right after the signal has passed through. All of them are
-// configured to grab the new value after a negedge enters the beginning of
-// of the ADT, but of course since the signal is inverted at each stage
-// ADT and FDT do it on posege and CDT does it on negedge.
-//
-// We employ a MUXI4 that is part of the standard cell library
-// that we verify to be glitch-free using spice simulation (presumably because it is based on a
-// t-gate design). If the MUXI4 were made out of AND-OR circuits, care
-// would have to be taken to make sure that the transitions occur when
-// either all inputs are 0 or 1 to the MUXI4, depending on the implementation.
-// For example, if the mux is AOI, triggered on negedge edge of input clock would
-// be okay. Fortunately, we don't have to worry about this (and confirmed by spice.)
-//
-// We have verified this in TSMC 40 by running with sdf annotations.
-//
-
-// Gen 2 specific info (starting with 40nm)  MBT 5-26-2018
-//
-// This Gen 2 clock generator has been slight redesigned in order to address the races
-// in the gen 1 design that prevented automation.
-//
-// We use the bsg_tag_client_unsync implementation in order to reduce the load on
-// the internally generated clock. Additionally, we separate out the we_r trigger
-// signal so that it is explicitly set. This means that to set the frequency
-// on average, three packets will need to be sent. First, a packet will be sent
-// to set clock configuration bits. Then a packet will be sent to enable the we_r
-// signal. Finally a packet will be sent to clear the we_r signal.
-// This applies only for the oscillator programming.
-//
-// The trigger is synchronized inside the ADT; and then the synchronized signal
-// is buffered and passed on to the CDT and then to the FDT, mirroring the
-// flow of the clock signal through the units.
-//
-// The goal of this approach is to ensure that a new value is latched into the
-// oscillator's configuration registers atomically, and during the first negative
-// clock phase after a positive edge.
-//
-//
-// The downsampler uses the normal interface.
-//
-//
-// Gen 1 specific info (for reference)
-//
-// There is an implicit race between the bsg_tag's output fb_we_r (clocked on
-// positive edge of FDT output) and these config flops that cannot be addressed
-// in ICC because we cannot explicitly control timing between ICC-managed
-// clocks and our internal oscillator clocks.
-//
-// A final check must be made on the 5 flops inside the adt / cdt / fdt
-// to see that async reset drops and data inputs do not come too close
-// to the appropriate clock edge.  This could be verified via a script that
-// processes the SDF file, but for now we pull the test trace up in DVE and
-// manually check these points.  Typically, the ADT is the closest
-// call, where in MAX timing mode, the data changes about 481 ps before the
-// positive edge of the flop's clock. With a setup time on the order of
-// 261 ps, there is a slack of 220 ps. This path was originally a problem
-// and it fixed by sending the clock out to the BTC at the beginning of
-// the FDT as opposed to at the end. This gives more time for propagate
-// through the ICC-generate clock tree for the BTC.
-//
-//
-//
-//
-
-`timescale 1ps/1ps
-
-`include "bsg_defines.v"
-`include "bsg_clk_gen.vh"
-
-module bsg_clk_gen_osc
-   import bsg_tag_pkg::bsg_tag_s;
- #(parameter num_adgs_p=1)
-  (
-   input bsg_tag_s bsg_tag_i
-   ,input bsg_tag_s bsg_tag_trigger_i
-
-   ,input async_reset_i
-   ,output clk_o
-   );
-
-   wire  fb_clk;
-   wire       async_reset_neg = ~async_reset_i;
-
-   `declare_bsg_clk_gen_osc_tag_payload_s(num_adgs_p)
-
-   bsg_clk_gen_osc_tag_payload_s tag_r_async;
-   wire       tag_trigger_r_async;
-   wire       adt_to_cdt_trigger_lo, cdt_to_fdt_trigger_lo;
-   wire [num_adgs_p:0] adt_to_adt_trigger_lo;
-
-   // this is a raw interface; and wires will toggle
-   // as the bits shift in. the wires are also
-   // unsynchronized with respect to the target domain.
-
-   bsg_tag_client_unsync
-     #(.width_p($bits(bsg_clk_gen_osc_tag_payload_s))
-       ,.harden_p(1)
-       ) btc
-       (.bsg_tag_i(bsg_tag_i)
-        ,.data_async_r_o(tag_r_async)
-        );
-
-   bsg_tag_client_unsync
-     #(.width_p(1)
-       ,.harden_p(1)
-       ) btc_trigger
-       (.bsg_tag_i(bsg_tag_trigger_i)
-        ,.data_async_r_o(tag_trigger_r_async)
-        );
-
-   wire [num_adgs_p:0] adt_lo;
-   wire cdt_lo;
-
-   wire fb_clk_del;
-
-   // this adds some delay in the loop for RTL simulation
-   // should be ignored in synthesis
-   assign #4000 fb_clk_del = fb_clk;
-
-   assign adt_lo[num_adgs_p] = (num_adgs_p[0]) ? fb_clk_del : ~fb_clk_del;
-   assign adt_to_adt_trigger_lo[num_adgs_p] = tag_trigger_r_async;
-   for (genvar i = num_adgs_p-1; i >= 0; i--)
-     begin : a
-       bsg_rp_clk_gen_atomic_delay_tuner adt_BSG_DONT_TOUCH
-         (.i                 (~adt_lo[i+1]                )
-          ,.we_async_i       (adt_to_adt_trigger_lo[i+1]  )
-          ,.we_inited_i      (bsg_tag_trigger_i.en        )
-          ,.async_reset_neg_i(async_reset_neg             )
-          ,.sel_i            (tag_r_async.adg[i]          )
-          ,.we_o             (adt_to_adt_trigger_lo[i]    )
-          ,.o                (adt_lo[i]                   )
-          );
-     end
-   assign adt_to_cdt_trigger_lo = adt_to_adt_trigger_lo[0];
-
-   // instantatiate CDT (coarse delay tuner)
-   // this one inverts the output
-   // captures config state on negative edge of input clock
-
-   bsg_rp_clk_gen_coarse_delay_tuner cdt_BSG_DONT_TOUCH
-     (.i                 (adt_lo[0])
-      ,.we_i             (adt_to_cdt_trigger_lo)
-      ,.async_reset_neg_i(async_reset_neg      )
-      ,.sel_i            (tag_r_async.cdt      )
-      ,.we_o             (cdt_to_fdt_trigger_lo)
-      ,.o                (cdt_lo)
-      );
-
-   // instantiate FDT (fine delay tuner)
-   // captures config state on positive edge of (inverted) input clk
-   // non-inverting
-
-   bsg_rp_clk_gen_fine_delay_tuner fdt_BSG_DONT_TOUCH
-     (.i                 (cdt_lo)
-      ,.we_i             (cdt_to_fdt_trigger_lo)
-      ,.async_reset_neg_i(async_reset_neg)
-      ,.sel_i            (tag_r_async.fdt)
-      ,.o                (fb_clk)     // in the actual critical loop
-      ,.buf_o            (clk_o)     // outside this module
-      );
-
-   //always @(*)
-   //  $display("%m async_reset_neg=%b fb_clk=%b adg_int=%b fb_tag_r=%b fb_we_r=%b",
-   //           async_reset_neg,fb_clk,adg_int,fb_tag_r,fb_we_r);
-
-endmodule // bsg_clk_gen_osc
-
-
diff --git a/hard/tsmc_28/bsg_clk_gen/bsg_dly_line.v b/hard/tsmc_28/bsg_clk_gen/bsg_dly_line.v
deleted file mode 100644
index 0a297b9e..00000000
--- a/hard/tsmc_28/bsg_clk_gen/bsg_dly_line.v
+++ /dev/null
@@ -1,180 +0,0 @@
-// bsg_delay_line
-//
-// new settings are delivered via bsg_tag_i
-//
-// the clock is designed to be atomically updated
-// between any of its values without glitching.
-//
-// the order of components is:
-//
-// ADT, CDT, FDT  --> feedback (and buffer to outside world)
-//
-// All three stages invert their outputs.
-//
-// All of the modules have delay circuits that clock their config
-// flops right after the signal has passed through. All of them are
-// configured to grab the new value after a negedge enters the beginning of
-// of the ADT, but of course since the signal is inverted at each stage
-// ADT and FDT do it on posege and CDT does it on negedge.
-//
-// We employ a MUXI4 that is part of the standard cell library
-// that we verify to be glitch-free using spice simulation (presumably because it is based on a
-// t-gate design). If the MUXI4 were made out of AND-OR circuits, care
-// would have to be taken to make sure that the transitions occur when
-// either all inputs are 0 or 1 to the MUXI4, depending on the implementation.
-// For example, if the mux is AOI, triggered on negedge edge of input clock would
-// be okay. Fortunately, we don't have to worry about this (and confirmed by spice.)
-//
-// We have verified this in TSMC 40 by running with sdf annotations.
-//
-
-// Gen 2 specific info (starting with 40nm)  MBT 5-26-2018
-//
-// This Gen 2 clock generator has been slight redesigned in order to address the races
-// in the gen 1 design that prevented automation.
-//
-// We use the bsg_tag_client_unsync implementation in order to reduce the load on
-// the internally generated clock. Additionally, we separate out the we_r trigger
-// signal so that it is explicitly set. This means that to set the frequency
-// on average, three packets will need to be sent. First, a packet will be sent
-// to set clock configuration bits. Then a packet will be sent to enable the we_r
-// signal. Finally a packet will be sent to clear the we_r signal.
-// This applies only for the oscillator programming.
-//
-// The trigger is synchronized inside the ADT; and then the synchronized signal
-// is buffered and passed on to the CDT and then to the FDT, mirroring the
-// flow of the clock signal through the units.
-//
-// The goal of this approach is to ensure that a new value is latched into the
-// oscillator's configuration registers atomically, and during the first negative
-// clock phase after a positive edge.
-//
-//
-// The downsampler uses the normal interface.
-//
-//
-// Gen 1 specific info (for reference)
-//
-// There is an implicit race between the bsg_tag's output fb_we_r (clocked on
-// positive edge of FDT output) and these config flops that cannot be addressed
-// in ICC because we cannot explicitly control timing between ICC-managed
-// clocks and our internal oscillator clocks.
-//
-// A final check must be made on the 5 flops inside the adt / cdt / fdt
-// to see that async reset drops and data inputs do not come too close
-// to the appropriate clock edge.  This could be verified via a script that
-// processes the SDF file, but for now we pull the test trace up in DVE and
-// manually check these points.  Typically, the ADT is the closest
-// call, where in MAX timing mode, the data changes about 481 ps before the
-// positive edge of the flop's clock. With a setup time on the order of
-// 261 ps, there is a slack of 220 ps. This path was originally a problem
-// and it fixed by sending the clock out to the BTC at the beginning of
-// the FDT as opposed to at the end. This gives more time for propagate
-// through the ICC-generate clock tree for the BTC.
-//
-//
-//
-//
-
-`timescale 1ps/1ps
-
-`include "bsg_clk_gen.vh"
-
-module bsg_dly_line
-   import bsg_tag_pkg::bsg_tag_s;
- #(parameter num_adgs_p=1)
-  (
-   input bsg_tag_s bsg_tag_i
-   ,input bsg_tag_s bsg_tag_trigger_i
-
-   ,input async_reset_i
-   ,input clk_i
-   ,output clk_o
-   );
-
-   wire  fb_clk;
-   wire       async_reset_neg = ~async_reset_i;
-
-   `declare_bsg_clk_gen_osc_tag_payload_s(num_adgs_p)
-
-   bsg_clk_gen_osc_tag_payload_s tag_r_async;
-   wire       tag_trigger_r_async;
-   wire       adt_to_cdt_trigger_lo, cdt_to_fdt_trigger_lo;
-   wire [num_adgs_p:0] adt_to_adt_trigger_lo;
-
-   // this is a raw interface; and wires will toggle
-   // as the bits shift in. the wires are also
-   // unsynchronized with respect to the target domain.
-
-   bsg_tag_client_unsync
-     #(.width_p($bits(bsg_clk_gen_osc_tag_payload_s))
-       ,.harden_p(1)
-       ) btc
-       (.bsg_tag_i(bsg_tag_i)
-        ,.data_async_r_o(tag_r_async)
-        );
-
-   bsg_tag_client_unsync
-     #(.width_p(1)
-       ,.harden_p(1)
-       ) btc_trigger
-       (.bsg_tag_i(bsg_tag_trigger_i)
-        ,.data_async_r_o(tag_trigger_r_async)
-        );
-
-   wire [num_adgs_p:0] adt_lo;
-   wire cdt_lo;
-
-  wire clk_inv;
-  assign clk_inv = ~clk_i;
-  assign adt_lo[num_adgs_p] = (num_adgs_p[0]) ? clk_inv : clk_i;
-  assign adt_to_adt_trigger_lo[num_adgs_p] = tag_trigger_r_async;
-  for (genvar i = num_adgs_p-1; i >= 0; i--)
-    begin : a
-      bsg_rp_clk_gen_atomic_delay_tuner  adt_BSG_DONT_TOUCH
-        (.i                 (adt_lo[i+1]               )
-         ,.we_async_i       (adt_to_adt_trigger_lo[i+1])
-         ,.we_inited_i      (bsg_tag_trigger_i.en      )
-         ,.async_reset_neg_i(async_reset_neg           )
-         ,.sel_i            (tag_r_async.adg[i]        )
-         ,.we_o             (adt_to_adt_trigger_lo[i]  )
-         ,.o                (adt_lo[i]                 )
-         );
-    end
-   assign adt_to_cdt_trigger_lo = adt_to_adt_trigger_lo[0];
-
-   // instantatiate CDT (coarse delay tuner)
-   // this one inverts the output
-   // captures config state on negative edge of input clock
-
-   bsg_rp_clk_gen_coarse_delay_tuner cdt_BSG_DONT_TOUCH
-     (.i                 (adt_lo[0])
-      ,.we_i             (adt_to_cdt_trigger_lo)
-      ,.async_reset_neg_i(async_reset_neg      )
-      ,.sel_i            (tag_r_async.cdt      )
-      ,.we_o             (cdt_to_fdt_trigger_lo)
-      ,.o                (cdt_lo)
-      );
-
-   // instantiate FDT (fine delay tuner)
-   // captures config state on positive edge of (inverted) input clk
-   // non-inverting
-
-   bsg_rp_clk_gen_fine_delay_tuner fdt_BSG_DONT_TOUCH
-     (.i                 (cdt_lo)
-      ,.we_i             (cdt_to_fdt_trigger_lo)
-      ,.async_reset_neg_i(async_reset_neg)
-      ,.sel_i            (tag_r_async.fdt)
-      ,.o                (fb_clk)     // in the actual critical loop
-      ,.buf_o            (clk_o)     // outside this module
-      );
-
-   //always @(*)
-   //  $display("%m async_reset_neg=%b fb_clk=%b adg_int=%b fb_tag_r=%b fb_we_r=%b",
-   //           async_reset_neg,fb_clk,adg_int,fb_tag_r,fb_we_r);
-
-endmodule // bsg_dly_line
-
-`BSG_ABSTRACT_MODULE(bsg_dly_line)
-
-
diff --git a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_atomic_delay_tuner.v b/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_atomic_delay_tuner.v
deleted file mode 100755
index 3ccb59b9..00000000
--- a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_atomic_delay_tuner.v
+++ /dev/null
@@ -1,95 +0,0 @@
-// bsg_rp_clk_gen_coarse_delay_element
-//
-// o       contains controllably delayed signal
-//
-// module bsg_clk_gen_coarse_delay_element #(parameter `BSG_INV_PARAM(start_tap_p))
-//
-// DWP 10/6/2021: Ported from TSMC40 to TSMC28 by reusing cells and appending 7T30P140ULVT for the specific cell lib
-
-module bsg_rp_clk_gen_atomic_delay_tuner
-  (input i
-
-   , input  sel_i
-   , input  we_async_i
-   , input  we_inited_i  // basically says we_async_i should have successfully passed through
-                         // the generated clock's synchronizers; i.e. the generated clock is
-                         // running and the bsg_tag_slave and client have been initialized
-   , input async_reset_neg_i
-   , output we_o
-   , output o
-   );
-
-   wire [1:0] sel_r;
-   wire [8:0] signal;
-   wire       we_o_pre_buf;
-
-   assign signal[0] = i;
-
-   // synopsys rp_group (bsg_clk_gen_adt)
-   // synopsys rp_fill (13 2 LX)
-
-   CKND2BWP7T30P140ULVT I1  (.I(signal[0]), .ZN(signal[1]) );
-   CKND2BWP7T30P140ULVT I2  (.I(signal[1]), .ZN(signal[2]) );
-   CKND2BWP7T30P140ULVT I2a (.I(signal[1]), .ZN()          );
-
-   CKND2BWP7T30P140ULVT I3  (.I(signal[2]), .ZN(signal[3]) );
-   CKND2BWP7T30P140ULVT I4  (.I(signal[3]), .ZN(signal[4]) );
-   CKND4BWP7T30P140ULVT I4a (.I(signal[3]), .ZN()          );
-   CKND2BWP7T30P140ULVT I4b (.I(signal[3]), .ZN()          );
-                                                        // we are not attaching to the mux
-                                                        // cap tries to match that of mux input
-   CKND2BWP7T30P140ULVT I5  (.I(signal[4]), .ZN(signal[5]) );
-   CKND4BWP7T30P140ULVT I6  (.I(signal[5]), .ZN(signal[6]) );
-   CKND4BWP7T30P140ULVT I6a (.I(signal[5]), .ZN()          );
-
-   CKND2BWP7T30P140ULVT I7  (.I(signal[6]), .ZN(signal[7]) );
-   CKND2BWP7T30P140ULVT I8  (.I(signal[7]), .ZN(signal[8]) );
-   CKND4BWP7T30P140ULVT I8a (.I(signal[7]), .ZN()          );
-   CKND3BWP7T30P140ULVT I8b (.I(signal[7]), .ZN()          );
-
-   // synopsys rp_fill (0 1 RX)
-
-   wire       zero_bit;
-
-   MUX4ND4BWP7T30P140ULVT M1 ( .I0(signal[8])
-                        ,.I1(signal[6])
-                        ,.I2(zero_bit)
-                        ,.I3(signal[0])
-
-                        ,.S0(sel_r[0])
-                        ,.S1(sel_r[1])
-                        ,.ZN(o   )
-                         );
-
-   wire [1:0] mux_lo;
-   wire       we_i_sync, we_i_sync_sync, we_i_sync_sync_nand;
-
-   // synopsys rp_fill (0 0 RX)
-
-   // this gate picks input 01 when async reset is low, initializing the oscillator
-   IND2D2BWP7T30P140ULVT NB (.A1(sel_r[0]), .B1(async_reset_neg_i), .ZN(sel_r[1]));
-   TIELBWP7T30P140ULVT   ZB (.ZN(zero_bit));
-
-   DFCND4BWP7T30P140ULVT sel_r_reg_0 (.D(mux_lo[0]), .CP(o)      ,.CDN(async_reset_neg_i), .Q(sel_r[0]), .QN());
-   //LHCND4BWP7T30P140ULVT sel_r_latch_0 (.D(mux_lo[0]), .E(o)      ,.CDN(async_reset_neg_i), .Q(sel_r[0]), .QN());
-
-   // inputs are reversed because select is inverted
-   // we_i&we_inited_i=1 -> new value  (I0)
-   // we_i&we_inited-i=0 -> use value in register (I1)
-   MUX2D1BWP7T30P140ULVT MX1          ( .I0(sel_i), .I1(sel_r[0]), .S(we_i_sync_sync_nand), .Z(mux_lo[0]));
-
-   // nand 10ps versus 22ps
-   ND2D1BWP7T30P140ULVT bsg_we_nand   (.A1(we_i_sync_sync), .A2(we_inited_i), .ZN(we_i_sync_sync_nand));
-   // synchronizer flops; negative edge triggered
-   //DFND1BWP7T30P140ULVT bsg_SYNC_2_r  (.D(we_i_sync), .CPN(o), .Q(we_i_sync_sync), .QN());
-   //DFND1BWP7T30P140ULVT bsg_SYNC_1_r  (.D(we_async_i),     .CPN(o), .Q(we_i_sync),      .QN());
-   DFNCND1BWP7T30P140ULVT bsg_SYNC_2_r  (.D(we_i_sync),  .CPN(o), .CDN(async_reset_neg_i), .Q(we_i_sync_sync), .QN());
-   DFNCND1BWP7T30P140ULVT bsg_SYNC_1_r  (.D(we_async_i), .CPN(o), .CDN(async_reset_neg_i), .Q(we_i_sync),      .QN());
-   // drive we signal to next CDT; minimize capacitive load on critical we_i path
-   INVD0BWP7T30P140ULVT we_o_pre      (.I(we_i_sync_sync_nand), .ZN(we_o_pre_buf));
-   BUFFD4BWP7T30P140ULVT we_o_buf     (.I(we_o_pre_buf),. Z(we_o));
-
-   // synopsys rp_endgroup (bsg_clk_gen_adt)
-
-endmodule
-
diff --git a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_coarse_delay_tuner.v b/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_coarse_delay_tuner.v
deleted file mode 100755
index 06d58a8b..00000000
--- a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_coarse_delay_tuner.v
+++ /dev/null
@@ -1,80 +0,0 @@
-// bsg_rp_clk_gen_coarse_delay_element
-//
-// (o       is inverting on even start_tap_p
-//  worst_o is non-inverting)
-//
-// o       contains controllably delayed signal
-// worst_o contains worst-case   delayed signal (for delay matching)
-//
-//
-// we use sed to substitute parameters because the netlist reader
-// does not like them, and we need the netlist reader for rp_groups
-//
-// module bsg_clk_gen_coarse_delay_element #(parameter `BSG_INV_PARAM(start_tap_p))
-//
-// DWP 10/6/2021: Ported from TSMC40 to TSMC28 by reusing cells and appending 7T30P140ULVT for the specific cell lib
-
-module bsg_rp_clk_gen_coarse_delay_tuner
-  (input i
-
-   , input  [1:0] sel_i
-   , input  we_i
-   , input async_reset_neg_i
-   , output       o
-   , output we_o
-   );
-
-   wire [1:0] sel_r;
-   wire [8:0] signal;
-
-   assign signal[0] = i;
-
-   // synopsys rp_group (bsg_clk_gen_cdt)
-   // synopsys rp_fill (0 0 RX)
-
-   CKND2BWP7T30P140ULVT  I1  (.I(signal[0]), .ZN(signal[1]) );
-   CKND2BWP7T30P140ULVT  I2  (.I(signal[1]), .ZN(signal[2]) );
-   CKND4BWP7T30P140ULVT I2a (.I(signal[1]), .ZN()          );
-
-   CKND2BWP7T30P140ULVT  I3  (.I(signal[2]), .ZN(signal[3]) );
-   CKND2BWP7T30P140ULVT  I4  (.I(signal[3]), .ZN(signal[4]) );
-   CKND8BWP7T30P140ULVT I4a (.I(signal[3]), .ZN()          );
-
-   CKND2BWP7T30P140ULVT  I5  (.I(signal[4]), .ZN(signal[5]) );
-   CKND2BWP7T30P140ULVT  I6  (.I(signal[5]), .ZN(signal[6]) );
-   CKND4BWP7T30P140ULVT I6a (.I(signal[5]), .ZN()          );
-
-   CKND2BWP7T30P140ULVT  I7  (.I(signal[6]), .ZN(signal[7]) );
-   CKND2BWP7T30P140ULVT  I8  (.I(signal[7]), .ZN(signal[8]) );
-
-   // synopsys rp_fill (0 1 RX)
-
-   MUX4ND4BWP7T30P140ULVT M1 ( .I0(signal[6])       // start_tap_p + 6
-                        ,.I1(signal[4])       // start_tap_p + 4
-                        ,.I2(signal[2])       // start_tap_p + 2
-                        ,.I3(signal[0])       // start_tap_p + 0
-
-                        ,.S0(sel_r[0])
-                        ,.S1(sel_r[1])
-                        ,.ZN (o   )
-                         );
-
-   wire [1:0] mux_lo;
-
-   // synopsys rp_fill (0 2 RX)
-
-   DFNCND4BWP7T30P140ULVT sel_r_reg_0 (.D(mux_lo[0]), .CPN(o), .CDN(async_reset_neg_i), .Q(sel_r[0]), .QN());
-   MUX2D1BWP7T30P140ULVT MX1 (.I0(sel_r[0]),.I1(sel_i[0]),.S(we_i), .Z(mux_lo[0]));
-
-   // synopsys rp_fill (0 3 RX)
-
-   DFNCND4BWP7T30P140ULVT sel_r_reg_1 (.D(mux_lo[1]), .CPN(o), .CDN(async_reset_neg_i), .Q(sel_r[1]), .QN());
-   MUX2D1BWP7T30P140ULVT MX2 (.I0(sel_r[1]),.I1(sel_i[1]),.S(we_i), .Z(mux_lo[1]));
-
-   // synopsys rp_fill (0 4 RX)
-   BUFFD4BWP7T30P140ULVT we_o_buf (.I(we_i), .Z(we_o));
-
-   // synopsys rp_endgroup (bsg_clk_gen_cdt)
-
-endmodule
-
diff --git a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_fine_delay_tuner.v b/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_fine_delay_tuner.v
deleted file mode 100755
index 91c0bd07..00000000
--- a/hard/tsmc_28/bsg_clk_gen/bsg_rp_clk_gen_fine_delay_tuner.v
+++ /dev/null
@@ -1,75 +0,0 @@
-
-// bsg_rp_clk_gen_fine_delay_tuner
-// fine-tuned sub-gate granularity of delay tuning
-//
-// o is delayed signal, non-inverted
-//
-// DWP 10/6/2021: Ported from TSMC40 to TSMC28 by reusing cells and appending 7T30P140ULVT for the specific cell lib
-
-module bsg_rp_clk_gen_fine_delay_tuner
-  (input i
-   , input we_i
-   , input async_reset_neg_i
-   , input [1:0] sel_i
-   , output o
-   , output buf_o
-   );
-
-   wire [1:0] sel_r;
-   wire [1:0] mux_lo;
-
-   // if wen, capture the select line shortly after a transition
-   // from 1 to 0 of the input i
-
-   // synopsys rp_group (bsg_clk_gen_fdt)
-   // synopsys rp_fill (0 0 UX)
-
-   wire [3:0] ft;
-   wire       i_inv;
-
-   // synopsys rp_fill (0 0 UX)
-
-   // synopsys rp_orient ({N FS} I2_1)
-   CKND3BWP7T30P140ULVT I2_1 (.I(ft[1]),.ZN());
-   // synopsys rp_orient ({N FS} I3_1)
-   CKND3BWP7T30P140ULVT I3_1 (.I(ft[2]),.ZN());
-   // synopsys rp_orient ({N FS} I3_2)
-   CKND4BWP7T30P140ULVT I3_2 (.I(ft[2]),.ZN());
-   // synopsys rp_orient ({N FS} I4_1)
-   CKND3BWP7T30P140ULVT I4_1 (.I(ft[3]),.ZN());
-   // synopsys rp_orient ({N FS} I4_2)
-   CKND4BWP7T30P140ULVT I4_2 (.I(ft[3]),.ZN());
-   // synopsys rp_orient ({N FS} I4_3)
-   CKND4BWP7T30P140ULVT I4_3 (.I(ft[3]),.ZN());
-
-   // same driver with different caps and thus different transition times
-   // synopsys rp_fill (1 0 UX)
-   CKND4BWP7T30P140ULVT I0 (.I(i), .ZN(i_inv));     // decouple load of FDT from previous stage; also makes this inverting
-   CKND2BWP7T30P140ULVT I1 (.I(i_inv), .ZN(ft[0]));
-   CKND2BWP7T30P140ULVT I2 (.I(i_inv), .ZN(ft[1]));
-   CKND2BWP7T30P140ULVT I3 (.I(i_inv), .ZN(ft[2]));
-   CKND2BWP7T30P140ULVT I4 (.I(i_inv), .ZN(ft[3]));
-
-   // flops catch on positive edge of inverted clock
-
-   // synopsys rp_fill (2 0 UX)
-   MUX2D1BWP7T30P140ULVT   MX1 (.I0(sel_r [0]),.I1  (sel_i[0]), .S(we_i)    ,.Z(mux_lo[0]         ));
-   DFCND4BWP7T30P140ULVT DFFR1 (.D(mux_lo[0]),.CP(o), .Q (sel_r[0]), .QN(), .CDN(async_reset_neg_i));
-
-   MUX4ND4BWP7T30P140ULVT M2 (.I0(ft[3]), .I1(ft[2]), .I2(ft[1]), .I3(ft[0])
-              ,.S0(sel_r[0]), .S1(sel_r[1])
-              ,.ZN(o)
-              );
-
-   // capture on positive edge
-   DFCND4BWP7T30P140ULVT DFFR2 (.D(mux_lo[1]),.CP(o), .Q (sel_r[1]), .QN(), .CDN(async_reset_neg_i));
-   MUX2D1BWP7T30P140ULVT   MX2 (.I0(sel_r [1]),.I1  (sel_i[1]), .S(we_i)    ,.Z(mux_lo[1]         ));
-
-   // synopsys rp_fill (3 2 UX)
-
-   CKBD8BWP7T30P140ULVT ICLK (.I(o),        .Z(buf_o) );
-
-   // synopsys rp_endgroup(bsg_clk_gen_fdt)
-
-endmodule
-
diff --git a/hard/tsmc_28/bsg_link/bsg_link_isdr_phy.v b/hard/tsmc_28/bsg_link/bsg_link_isdr_phy.v
deleted file mode 100755
index e8e3acf4..00000000
--- a/hard/tsmc_28/bsg_link/bsg_link_isdr_phy.v
+++ /dev/null
@@ -1,25 +0,0 @@
-
-module bsg_link_isdr_phy
-
- #(parameter `BSG_INV_PARAM(width_p ))
-
-  (input                clk_i
-  ,output               clk_o
-  ,input  [width_p-1:0] data_i
-  ,output [width_p-1:0] data_o
-  );
-
-  wire [width_p-1:0] data_i_buf;
-
-  CKBD4BWP7T40P140 BSG_ISDR_CKBUF_BSG_DONT_TOUCH (.I(clk_i),.Z(clk_o));
-
-  for (genvar i = 0; i < width_p; i++)
-  begin: data
-    CKBD4BWP7T40P140 BSG_ISDR_BUF_BSG_DONT_TOUCH
-    (.I(data_i[i]),.Z(data_i_buf[i]));
-    DFQD1BWP7T40P140 BSG_ISDR_DFFQ
-    (.D(data_i_buf[i]),.CP(clk_o),.Q(data_o[i]));
-  end
-
-endmodule
-`BSG_ABSTRACT_MODULE(bsg_link_isdr_phy)
diff --git a/hard/tsmc_28/bsg_link/bsg_link_osdr_phy.v b/hard/tsmc_28/bsg_link/bsg_link_osdr_phy.v
deleted file mode 100755
index cdae50e4..00000000
--- a/hard/tsmc_28/bsg_link/bsg_link_osdr_phy.v
+++ /dev/null
@@ -1,50 +0,0 @@
-
-module bsg_link_osdr_phy
-
- #(parameter `BSG_INV_PARAM(width_p    )
-  ,parameter strength_p = 0)
-
-  (input                clk_i
-  ,input                reset_i
-  ,input  [width_p-1:0] data_i
-  ,output               clk_o
-  ,output [width_p-1:0] data_o
-  );
-
-`define BSG_LINK_OSDR_PHY_CKBUF_INST_MACRO(strength,name,in,out)          \
-  begin: s``strength``                                                    \
-    CKBD``strength``BWP7T40P140 ``name`` (.I(``in``),.Z(``out``)); \
-  end
-
-`define BSG_LINK_OSDR_PHY_CKBUF_STRENGTH_MACRO(strength,name,in,out) \
-  if (strength_p >= ``strength``)                                    \
-    `BSG_LINK_OSDR_PHY_CKBUF_INST_MACRO(strength,name,in,out)
-
-`define BSG_LINK_OSDR_PHY_CKBUF_MACRO(name,in,out)             \
-  `BSG_LINK_OSDR_PHY_CKBUF_STRENGTH_MACRO(16,name,in,out) else \
-  `BSG_LINK_OSDR_PHY_CKBUF_STRENGTH_MACRO(12,name,in,out) else \
-  `BSG_LINK_OSDR_PHY_CKBUF_STRENGTH_MACRO(8,name,in,out)  else \
-  `BSG_LINK_OSDR_PHY_CKBUF_STRENGTH_MACRO(6,name,in,out)  else \
-  `BSG_LINK_OSDR_PHY_CKBUF_INST_MACRO(4,name,in,out)
-
-  wire clk_r_p, clk_r_n, clk_o_buf;
-  wire [width_p-1:0] data_o_buf;
-
-  CKXOR2D2BWP7T40P140 BSG_OSDR_CKXOR2_BSG_DONT_TOUCH
-  (.Z(clk_o_buf),.A1(clk_r_p),.A2(clk_r_n));
-  `BSG_LINK_OSDR_PHY_CKBUF_MACRO(BSG_OSDR_CKBUF_BSG_DONT_TOUCH, clk_o_buf, clk_o)
-
-  DFD2BWP7T40P140 BSG_OSDR_DFFPOS_BSG_DONT_TOUCH
-  (.D(~(clk_r_p|reset_i)),.CP(clk_i),.Q(clk_r_p), .QN());
-  DFND2BWP7T40P140 BSG_OSDR_DFFNEG_BSG_DONT_TOUCH
-  (.D(~(clk_r_n|reset_i)),.CPN(clk_i),.Q(clk_r_n),.QN());
-
-  for (genvar i = 0; i < width_p; i++)
-  begin: data
-    DFQD1BWP7T40P140 BSG_OSDR_DFFQ
-    (.D(data_i[i]),.CP(clk_i),.Q(data_o_buf[i]));
-    `BSG_LINK_OSDR_PHY_CKBUF_MACRO(BSG_OSDR_BUF_BSG_DONT_TOUCH, data_o_buf[i], data_o[i])
-  end
-
-endmodule
-`BSG_ABSTRACT_MODULE(bsg_link_osdr_phy)
diff --git a/hard/tsmc_28/bsg_link/tcl/bsg_link_sdr.constraints.tcl b/hard/tsmc_28/bsg_link/tcl/bsg_link_sdr.constraints.tcl
deleted file mode 100755
index bc2f46c7..00000000
--- a/hard/tsmc_28/bsg_link/tcl/bsg_link_sdr.constraints.tcl
+++ /dev/null
@@ -1,98 +0,0 @@
-#
-# Paul Gao 03/2021
-#
-# Link to BSG Link SDR Constraints User Guide:
-# https://docs.google.com/document/d/1YEUgOdaGesm_mv495k7OwfxzDKGrBoQ-DphwivE91DE
-#
-
-puts "Info: Start script [info script]\n"
-set BSG_LINK_SDR_USE_GENERATED_CLOCK 0
-
-proc bsg_link_sdr_dont_touch_constraints {in_dv_port} {
-  # inputs
-  set_dont_touch_network -no_propagate $in_dv_port
-  # outputs
-  set_dont_touch_network -no_propagate [get_pins -hier -filter "full_name=~*BSG_OSDR_BUF_BSG_DONT_TOUCH/Z"]
-  global BSG_LINK_SDR_USE_GENERATED_CLOCK
-  puts "BSG_LINK_SDR_USE_GENERATED_CLOCK = $BSG_LINK_SDR_USE_GENERATED_CLOCK"
-  if {$BSG_LINK_SDR_USE_GENERATED_CLOCK == 0} {
-    set_dont_touch_network -no_propagate [get_pins -hier -filter "full_name=~*BSG_OSDR_CKBUF_BSG_DONT_TOUCH/Z"]
-  }
-}
-
-proc bsg_link_sdr_disable_timing_constraints {} {
-  global BSG_LINK_SDR_USE_GENERATED_CLOCK
-  puts "BSG_LINK_SDR_USE_GENERATED_CLOCK = $BSG_LINK_SDR_USE_GENERATED_CLOCK"
-  if {$BSG_LINK_SDR_USE_GENERATED_CLOCK == 0} {
-    set_disable_timing [get_pins -hier -filter "full_name=~*BSG_OSDR_DFFPOS_BSG_DONT_TOUCH/Q"]
-  }
-}
-
-proc bsg_link_sdr_in_constraints {clk_name ports max_delay min_delay} {
-  set_input_delay -max $max_delay -clock $clk_name -source_latency_included -network_latency_included $ports
-  set_input_delay -min $min_delay -clock $clk_name -source_latency_included -network_latency_included -add_delay $ports
-}
-
-proc bsg_link_sdr_out_constraints {clk_port ports setup_time hold_time} {
-  foreach_in_collection obj $ports {
-    set_data_check -rise_from $clk_port -to $obj -setup $setup_time
-    set_data_check -rise_from $clk_port -to $obj -hold  $hold_time
-    set_multicycle_path -end   -setup 1 -to $obj
-    set_multicycle_path -start -hold  0 -to $obj
-  }
-}
-
-proc bsg_link_sdr_out_generated_clock_constraints {clk_name ports max_delay min_delay} {
-  set_output_delay -max $max_delay -clock $clk_name $ports
-  set_output_delay -min $min_delay -clock $clk_name -add_delay $ports
-}
-
-proc bsg_link_sdr_constraints { \
-  master_clk_name               \
-  master_clk_port               \
-  out_clk_name                  \
-  out_clk_period                \
-  out_clk_margin                \
-  out_clk_port                  \
-  out_dv_port                   \
-  in_clk_name                   \
-  in_clk_period                 \
-  in_clk_margin                 \
-  in_clk_port                   \
-  in_dv_port                    \
-  tkn_clk_name                  \
-  tkn_clk_port                  \
-  uncertainty                   \
-} {
-  # token
-  set tkn_clk_period         [expr 2*$in_clk_period]
-  create_clock -period $tkn_clk_period -name $tkn_clk_name $tkn_clk_port
-  set_clock_uncertainty $uncertainty [get_clocks $tkn_clk_name]
-
-  # input
-  set max_input_delay        [expr ($in_clk_period)-$in_clk_margin]
-  set min_input_delay        [expr $in_clk_margin]
-  create_clock -period $in_clk_period -name $in_clk_name $in_clk_port
-  set_clock_uncertainty $uncertainty [get_clocks $in_clk_name]
-  bsg_link_sdr_in_constraints $in_clk_name $in_dv_port $max_input_delay $min_input_delay
-  set_driving_cell -no_design_rule -lib_cell "CKBD4BWP7T40P140" $in_clk_port
-  set_driving_cell -no_design_rule -lib_cell "CKBD4BWP7T40P140" $in_dv_port
-
-  # output
-  global BSG_LINK_SDR_USE_GENERATED_CLOCK
-  puts "BSG_LINK_SDR_USE_GENERATED_CLOCK = $BSG_LINK_SDR_USE_GENERATED_CLOCK"
-  if {$BSG_LINK_SDR_USE_GENERATED_CLOCK == 0} {
-    set setup_time_output      [expr ($out_clk_period/2)-$out_clk_margin]
-    set hold_time_output       [expr ($out_clk_period/2)-$out_clk_margin]
-    bsg_link_sdr_out_constraints $out_clk_port $out_dv_port $setup_time_output $hold_time_output
-  } else {
-    set max_output_delay       [expr ($out_clk_period/2)-$out_clk_margin]
-    set min_output_delay       [expr $out_clk_margin-($out_clk_period/2)]
-    create_generated_clock -divide_by 1 -invert -master_clock $master_clk_name -source $master_clk_port -name $out_clk_name $out_clk_port
-    bsg_link_sdr_out_generated_clock_constraints $out_clk_name $out_dv_port $max_output_delay $min_output_delay
-  }
-  set_load [load_of [get_lib_pin "*/CKBD4BWP7T40P140/I"]] $out_clk_port
-  set_load [load_of [get_lib_pin "*/CKBD4BWP7T40P140/I"]] $out_dv_port
-}
-
-puts "Info: Completed script [info script]\n"
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_macros.vh
deleted file mode 100755
index f9cb26c1..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_macros.vh
+++ /dev/null
@@ -1,101 +0,0 @@
-`ifndef BSG_MEM_1R1W_SYNC_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MACROS_VH
-
-//
-// Synchronous 2-port ram.
-//
-// When read and write with the same address, the behavior depends on which
-// clock arrives first, and the read/write clock MUST be separated at least
-// twrcc, otherwise will incur indeterminate result. 
-//
-
-`define bsg_mem_1r1w_sync_2rf_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem      \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.REB      ( ~r_v_i        )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r_data_o      )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_1r1w_sync_2sram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r_v_i        )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r_data_o      )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_1r1w_sync_2hdsram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem   \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r_v_i        )                       \
-             ,.QB       ( r_data_o      )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_1r1w_sync_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && width_p == bits) begin: macro \
-    bsg_mem_1r1w_sync_banked #(                                             \
-      .width_p(width_p)                                                     \
-      ,.els_p(els_p)                                                        \
-      ,.read_write_same_addr_p(read_write_same_addr_p)                      \
-      ,.num_width_bank_p(wbank)                                             \
-      ,.num_depth_bank_p(dbank)                                             \
-    ) bmem (                                                                \
-      .clk_i(clk_i)                                                         \
-      ,.reset_i(reset_i)                                                    \
-      ,.w_v_i(w_v_i)                                                        \
-      ,.w_addr_i(w_addr_i)                                                  \
-      ,.w_data_i(w_data_i)                                                  \
-      ,.r_v_i(r_v_i)                                                        \
-      ,.r_addr_i(r_addr_i)                                                  \
-      ,.r_data_o(r_data_o)                                                  \
-    );                                                                      \
-  end: macro
-
-`endif
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh
deleted file mode 100755
index d6132d36..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,78 +0,0 @@
-`ifndef BSG_MEM_1R1W_SYNC_MASK_WRITE_BIT_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MASK_WRITE_BIT_MACROS_VH
-
-`define bsg_mem_1r1w_sync_mask_write_bit_2rf_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_bit_2rf mem  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.BWEB     ( ~w_mask_i     )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.REB      ( ~r_v_i        )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r_data_o      )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_1r1w_sync_mask_write_bit_2sram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_bit_2sram mem \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.BWEBA    ( ~w_mask_i     )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.DB       ( '1            )                       \
-             ,.BWEBB    ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r_v_i        )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r_data_o      )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_1r1w_sync_mask_write_bit_2hdsram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_bit_2hdsram mem \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.BWEBA    ( ~w_mask_i     )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r_addr_i      )                       \
-             ,.DB       ( '1            )                       \
-             ,.BWEBB    ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r_v_i        )                       \
-             ,.QB       ( r_data_o      )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-  end
-
-`endif 
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh
deleted file mode 100755
index 97c182c2..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1r1w_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,36 +0,0 @@
-`ifndef BSG_MEM_1R1W_SYNC_MASK_WRITE_BYTE_MACROS_VH
-`define BSG_MEM_1R1W_SYNC_MASK_WRITE_BYTE_MACROS_VH
-
-//
-// Synchronous 2-port ram.
-//
-// When read and write with the same address, the behavior depends on which
-// clock arrives first, and the read/write clock MUST be separated at least
-// twrcc, otherwise will incur indeterminate result. 
-//
-
-`define bsg_mem_1r1w_sync_mask_write_byte_2rf_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_1r1w_sync_mask_write_byte_2sram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_1r1w_sync_mask_write_byte_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits)
-
-`define bsg_mem_1r1w_sync_mask_write_byte_macro(words,bits) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: wrap                                                   \
-    logic [width_p-1:0] w_mask_li;                              \
-    bsg_expand_bitmask                                          \
-     #(.in_width_p(write_mask_width_lp), .expand_p(8))          \
-     wmask_expand                                               \
-      (.i(w_mask_i)                                             \
-       ,.o(w_mask_li)                                           \
-       );                                                       \
-                                                                \
-    bsg_mem_1r1w_sync_mask_write_bit                            \
-     #(.width_p(width_p), .els_p(els_p))                        \
-     bit_mem                                                    \
-      (.w_mask_i(w_mask_li), .*);                               \
-  end
-
-`endif 
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_macros.vh
deleted file mode 100755
index 14714fb9..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_macros.vh
+++ /dev/null
@@ -1,68 +0,0 @@
-`ifndef BSG_MEM_1RW_SYNC_MACROS_VH
-`define BSG_MEM_1RW_SYNC_MACROS_VH
-
-`define bsg_mem_1rw_sync_1rf_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_1rf mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_1sram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_1sram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_1hdsram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_1hdsram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.WTSEL    ( 2'b00         )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && width_p == bits) begin: macro \
-    bsg_mem_1rw_sync_banked #(                                              \
-      .width_p(width_p)                                                     \
-      ,.els_p(els_p)                                                        \
-      ,.latch_last_read_p(latch_last_read_p)                                \
-      ,.num_width_bank_p(wbank)                                             \
-      ,.num_depth_bank_p(dbank)                                             \
-    ) bmem (                                                                \
-      .clk_i(clk_i)                                                         \
-      ,.reset_i(reset_i)                                                    \
-      ,.v_i(v_i)                                                            \
-      ,.w_i(w_i)                                                            \
-      ,.addr_i(addr_i)                                                      \
-      ,.data_i(data_i)                                                      \
-      ,.data_o(data_o)                                                      \
-    );                                                                      \
-  end: macro
-
-`endif
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
deleted file mode 100755
index db4de773..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,72 +0,0 @@
-`ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-`define BSG_MEM_1RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-
-`define bsg_mem_1rw_sync_mask_write_bit_1rf_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_bit_1rf mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.BWEB     ( ~w_mask_i     )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_mask_write_bit_1sram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_bit_1sram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.BWEB     ( ~w_mask_i     )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_mask_write_bit_1hdsram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_1rw_d``words``_w``bits``_``tag``_bit_1hdsram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEB      ( ~v_i          )                       \
-             ,.WEB      ( ~w_i          )                       \
-             ,.BWEB     ( ~w_mask_i     )                       \
-             ,.A        ( addr_i        )                       \
-             ,.D        ( data_i        )                       \
-             ,.Q        ( data_o        )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.WTSEL    ( 2'b00         )                       \
-            );                                                  \
-    end
-
-`define bsg_mem_1rw_sync_mask_write_bit_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && width_p == bits) begin: macro \
-    bsg_mem_1rw_sync_mask_write_bit_banked #(                     \
-      .width_p(width_p)                                                     \
-      ,.els_p(els_p)                                                        \
-      ,.latch_last_read_p(latch_last_read_p)                                \
-      ,.num_width_bank_p(wbank)                                             \
-      ,.num_depth_bank_p(dbank)                                             \
-    ) bmem (                                                                \
-      .clk_i(clk_i)                                                         \
-      ,.reset_i(reset_i)                                                    \
-      ,.v_i(v_i)                                                            \
-      ,.w_i(w_i)                                                            \
-      ,.addr_i(addr_i)                                                      \
-      ,.data_i(data_i)                                                      \
-      ,.w_mask_i(w_mask_i)                                                  \
-      ,.data_o(data_o)                                                      \
-    );                                                                      \
-  end: macro
-
-`endif
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
deleted file mode 100755
index b1f83224..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_1rw_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,48 +0,0 @@
-`ifndef BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-`define BSG_MEM_1RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-
-`define bsg_mem_1rw_sync_mask_write_byte_1rf_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_1rw_sync_mask_write_byte_1sram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_1rw_sync_mask_write_byte_1hdsram_macro(words,bits,tag) \
-  `bsg_mem_1rw_sync_mask_write_byte_macro(words,bits)
-
-`define bsg_mem_1rw_sync_mask_write_byte_macro(words,bits) \
-if (harden_p && els_p == words && data_width_p == bits)         \
-  begin: wrap                                                   \
-    logic [data_width_p-1:0] w_mask_li;                         \
-    bsg_expand_bitmask                                          \
-     #(.in_width_p(write_mask_width_lp), .expand_p(8))          \
-     wmask_expand                                               \
-      (.i(write_mask_i)                                         \
-       ,.o(w_mask_li)                                           \
-       );                                                       \
-                                                                \
-    bsg_mem_1rw_sync_mask_write_bit                             \
-     #(.width_p(data_width_p), .els_p(els_p))                   \
-     bit_mem                                                    \
-      (.w_mask_i(w_mask_li), .*);                               \
-  end
-
-`define bsg_mem_1rw_sync_mask_write_byte_banked_macro(words,bits,wbank,dbank) \
-  if (harden_p && els_p == words && data_width_p == bits) begin: macro        \
-      bsg_mem_1rw_sync_mask_write_byte_banked #(                              \
-        .data_width_p(data_width_p)                                           \
-        ,.els_p(els_p)                                                        \
-        ,.latch_last_read_p(latch_last_read_p)                                \
-        ,.num_width_bank_p(wbank)                                             \
-        ,.num_depth_bank_p(dbank)                                             \
-      ) bmem (                                                                \
-        .clk_i(clk_i)                                                         \
-        ,.reset_i(reset_i)                                                    \
-        ,.v_i(v_i)                                                            \
-        ,.w_i(w_i)                                                            \
-        ,.addr_i(addr_i)                                                      \
-        ,.data_i(data_i)                                                      \
-        ,.write_mask_i(write_mask_i)                                          \
-        ,.data_o(data_o)                                                      \
-      );                                                                      \
-    end: macro
-
-`endif 
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_2r1w_sync_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_2r1w_sync_macros.vh
deleted file mode 100644
index a0daf6fe..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_2r1w_sync_macros.vh
+++ /dev/null
@@ -1,129 +0,0 @@
-
-`ifndef BSG_MEM_2R1W_SYNC_MACROS_VH
-`define BSG_MEM_2R1W_SYNC_MACROS_VH
-
-`define bsg_mem_2r1w_sync_2rf_macro(words,bits,tag) \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                                \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem0     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.REB      ( ~r0_v_i       )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r0_data_o     )                       \
-            );                                                  \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem1     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.REB      ( ~r1_v_i       )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r1_data_o     )                       \
-            );                                                  \
-    end: macro
-
-`define bsg_mem_2r1w_sync_2sram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem0    \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r0_v_i       )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r0_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem1    \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r1_v_i       )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r1_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_2r1w_sync_2hdsram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem0  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r0_v_i       )                       \
-             ,.QB       ( r0_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem1  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r1_v_i       )                       \
-             ,.QB       ( r1_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-  end
-
-`endif
-
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_macros.vh
deleted file mode 100755
index 127ff7bd..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_macros.vh
+++ /dev/null
@@ -1,53 +0,0 @@
-`ifndef BSG_MEM_2RW_SYNC_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MACROS_VH
-
-`define bsg_mem_2rw_sync_2sram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem  \
-            (                                                   \
-              .CLKA     ( clk_i         )                       \
-             ,.CEBA     ( ~a_v_i        )                       \
-             ,.WEBA     ( ~a_w_i        )                       \
-             ,.AA       ( a_addr_i      )                       \
-             ,.DA       ( a_data_i      )                       \
-             ,.QA       ( a_data_o      )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.CEBB     ( ~b_v_i        )                       \
-             ,.WEBB     ( ~b_w_i        )                       \
-             ,.AB       ( b_addr_i      )                       \
-             ,.DB       ( b_data_i      )                       \
-             ,.QB       ( b_data_o      )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-    end
-
-
-`define bsg_mem_2rw_sync_2hdsram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEBA     ( ~a_v_i        )                       \
-             ,.WEBA     ( ~a_w_i        )                       \
-             ,.AA       ( a_addr_i      )                       \
-             ,.DA       ( a_data_i      )                       \
-             ,.QA       ( a_data_o      )                       \
-             ,.CEBB     ( ~b_v_i        )                       \
-             ,.WEBB     ( ~b_w_i        )                       \
-             ,.AB       ( b_addr_i      )                       \
-             ,.DB       ( b_data_i      )                       \
-             ,.QB       ( b_data_o      )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-    end
-
-`endif 
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh
deleted file mode 100755
index 2d950747..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_bit_macros.vh
+++ /dev/null
@@ -1,57 +0,0 @@
-`ifndef BSG_MEM_2RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MASK_WRITE_BIT_MACROS_VH
-
-`define bsg_mem_2rw_sync_mask_write_bit_2sram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_bit_2sram mem  \
-            (                                                   \
-              .CLKA     ( clk_i         )                       \
-             ,.CEBA     ( ~a_v_i        )                       \
-             ,.WEBA     ( ~a_w_i        )                       \
-             ,.BWEBA    ( ~a_w_mask_i   )                       \
-             ,.AA       ( a_addr_i      )                       \
-             ,.DA       ( a_data_i      )                       \
-             ,.QA       ( a_data_o      )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.CEBB     ( ~b_v_i        )                       \
-             ,.WEBB     ( ~b_w_i        )                       \
-             ,.BWEBB    ( ~b_w_mask_i   )                       \
-             ,.AB       ( b_addr_i      )                       \
-             ,.DB       ( b_data_i      )                       \
-             ,.QB       ( b_data_o      )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-    end
-
-
-`define bsg_mem_2rw_sync_mask_write_bit_2hdsram_macro(words,bits,tag)       \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                     \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_bit_2hdsram mem  \
-            (                                                   \
-              .CLK      ( clk_i         )                       \
-             ,.CEBA     ( ~a_v_i        )                       \
-             ,.WEBA     ( ~a_w_i        )                       \
-             ,.BWEBA    ( ~a_w_mask_i   )                       \
-             ,.AA       ( a_addr_i      )                       \
-             ,.DA       ( a_data_i      )                       \
-             ,.QA       ( a_data_o      )                       \
-             ,.CEBB     ( ~b_v_i        )                       \
-             ,.WEBB     ( ~b_w_i        )                       \
-             ,.BWEBB    ( ~b_w_mask_i   )                       \
-             ,.AB       ( b_addr_i      )                       \
-             ,.DB       ( b_data_i      )                       \
-             ,.QB       ( b_data_o      )                       \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-    end
-
-`endif
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh
deleted file mode 100755
index 8a1cd53c..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_2rw_sync_mask_write_byte_macros.vh
+++ /dev/null
@@ -1,36 +0,0 @@
-`ifndef BSG_MEM_2RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-`define BSG_MEM_2RW_SYNC_MASK_WRITE_BYTE_MACROS_VH
-
-`define bsg_mem_2rw_sync_mask_write_byte_2rf_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_2rw_sync_mask_write_byte_2sram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_byte_macro(words,bits)
-`define bsg_mem_2rw_sync_mask_write_byte_2hdsram_macro(words,bits,tag) \
-  `bsg_mem_2rw_sync_mask_write_byte_macro(words,bits)
-
-`define bsg_mem_2rw_sync_mask_write_byte_macro(words,bits) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: wrap                                                   \
-  logic [width_p-1:0] a_w_mask_li;                              \
-  bsg_expand_bitmask                                            \
-   #(.in_width_p(write_mask_width_lp), .expand_p(8))            \
-   a_wmask_expand                                               \
-    (.i(a_w_mask_i)                                             \
-     ,.o(a_w_mask_li)                                           \
-     );                                                         \
-                                                                \
-  logic [width_p-1:0] b_w_mask_li;                              \
-  bsg_expand_bitmask                                            \
-   #(.in_width_p(write_mask_width_lp), .expand_p(8))            \
-   b_wmask_expand                                               \
-    (.i(b_w_mask_i)                                             \
-     ,.o(b_w_mask_li)                                           \
-     );                                                         \
-                                                                \
-  bsg_mem_2rw_sync_mask_write_bit                               \
-   #(.width_p(width_p), .els_p(els_p))                          \
-   bit_mem                                                      \
-    (.a_w_mask_i(a_w_mask_li), .b_w_mask_i(b_w_mask_i), .*);    \
-  end
-
-`endif 
diff --git a/hard/tsmc_28/bsg_mem/bsg_mem_3r1w_sync_macros.vh b/hard/tsmc_28/bsg_mem/bsg_mem_3r1w_sync_macros.vh
deleted file mode 100644
index 013cd6e3..00000000
--- a/hard/tsmc_28/bsg_mem/bsg_mem_3r1w_sync_macros.vh
+++ /dev/null
@@ -1,183 +0,0 @@
-
-`ifndef BSG_MEM_3R1W_SYNC_MACROS_VH
-`define BSG_MEM_3R1W_SYNC_MACROS_VH
-
-`define bsg_mem_3r1w_sync_2rf_macro(words,bits,tag) \
-  if (harden_p && els_p == words && width_p == bits) \
-    begin: macro                                                \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem0     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.REB      ( ~r0_v_i       )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r0_data_o     )                       \
-            );                                                  \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem1     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.REB      ( ~r1_v_i       )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r1_data_o     )                       \
-            );                                                  \
-          tsmc28_1r1w_d``words``_w``bits``_``tag``_2rf mem2     \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.D        ( w_data_i      )                       \
-             ,.WEB      ( ~w_v_i        )                       \
-             ,.CLKW     ( clk_i         )                       \
-                                                                \
-             ,.AB       ( r2_addr_i     )                       \
-             ,.REB      ( ~r2_v_i       )                       \
-             ,.CLKR     ( clk_i         )                       \
-             ,.Q        ( r2_data_o     )                       \
-            );                                                  \
-    end: macro
-
-`define bsg_mem_3r1w_sync_2sram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem0    \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r0_v_i       )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r0_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem1    \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r1_v_i       )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r1_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2sram mem2    \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLKA     ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r2_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r2_v_i       )                       \
-             ,.CLKB     ( clk_i         )                       \
-             ,.QB       ( r2_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b01         )                       \
-             ,.RTSEL    ( 2'b01         )                       \
-             ,.VG       ( 1'b1          )                       \
-             ,.VS       ( 1'b1          )                       \
-            );                                                  \
-  end
-
-`define bsg_mem_3r1w_sync_2hdsram_macro(words,bits,tag) \
-if (harden_p && els_p == words && width_p == bits)              \
-  begin: macro                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem0  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r0_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r0_v_i       )                       \
-             ,.QB       ( r0_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem1  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r1_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r1_v_i       )                       \
-             ,.QB       ( r1_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-          tsmc28_2rw_d``words``_w``bits``_``tag``_2hdsram mem2  \
-            (                                                   \
-              .AA       ( w_addr_i      )                       \
-             ,.DA       ( w_data_i      )                       \
-             ,.WEBA     ( ~w_v_i        )                       \
-             ,.CEBA     ( ~w_v_i        )                       \
-             ,.CLK      ( clk_i         )                       \
-             ,.QA       (               )                       \
-                                                                \
-             ,.AB       ( r2_addr_i     )                       \
-             ,.DB       ( '1            )                       \
-             ,.WEBB     ( '1            )                       \
-             ,.CEBB     ( ~r2_v_i       )                       \
-             ,.QB       ( r2_data_o     )                       \
-                                                                \
-             /* According to TSMC, other settings are for debug only */ \
-             ,.WTSEL    ( 2'b00         )                       \
-             ,.RTSEL    ( 2'b00         )                       \
-             ,.PTSEL    ( 2'b00         )                       \
-            );                                                  \
-  end
-
-`endif
-
diff --git a/hard/tsmc_28/bsg_misc/bsg_buf.v b/hard/tsmc_28/bsg_misc/bsg_buf.v
deleted file mode 100644
index 2938d057..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_buf.v
+++ /dev/null
@@ -1,114 +0,0 @@
-`define bsg_buf_macro(bits)                                   \
-if (harden_p && (width_p==bits))                              \
-  begin: macro                                                \
-    for (genvar j = 0; j < width_p; j++)                      \
-      begin : b                                               \
-        BUFFD8BWP7T40P140 b (.I(i[j]), .Z(o[j]));             \
-      end                                                     \
-  end
-
-module bsg_buf #(parameter `BSG_INV_PARAM(width_p)
-                 , parameter harden_p=1
-		 , parameter vertical_p=1
-                 )
-   (input    [width_p-1:0] i
-    , output [width_p-1:0] o
-    );
-
-   `bsg_buf_macro(89) else
-   `bsg_buf_macro(88) else
-   `bsg_buf_macro(87) else
-   `bsg_buf_macro(86) else
-   `bsg_buf_macro(85) else
-   `bsg_buf_macro(84) else
-   `bsg_buf_macro(83) else
-   `bsg_buf_macro(82) else
-   `bsg_buf_macro(81) else
-   `bsg_buf_macro(80) else
-   `bsg_buf_macro(79) else
-   `bsg_buf_macro(78) else
-   `bsg_buf_macro(77) else
-   `bsg_buf_macro(76) else
-   `bsg_buf_macro(75) else
-   `bsg_buf_macro(74) else
-   `bsg_buf_macro(73) else
-   `bsg_buf_macro(72) else
-   `bsg_buf_macro(71) else
-   `bsg_buf_macro(70) else
-   `bsg_buf_macro(69) else
-   `bsg_buf_macro(68) else
-   `bsg_buf_macro(67) else
-   `bsg_buf_macro(66) else
-   `bsg_buf_macro(65) else
-   `bsg_buf_macro(64) else
-   `bsg_buf_macro(63) else
-   `bsg_buf_macro(62) else
-   `bsg_buf_macro(61) else
-   `bsg_buf_macro(60) else
-   `bsg_buf_macro(59) else
-   `bsg_buf_macro(58) else
-   `bsg_buf_macro(57) else
-   `bsg_buf_macro(56) else
-   `bsg_buf_macro(55) else
-   `bsg_buf_macro(54) else
-   `bsg_buf_macro(53) else
-   `bsg_buf_macro(52) else
-   `bsg_buf_macro(51) else
-   `bsg_buf_macro(50) else
-   `bsg_buf_macro(49) else
-   `bsg_buf_macro(48) else
-   `bsg_buf_macro(47) else
-   `bsg_buf_macro(46) else
-   `bsg_buf_macro(45) else
-   `bsg_buf_macro(44) else
-   `bsg_buf_macro(43) else
-   `bsg_buf_macro(42) else
-   `bsg_buf_macro(41) else
-   `bsg_buf_macro(40) else
-   `bsg_buf_macro(39) else
-   `bsg_buf_macro(38) else
-   `bsg_buf_macro(37) else
-   `bsg_buf_macro(36) else
-   `bsg_buf_macro(35) else
-   `bsg_buf_macro(34) else
-   `bsg_buf_macro(33) else
-   `bsg_buf_macro(32) else
-   `bsg_buf_macro(31) else
-   `bsg_buf_macro(30) else
-   `bsg_buf_macro(29) else
-   `bsg_buf_macro(28) else
-   `bsg_buf_macro(27) else
-   `bsg_buf_macro(26) else
-   `bsg_buf_macro(25) else
-   `bsg_buf_macro(24) else
-   `bsg_buf_macro(23) else
-   `bsg_buf_macro(22) else
-   `bsg_buf_macro(21) else
-   `bsg_buf_macro(20) else
-   `bsg_buf_macro(19) else
-   `bsg_buf_macro(18) else
-   `bsg_buf_macro(17) else
-   `bsg_buf_macro(16) else
-   `bsg_buf_macro(15) else
-   `bsg_buf_macro(14) else
-   `bsg_buf_macro(13) else
-   `bsg_buf_macro(12) else
-   `bsg_buf_macro(11) else
-   `bsg_buf_macro(10) else
-   `bsg_buf_macro(9) else
-   `bsg_buf_macro(8) else
-   `bsg_buf_macro(7) else
-   `bsg_buf_macro(6) else
-   `bsg_buf_macro(5) else
-   `bsg_buf_macro(4) else
-   `bsg_buf_macro(3) else
-   `bsg_buf_macro(2) else
-   `bsg_buf_macro(1) else
-       begin :notmacro
-          initial assert(harden_p==0) else $error("## %m wanted to harden but no macro");
-
-             assign o = i;
-      end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_buf)
diff --git a/hard/tsmc_28/bsg_misc/bsg_clkmux.v b/hard/tsmc_28/bsg_misc/bsg_clkmux.v
deleted file mode 100644
index c696ed6b..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_clkmux.v
+++ /dev/null
@@ -1,69 +0,0 @@
-`include "bsg_defines.v"
-module bsg_clkmux #(els_p = 2
-                 , width_p = 1
-                 , harden_p = 1
-                 , strength_p = 0
-                 , lg_els_lp=`BSG_SAFE_CLOG2(els_p)
-                 )
-   (
-    input [els_p-1:0][width_p-1:0] data_i
-    ,input [lg_els_lp-1:0] sel_i
-    ,output [width_p-1:0] data_o
-    );
-
-  localparam total_els_lp = width_p*els_p;
-  localparam pot_els_lp = 2**$clog2(total_els_lp);
-
-   if (total_els_lp == 2 && strength_p == 0)
-     begin : s0
-       CLMUX2D0BWP7T40P140 c
-        (.I0(data_i[0], .I1(data_i[1]), .S(sel_i), .Z(data_o));
-     end
-   else if (total_els_lp == 2 && strength_p == 1)
-     begin : s1
-       CLMUX2D1BWP7T40P140 c 
-        (.I0(data_i[0], .I1(data_i[1]), .S(sel_i), .Z(data_o));
-     end
-   else if (total_els_lp == 2 && strength_p == 2)
-     begin : s1
-       CLMUX2D2BWP7T40P140 c
-        (.I0(data_i[0], .I1(data_i[1]), .S(sel_i), .Z(data_o));
-     end
-   else if (total_els_lp == 2 && strength_p == 4)
-     begin : s1
-       CLMUX2D4BWP7T40P140 c
-        (.I0(data_i[0], .I1(data_i[1]), .S(sel_i), .Z(data_o));
-     end
-   else if (total_els_lp == 2 && strength_p == 8)
-     begin : s1
-       CLMUX2D8BWP7T40P140 c
-        (.I0(data_i[0], .I1(data_i[1]), .S(sel_i), .Z(data_o));
-     end
-   else
-     begin
-       localparam new_els_lp = new_els_lp;
-       localparam lg_new_els_lp = `BSG_SAFE_CLOG2(new_els_lp);
-       wire [pot_els_lp-1:0] data_li = {{(pot_els_lp-total_els_lp){1'b0}}, data_i};
-       logic [new_els_lp-1:0] c0_lo;
-       bsg_clkmux #(.els_p(new_els_lp), .harden_p(harden_p), .strength_p(strength_p)) c0
-        (.data_i(data_li[0+:new_els_lp])
-         ,.sel_i(sel_i[0+:lg_new_els_lp])
-         ,.data_o(c0_lo)
-         );
-       logic [new_els_lp-1:0] c1_lo;
-       bsg_clkmux #(.els_p(new_els_lp), .harden_p(harden_p), .strength_p(strength_p)) c1
-        (.data_i(data_li[new_els_lp+:new_els_lp])
-         ,.sel_i(sel_i[0+:lg_new_els_lp])
-         ,.data_o(c1_lo)
-         );
-       bsg_clkmux #(.width_p(new_width_lp), .harden_p(harden_p), .strength_p(strength_p)) c2
-        (.data_i({c1_lo, c0_lo})
-         ,.sel_i(sel_i[lg_new_els_lp])
-         ,.data_o(data_o)
-         );
-     end
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_clkmux)
-
diff --git a/hard/tsmc_28/bsg_misc/bsg_dff.v b/hard/tsmc_28/bsg_misc/bsg_dff.v
deleted file mode 100644
index effeed46..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_dff.v
+++ /dev/null
@@ -1,190 +0,0 @@
-`define bsg_dff_macro(bits,strength)                      \
-if (harden_p && (width_p==bits) && (strength_p==strength)) \
-  begin: macro                                                \
-    for (genvar j = 0; j < width_p; j++)                      \
-      begin : d                                               \
-        DFQD``strength``BWP7T40P140 d (.CP(clk_i), .D(data_i[j]), .Q(data_o[j])); \
-      end                                                     \
-  end
-
-module bsg_dff #(width_p=-1, harden_p=1, strength_p=1)
-   (input   clk_i
-    ,input  [width_p-1:0] data_i
-    ,output [width_p-1:0] data_o
-    );
-
-   `bsg_dff_macro(80,1) else
-   `bsg_dff_macro(79,1) else
-   `bsg_dff_macro(78,1) else
-   `bsg_dff_macro(77,1) else
-   `bsg_dff_macro(76,1) else
-   `bsg_dff_macro(75,1) else
-   `bsg_dff_macro(74,1) else
-   `bsg_dff_macro(73,1) else
-   `bsg_dff_macro(72,1) else
-   `bsg_dff_macro(71,1) else
-   `bsg_dff_macro(70,1) else
-   `bsg_dff_macro(69,1) else
-   `bsg_dff_macro(68,1) else
-   `bsg_dff_macro(67,1) else
-   `bsg_dff_macro(66,1) else
-   `bsg_dff_macro(65,1) else
-   `bsg_dff_macro(64,1) else
-   `bsg_dff_macro(63,1) else
-   `bsg_dff_macro(62,1) else
-   `bsg_dff_macro(61,1) else
-   `bsg_dff_macro(60,1) else
-   `bsg_dff_macro(59,1) else
-   `bsg_dff_macro(58,1) else
-   `bsg_dff_macro(57,1) else
-   `bsg_dff_macro(56,1) else
-   `bsg_dff_macro(55,1) else
-   `bsg_dff_macro(54,1) else
-   `bsg_dff_macro(53,1) else
-   `bsg_dff_macro(52,1) else
-   `bsg_dff_macro(51,1) else
-   `bsg_dff_macro(50,1) else
-   `bsg_dff_macro(49,1) else
-   `bsg_dff_macro(48,1) else
-   `bsg_dff_macro(47,1) else
-   `bsg_dff_macro(46,1) else
-   `bsg_dff_macro(45,1) else
-   `bsg_dff_macro(44,1) else
-   `bsg_dff_macro(43,1) else
-   `bsg_dff_macro(42,1) else
-   `bsg_dff_macro(41,1) else      
-   `bsg_dff_macro(40,1) else
-   `bsg_dff_macro(39,1) else
-   `bsg_dff_macro(38,1) else
-   `bsg_dff_macro(37,1) else
-   `bsg_dff_macro(36,1) else
-   `bsg_dff_macro(35,1) else
-   `bsg_dff_macro(34,1) else
-   `bsg_dff_macro(33,1) else
-   `bsg_dff_macro(32,1) else
-   `bsg_dff_macro(31,1) else
-   `bsg_dff_macro(30,1) else
-   `bsg_dff_macro(29,1) else
-   `bsg_dff_macro(28,1) else
-   `bsg_dff_macro(27,1) else
-   `bsg_dff_macro(26,1) else
-   `bsg_dff_macro(25,1) else
-   `bsg_dff_macro(24,1) else
-   `bsg_dff_macro(23,1) else
-   `bsg_dff_macro(22,1) else
-   `bsg_dff_macro(21,1) else      
-   `bsg_dff_macro(20,1) else
-   `bsg_dff_macro(19,1) else
-   `bsg_dff_macro(18,1) else
-   `bsg_dff_macro(17,1) else
-   `bsg_dff_macro(16,1) else
-   `bsg_dff_macro(15,1) else
-   `bsg_dff_macro(14,1) else
-   `bsg_dff_macro(13,1) else
-   `bsg_dff_macro(12,1) else
-   `bsg_dff_macro(11,1) else
-   `bsg_dff_macro(10,1) else
-   `bsg_dff_macro(9,1) else
-   `bsg_dff_macro(8,1) else
-   `bsg_dff_macro(7,1) else
-   `bsg_dff_macro(6,1) else
-   `bsg_dff_macro(5,1) else
-   `bsg_dff_macro(4,1) else
-   `bsg_dff_macro(3,1) else
-   `bsg_dff_macro(2,1) else
-   `bsg_dff_macro(1,1) else
-   `bsg_dff_macro(40,2) else
-   `bsg_dff_macro(39,2) else
-   `bsg_dff_macro(38,2) else
-   `bsg_dff_macro(37,2) else
-   `bsg_dff_macro(36,2) else
-   `bsg_dff_macro(35,2) else
-   `bsg_dff_macro(34,2) else
-   `bsg_dff_macro(33,2) else
-   `bsg_dff_macro(32,2) else
-   `bsg_dff_macro(31,2) else
-   `bsg_dff_macro(30,2) else
-   `bsg_dff_macro(29,2) else
-   `bsg_dff_macro(28,2) else
-   `bsg_dff_macro(27,2) else
-   `bsg_dff_macro(26,2) else
-   `bsg_dff_macro(25,2) else
-   `bsg_dff_macro(24,2) else
-   `bsg_dff_macro(23,2) else
-   `bsg_dff_macro(22,2) else
-   `bsg_dff_macro(21,2) else      
-   `bsg_dff_macro(20,2) else
-   `bsg_dff_macro(19,2) else
-   `bsg_dff_macro(18,2) else
-   `bsg_dff_macro(17,2) else
-   `bsg_dff_macro(16,2) else
-   `bsg_dff_macro(15,2) else
-   `bsg_dff_macro(14,2) else
-   `bsg_dff_macro(13,2) else
-   `bsg_dff_macro(12,2) else
-   `bsg_dff_macro(11,2) else
-   `bsg_dff_macro(10,2) else
-   `bsg_dff_macro(9,2) else
-   `bsg_dff_macro(8,2) else
-   `bsg_dff_macro(7,2) else
-   `bsg_dff_macro(6,2) else
-   `bsg_dff_macro(5,2) else
-   `bsg_dff_macro(4,2) else
-   `bsg_dff_macro(3,2) else
-   `bsg_dff_macro(2,2) else
-   `bsg_dff_macro(1,2) else
-   `bsg_dff_macro(40,4) else
-   `bsg_dff_macro(39,4) else
-   `bsg_dff_macro(38,4) else
-   `bsg_dff_macro(37,4) else
-   `bsg_dff_macro(36,4) else
-   `bsg_dff_macro(35,4) else
-   `bsg_dff_macro(34,4) else
-   `bsg_dff_macro(33,4) else
-   `bsg_dff_macro(32,4) else
-   `bsg_dff_macro(31,4) else
-   `bsg_dff_macro(30,4) else
-   `bsg_dff_macro(29,4) else
-   `bsg_dff_macro(28,4) else
-   `bsg_dff_macro(27,4) else
-   `bsg_dff_macro(26,4) else
-   `bsg_dff_macro(25,4) else
-   `bsg_dff_macro(24,4) else
-   `bsg_dff_macro(23,4) else
-   `bsg_dff_macro(22,4) else
-   `bsg_dff_macro(21,4) else
-   `bsg_dff_macro(20,4) else
-   `bsg_dff_macro(19,4) else
-   `bsg_dff_macro(18,4) else
-   `bsg_dff_macro(17,4) else
-   `bsg_dff_macro(16,4) else
-   `bsg_dff_macro(15,4) else
-   `bsg_dff_macro(14,4) else
-   `bsg_dff_macro(13,4) else
-   `bsg_dff_macro(12,4) else
-   `bsg_dff_macro(11,4) else
-   `bsg_dff_macro(10,4) else
-   `bsg_dff_macro(9,4) else
-   `bsg_dff_macro(8,4) else
-   `bsg_dff_macro(7,4) else
-   `bsg_dff_macro(6,4) else
-   `bsg_dff_macro(5,4) else
-   `bsg_dff_macro(4,4) else
-   `bsg_dff_macro(3,4) else
-   `bsg_dff_macro(2,4) else
-   `bsg_dff_macro(1,4) else
-    `bsg_dff_macro(32,2)
-    else
-   `bsg_dff_macro(32,8)
-     else
-     begin: notmacro
-        reg [width_p-1:0] data_r;
-
-        assign data_o = data_r;
-
-        always @(posedge clk_i)
-          data_r <= data_i;
-     end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_dff)
diff --git a/hard/tsmc_28/bsg_misc/bsg_mux.v b/hard/tsmc_28/bsg_misc/bsg_mux.v
deleted file mode 100644
index 4fd89fc3..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_mux.v
+++ /dev/null
@@ -1,50 +0,0 @@
-`include "bsg_defines.v"
-
-module bsg_mux #(parameter `BSG_INV_PARAM(width_p)
-                 , els_p=1
-                 , harden_p = 0
-                 , balanced_p = 0
-                 , lg_els_lp=`BSG_SAFE_CLOG2(els_p)
-                 )
-   (
-    input [els_p-1:0][width_p-1:0] data_i
-    ,input [lg_els_lp-1:0] sel_i
-    ,output [width_p-1:0] data_o
-    );
-
-   genvar j;
-
-   if ((els_p == 4) && (harden_p == 1) && (balanced_p))
-     begin : fi
-        for (j = 0; j < width_p; j=j+1)
-          begin: rof
-             // fast, but not too extreme
-             MUX4D4BWP7T40P140LVT (.I0(data_i[0][j]), .I1(data_i[1][j]), .I2(data_i[2][j]), .I3(data_i[3][j]), .S0(sel_i[0]), .S1(sel_i[1]), .Z(data_o[j]));
-          end
-     end
-   else
-     begin : nofi
-
-        if (els_p == 1) begin
-          assign data_o = data_i;
-          wire unused = sel_i;
-        end
-        else begin
-          assign data_o = data_i[sel_i];
-        end
-
-
-        // synopsys translate_off
-        initial
-          assert(balanced_p == 0)
-            else $error("%m warning: synthesizable implementation of bsg_mux does not support balanced_p");
-       // synopsys translate_on
-     end
-
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_mux)
-
-
-
-
diff --git a/hard/tsmc_28/bsg_misc/bsg_nand.v b/hard/tsmc_28/bsg_misc/bsg_nand.v
deleted file mode 100644
index 97900616..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_nand.v
+++ /dev/null
@@ -1,60 +0,0 @@
-
-`define bsg_nand_macro(bits)                      \
-if (harden_p && (width_p==bits))                  \
-  begin: macro                                    \
-    for (genvar j = 0; j < width_p; j++)          \
-      begin : x                                   \
-        ND2D4BWP7T40P140 x (.A1(a_i[j]), .A2(b_i[j]), .ZN(o[j])); \
-      end                                                     \
-  end
-
-module bsg_nand #(parameter `BSG_INV_PARAM(width_p)
-                 , parameter harden_p=0
-                 )
-   (input    [width_p-1:0] a_i
-    , input  [width_p-1:0] b_i
-    , output [width_p-1:0] o
-    );
-
-   `bsg_nand_macro(34) else
-   `bsg_nand_macro(33) else
-   `bsg_nand_macro(32) else
-   `bsg_nand_macro(31) else
-   `bsg_nand_macro(30) else
-   `bsg_nand_macro(29) else
-   `bsg_nand_macro(28) else
-   `bsg_nand_macro(27) else
-   `bsg_nand_macro(26) else
-   `bsg_nand_macro(25) else
-   `bsg_nand_macro(24) else
-   `bsg_nand_macro(23) else
-   `bsg_nand_macro(22) else
-   `bsg_nand_macro(21) else
-   `bsg_nand_macro(20) else
-   `bsg_nand_macro(19) else
-   `bsg_nand_macro(18) else
-   `bsg_nand_macro(17) else
-   `bsg_nand_macro(16) else
-   `bsg_nand_macro(15) else
-   `bsg_nand_macro(14) else
-   `bsg_nand_macro(13) else
-   `bsg_nand_macro(12) else
-   `bsg_nand_macro(11) else
-   `bsg_nand_macro(10) else
-   `bsg_nand_macro(9) else
-   `bsg_nand_macro(8) else
-   `bsg_nand_macro(7) else
-   `bsg_nand_macro(6) else
-   `bsg_nand_macro(5) else
-   `bsg_nand_macro(4) else
-   `bsg_nand_macro(3) else
-   `bsg_nand_macro(2) else
-   `bsg_nand_macro(1) else
-       begin :notmacro
-          initial assert(harden_p==0) else $error("## %m wanted to harden but no macro");
-
-          assign o = ~(a_i & b_i);
-      end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_nand)
diff --git a/hard/tsmc_28/bsg_misc/bsg_nor3.v b/hard/tsmc_28/bsg_misc/bsg_nor3.v
deleted file mode 100644
index 13a1aed6..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_nor3.v
+++ /dev/null
@@ -1,61 +0,0 @@
-
-`define bsg_nor3_macro(bits)                      \
-if (harden_p && (width_p==bits))                  \
-  begin: macro                                    \
-    for (genvar j = 0; j < width_p; j++)          \
-      begin : x                                   \
-        NR3D4BWP7T40P140 x (.A1(a_i[j]), .A2(b_i[j]), .A3(c_i[j]), .ZN(o[j])); \
-      end                                                     \
-  end
-
-module bsg_nor3 #(parameter `BSG_INV_PARAM(width_p)
-                 , parameter harden_p=0
-                 )
-   (input    [width_p-1:0] a_i
-    , input  [width_p-1:0] b_i
-    , input  [width_p-1:0] c_i
-    , output [width_p-1:0] o
-    );
-
-   `bsg_nor3_macro(34) else
-   `bsg_nor3_macro(33) else
-   `bsg_nor3_macro(32) else
-   `bsg_nor3_macro(31) else
-   `bsg_nor3_macro(30) else
-   `bsg_nor3_macro(29) else
-   `bsg_nor3_macro(28) else
-   `bsg_nor3_macro(27) else
-   `bsg_nor3_macro(26) else
-   `bsg_nor3_macro(25) else
-   `bsg_nor3_macro(24) else
-   `bsg_nor3_macro(23) else
-   `bsg_nor3_macro(22) else
-   `bsg_nor3_macro(21) else
-   `bsg_nor3_macro(20) else
-   `bsg_nor3_macro(19) else
-   `bsg_nor3_macro(18) else
-   `bsg_nor3_macro(17) else
-   `bsg_nor3_macro(16) else
-   `bsg_nor3_macro(15) else
-   `bsg_nor3_macro(14) else
-   `bsg_nor3_macro(13) else
-   `bsg_nor3_macro(12) else
-   `bsg_nor3_macro(11) else
-   `bsg_nor3_macro(10) else
-   `bsg_nor3_macro(9) else
-   `bsg_nor3_macro(8) else
-   `bsg_nor3_macro(7) else
-   `bsg_nor3_macro(6) else
-   `bsg_nor3_macro(5) else
-   `bsg_nor3_macro(4) else
-   `bsg_nor3_macro(3) else
-   `bsg_nor3_macro(2) else
-   `bsg_nor3_macro(1) else
-       begin :notmacro
-          initial assert(harden_p==0) else $error("## %m wanted to harden but no macro");
-
-          assign o = ~(a_i | b_i | c_i);
-      end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_nor3)
diff --git a/hard/tsmc_28/bsg_misc/bsg_xnor.v b/hard/tsmc_28/bsg_misc/bsg_xnor.v
deleted file mode 100644
index 360cf55b..00000000
--- a/hard/tsmc_28/bsg_misc/bsg_xnor.v
+++ /dev/null
@@ -1,60 +0,0 @@
-
-`define bsg_xnor_macro(bits)                      \
-if (harden_p && (width_p==bits))                  \
-  begin: macro                                    \
-    for (genvar j = 0; j < width_p; j++)          \
-      begin : x                                   \
-        XNR2D4BWP7T40P140 x (.A1(a_i[j]), .A2(b_i[j]), .ZN(o[j])); \
-      end                                                     \
-  end
-
-module bsg_xnor #(parameter `BSG_INV_PARAM(width_p)
-                 , parameter harden_p=0
-                 )
-   (input    [width_p-1:0] a_i
-    , input  [width_p-1:0] b_i
-    , output [width_p-1:0] o
-    );
-
-   `bsg_xnor_macro(34) else
-   `bsg_xnor_macro(33) else
-   `bsg_xnor_macro(32) else
-   `bsg_xnor_macro(31) else
-   `bsg_xnor_macro(30) else
-   `bsg_xnor_macro(29) else
-   `bsg_xnor_macro(28) else
-   `bsg_xnor_macro(27) else
-   `bsg_xnor_macro(26) else
-   `bsg_xnor_macro(25) else
-   `bsg_xnor_macro(24) else
-   `bsg_xnor_macro(23) else
-   `bsg_xnor_macro(22) else
-   `bsg_xnor_macro(21) else
-   `bsg_xnor_macro(20) else
-   `bsg_xnor_macro(19) else
-   `bsg_xnor_macro(18) else
-   `bsg_xnor_macro(17) else
-   `bsg_xnor_macro(16) else
-   `bsg_xnor_macro(15) else
-   `bsg_xnor_macro(14) else
-   `bsg_xnor_macro(13) else
-   `bsg_xnor_macro(12) else
-   `bsg_xnor_macro(11) else
-   `bsg_xnor_macro(10) else
-   `bsg_xnor_macro(9) else
-   `bsg_xnor_macro(8) else
-   `bsg_xnor_macro(7) else
-   `bsg_xnor_macro(6) else
-   `bsg_xnor_macro(5) else
-   `bsg_xnor_macro(4) else
-   `bsg_xnor_macro(3) else
-   `bsg_xnor_macro(2) else
-   `bsg_xnor_macro(1) else
-       begin :notmacro
-          initial assert(harden_p==0) else $error("## %m wanted to harden but no macro");
-
-          assign o = ~(a_i ^ b_i);
-      end
-endmodule
-
-`BSG_ABSTRACT_MODULE(bsg_xnor)
diff --git a/testing/bsg_cache/common/bsg_nonsynth_random_yumi_gen.v b/testing/bsg_cache/common/bsg_nonsynth_random_yumi_gen.v
index 99b6869f..8d7cec31 100644
--- a/testing/bsg_cache/common/bsg_nonsynth_random_yumi_gen.v
+++ b/testing/bsg_cache/common/bsg_nonsynth_random_yumi_gen.v
@@ -15,16 +15,14 @@ module bsg_nonsynth_random_yumi_gen
   
   always_ff @ (posedge clk_i) begin
     if (reset_i) begin
-      yumi_count_r <= $urandom() % (yumi_max_delay_p-yumi_min_delay_p) + yumi_min_delay_p;
+      yumi_count_r <= $urandom_range(yumi_max_delay_p,yumi_min_delay_p);
     end
     else begin
       if (v_i) begin
-        if (yumi_count_r <= 0) begin
-          yumi_count_r <= $urandom() % (yumi_max_delay_p-yumi_min_delay_p) + yumi_min_delay_p;
-        end
-        else begin
+        if (yumi_count_r == 0)
+          yumi_count_r <= $urandom_range(yumi_max_delay_p,yumi_min_delay_p);
+        else
           yumi_count_r <= yumi_count_r - 1;
-        end
       end
     end
   end
diff --git a/testing/bsg_dmc/.gitignore b/testing/bsg_dmc/.gitignore
deleted file mode 100644
index 8f17649c..00000000
--- a/testing/bsg_dmc/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-elaborate
-run
-vc_hdrs.h
-bsg_dmc_trace_rom.tr
-bsg_dmc_trace_rom.v
-bsg_tag_boot_rom.v
diff --git a/testing/bsg_dmc/Makefile b/testing/bsg_dmc/Makefile
index d954644b..77cb3f5d 100644
--- a/testing/bsg_dmc/Makefile
+++ b/testing/bsg_dmc/Makefile
@@ -1,59 +1,40 @@
 include ../../../bsg_cadenv/cadenv.mk
 
+ANALYSIS_OPTIONS = -full64
+ANALYSIS_OPTIONS += -sverilog
+ANALYSIS_OPTIONS += +incdir+../../bsg_clk_gen
+ANALYSIS_OPTIONS += +incdir+../../bsg_misc
 
 ELABORATE_OPTIONS = -full64
-ELABORATE_OPTIONS += -sverilog
-ELABORATE_OPTIONS += +incdir+../../bsg_clk_gen
-ELABORATE_OPTIONS += +incdir+../../bsg_misc
-ELABORATE_OPTIONS += +incdir+../../bsg_tag
-ELABORATE_OPTIONS += +incdir+../../bsg_dmc
-ELABORATE_OPTIONS += +incdir+lpddr_verilog_model
 ELABORATE_OPTIONS += -debug_pp
-ELABORATE_OPTIONS += -sverilog
 ELABORATE_OPTIONS += -lca
 ELABORATE_OPTIONS += +vcs+vcdpluson
 ELABORATE_OPTIONS += +vcs+vcdplusmemon
-ELABORATE_OPTIONS += +define+den2048Mb+sg5+x16+FULL_MEM
-ELABORATE_OPTIONS += +define+BSG_OSC_BASE_DELAY=500
-ELABORATE_OPTIONS += +define+BSG_OSC_GRANULARITY=100
-ELABORATE_OPTIONS += -timescale=1ps/1ps
-ELABORATE_OPTIONS += -assert svaext
-#Enable below line for using non-synthesisable UVM TB
-ELABORATE_OPTIONS += +define+NONSYNTH_TB
-ELABORATE_OPTIONS += +lint=TFIPC-L
 
-RUN_OPTIONS =
-#RUN_OPTIONS += +irritate_clk
+RUN_OPTIONS = 
 
-BSG_TRACE_FILES := bsg_dmc_trace_rom.tr bsg_tag_boot_rom.tr
-BSG_TRACE_ROMS  := ${BSG_TRACE_FILES:.tr=_rom.v}
-
-bsg_dmc_trace_rom.tr:
-	python bsg_dmc_trace_rom.py 0 > $@
-
-%.v: %.tr
-	../../bsg_mem/bsg_ascii_to_rom.py $< $* > $@
+analyze:
+	$(VCS_BIN)/vlogan $(ANALYSIS_OPTIONS) -timescale=1ns/1ps +incdir+lpddr_verilog_model+../../bsg_dmc +define+den2048Mb+sg5+x16+FULL_MEM -f filelist.lst -l $@.log
+	touch $@
 
-elaborate: bsg_dmc_trace_rom.v bsg_tag_boot_rom.v
-	$(VCS_BIN)/vcs $(ELABORATE_OPTIONS) -l $@.log -f filelist.lst
+elaborate: analyze
+	$(VCS_BIN)/vcs $(ELABORATE_OPTIONS) -l $@.log testbench
 	touch $@
 
 run: elaborate
-	./simv $(RUN_OPTIONS)  -l $@.log
+	./simv $(RUN_OPTIONS) -l $@.log
 	touch $@
 
-dve: 
+dve: run
 	$(VCS_BIN)/dve -full64 -vpd vcdplus.vpd &
 
 clean:
-	rm -rf elaborate run
+	rm analyze elaborate run
 	rm -rf *.log
-	rm -rf bsg_dmc_trace_rom.tr
-	rm -rf *_rom.v
+	rm -rf analyze_*
 	rm -rf *.vpd
-	rm -rf vc_hdrs.h
 	rm -rf simv*
 	rm -rf csrc
 	rm -rf ucli.key
-	#rm -rf DVEfiles
+	rm -rf DVEfiles
 	rm -rf AN.DB
diff --git a/testing/bsg_dmc/bsg_dmc_tester.v b/testing/bsg_dmc/bsg_dmc_tester.v
deleted file mode 100644
index d15b9853..00000000
--- a/testing/bsg_dmc/bsg_dmc_tester.v
+++ /dev/null
@@ -1,146 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////////////////////////
-//    		BASEJUMP STL
-//
-//       MODULE: bsg_dmc_tester
-//  DESCRIPTION: Synthesisable ester design for bringing up on-chip DRAM controller
-//    AUTHOR(S): Akash Suresh, akashs3@uw.edu
-// ORGANIZATION: Bespoke Silicon Group, University of Washington
-//      CREATED: 01/04/22
-///////////////////////////////////////////////////////////////////////////////////////////////////
-
-`include "bsg_defines.v"
-`include "bsg_dmc.vh"
-
-module bsg_dmc_tester
-	  	import bsg_dmc_pkg::*;
-		#(	parameter data_width_p=32,
-		  	parameter addr_width_p = 28,
-			parameter burst_width_p = 2,
-
-  			localparam mask_width_lp   = data_width_p >> 3,
-			localparam rom_addr_width_lp=32,
-			localparam data_mask_width_lp = data_width_p>>3,
-			localparam payload_width_lp = `bsg_dmc_trace_entry_width(data_width_p, addr_width_p)
-		 )
-		(	input 							fpga_link_clk_i,
-			input 							fpga_link_io_clk_i,
-			input 							fpga_link_reset_i,
-			input 							fpga_link_upstream_io_reset_i,
-			input							fpga_link_downstream_io_reset_i,
-			input 							fpga_link_token_reset_i,
-
-			input							en_trace_reading_i,
-
-			output							fpga_link_upstream_edge_clk_o,
-			input							asic_link_downstream_edge_token_i,
-			output [payload_width_lp/2-1:0] fpga_link_upstream_edge_data_o,
-			output 							fpga_link_upstream_edge_valid_o,
-
-			input 							asic_link_upstream_edge_clk_i,
-			input [payload_width_lp/2-1:0]	asic_link_upstream_edge_data_i,
-			input							asic_link_upstream_edge_valid_i,
-			output							fpga_link_downstream_edge_token_o,
-            output                          trace_reading_done_o
-
-		);
-
-
-  
-  	//  trace replay
-  	//
-  	//  send trace: {opcode(5), addr, data}
-  	//  recv trace: {filler(5+32), data}
-  	logic trace_valid_lo;
-  	logic [payload_width_lp-1:0] trace_data_lo;
-  	logic trace_yumi_li;
-
-  	logic [rom_addr_width_lp-1:0] trace_rom_addr_lo;
-  	logic [payload_width_lp +4 - 1:0] trace_rom_data_lo;
-
-	logic [payload_width_lp - 1: 0] read_data_to_trace_replay;
-	logic read_data_to_trace_replay_valid;
-	logic trace_replay_ready_to_read;
-
-	// FPGA SIDE LINK EDGE SIGNALS
-	logic fpga_link_upstream_edge_token;
-	logic fpga_link_upstream_edge_clk;
-	logic fpga_link_upstream_core_ready_lo;
-
-	bsg_trace_replay
-  					#(  .payload_width_p(payload_width_lp)
-  					  	,.rom_addr_width_p(rom_addr_width_lp)
-                        ,.debug_p(2)
-  					) trace_replay
-    				(.clk_i(fpga_link_clk_i),
-    				.reset_i(fpga_link_reset_i),
-    				.en_i(en_trace_reading_i),
-
-    				.v_i(read_data_to_trace_replay_valid),
-    				.data_i(read_data_to_trace_replay),
-    				.ready_o(trace_replay_ready_to_read),
-
-    				.v_o(trace_valid_lo),
-    				.data_o(trace_data_lo),
-    				.yumi_i(trace_yumi_li),
-
-    				.rom_addr_o(trace_rom_addr_lo),
-    				.rom_data_i(trace_rom_data_lo),
-
-    				.done_o(trace_reading_done_o),
-    				.error_o()
-  					);
-
-    bsg_dmc_trace_rom 
-					#( .addr_width_p(rom_addr_width_lp)
-    				  ,.width_p(payload_width_lp+4)
-    				) trace_rom (
-    				  .addr_i(trace_rom_addr_lo)
-    				  ,.data_o(trace_rom_data_lo)
-    				);
-
-	assign trace_yumi_li = fpga_link_upstream_core_ready_lo ;
-	assign fpga_link_upstream_edge_clk_o = fpga_link_upstream_edge_clk;
-
-	// FPGA SIDE LINKS START
-	bsg_link_ddr_upstream
- 					#(.width_p        (payload_width_lp)
- 					 ,.channel_width_p(payload_width_lp/2)
- 					 ,.num_channels_p (1)
- 					 ) fpga_link_upstream
- 					 (.core_clk_i         (fpga_link_clk_i)
- 					 ,.io_clk_i           (fpga_link_io_clk_i)
- 					 ,.core_link_reset_i  (fpga_link_reset_i)
- 					 ,.io_link_reset_i    (fpga_link_upstream_io_reset_i)
- 					 ,.async_token_reset_i(fpga_link_token_reset_i)
- 					 
- 					 ,.core_data_i (trace_data_lo)
- 					 ,.core_valid_i(trace_valid_lo)
- 					 ,.core_ready_o(fpga_link_upstream_core_ready_lo)
-
- 					 ,.io_clk_r_o  (fpga_link_upstream_edge_clk)
- 					 ,.io_data_r_o (fpga_link_upstream_edge_data_o)
- 					 ,.io_valid_r_o(fpga_link_upstream_edge_valid_o)
- 					 ,.token_clk_i (asic_link_downstream_edge_token_i)
- 					 );
-
-	bsg_link_ddr_downstream
-  					#(.width_p        (payload_width_lp)
-  					 ,.channel_width_p(payload_width_lp/2)
-  					 ,.num_channels_p (1)
-  					 ) fpga_link_downstream
-  					 (.core_clk_i       (fpga_link_clk_i)
-  					 ,.core_link_reset_i(fpga_link_reset_i)
-  					 ,.io_link_reset_i  (fpga_link_downstream_io_reset_i)
-  					 
-  					 ,.core_data_o   (read_data_to_trace_replay)
-  					 ,.core_valid_o  (read_data_to_trace_replay_valid)
-  					 ,.core_yumi_i   (read_data_to_trace_replay_valid)
-  					
-  					 ,.io_clk_i      (asic_link_upstream_edge_clk_i)
-  					 ,.io_data_i     (asic_link_upstream_edge_data_i)
-  					 ,.io_valid_i    (asic_link_upstream_edge_valid_i)
-  					 ,.core_token_r_o(fpga_link_downstream_edge_token_o)
-  					 );
-	// FPGA SIDE LINKS END
-	
-endmodule 
diff --git a/testing/bsg_dmc/bsg_dmc_trace_rom.py b/testing/bsg_dmc/bsg_dmc_trace_rom.py
deleted file mode 100644
index 26ba859b..00000000
--- a/testing/bsg_dmc/bsg_dmc_trace_rom.py
+++ /dev/null
@@ -1,169 +0,0 @@
-import sys
-import random
-import time
-import re
-
-# Script adapted from testing/bsg_cache/dmc/bsg_trace_rom.py
-class TraceGen:
-  def __init__(self, addr_width_p, data_width_p, cmd_width_p, burst_length_p):
-    self.addr_width_p = addr_width_p
-    self.data_width_p = data_width_p
-    self.cmd_width_p = cmd_width_p
-    self.burst_length_p = burst_length_p
-    self.mask_width_lp = data_width_p/8
-    self.zero_padding_width_lp = data_width_p + self.mask_width_lp - addr_width_p;
-
-  def send_read(self, addr):
-    trace = "0001_"
-    precharge = random.randint(0,1)
-    trace += "00"  + format(precharge, str(1)+"b") + "1_" + (self.zero_padding_width_lp)*"0" + "_"
-    trace += format(addr, "0"+str(self.addr_width_p)+"b") 
-    #+ "_"
-    self.print_trace(trace)
-
-
-  def send_write(self, addr, data, mask):
-    trace = "0001_"
-    precharge = random.randint(0,1)
-    #command and address
-    trace += "00" + format(precharge, str(1)+"b") + "0_" + (self.zero_padding_width_lp)*"0" + "_"
-    trace += format(addr, "0"+str(self.addr_width_p)+"b")
-    #+ "_"
-    self.print_trace(trace)
-
-    # Burst
-    for i in range(self.burst_length_p-1):
-        #tag replay: send
-        trace_wdata = "0001_"
-        trace_wdata += "1001_"
-        trace_wdata += format(mask, "0"+str(self.mask_width_lp)+"b") 
-        trace_wdata += format(data, "0"+str(self.data_width_p)+"b") + "_"
-        self.print_trace(trace_wdata)
-
-    # Burst termination
-    trace_wdata = "0001_"
-    trace_wdata += "1010_"
-    trace_wdata += format(mask, "0"+str(self.mask_width_lp)+"b") 
-    trace_wdata += format(data, "0"+str(self.data_width_p)+"b") + "_"
-    self.print_trace(trace_wdata)
-
-    #for i in range(self.burst_length_p):
-    #    trace += format(mask, "0"+str(self.mask_width_lp)+"b") + "_"        
-
-  def send_nop(self):
-    trace = "0001_"
-    trace += "1111_"
-    trace += (self.mask_width_lp)*"0" + "_"
-    trace += format(0, "0"+str(self.data_width_p)+"b")
-    self.print_trace(trace)
-
-  def send_exe(self):
-    trace = "0001_"
-    trace += "1000_"
-    trace += (self.mask_width_lp)*"0" + "_"
-    trace += format(0, "0"+str(self.data_width_p)+"b")
-    self.print_trace(trace)
-
-  def recv_data(self, data):
-
-    for i in range(self.burst_length_p):
-        trace = "0010_"
-        trace += "0000_"
-        trace += (self.mask_width_lp)*"0" + "_"
-        trace += format(data, "0"+str(self.data_width_p)+"b")
-        self.print_trace(trace)
-
-    #for i in range(self.burst_length_p):
-    #    trace += format(data, "0"+str(self.data_width_p)+"b") + "_"
-
-    #for i in range(self.burst_length_p):
-    #    trace += (self.mask_width_lp)*"0" + "_"        
-
-  def test_done(self):
-    print("#### DONE ####")
-    trace = "0011_"
-    trace += "1111_"    
-    trace += (self.data_width_p + self.mask_width_lp)*"0"
-    self.print_trace(trace)
-
-  def nop(self):
-    trace = "0000_"
-    trace += "1111_"    
-    trace += (self.data_width_p + self.mask_width_lp)*"0" 
-    self.print_trace(trace)
-
-  def wait(self, num_cycle):
-    trace = "0110_"
-    trace += "1111_"    
-    trace += format(num_cycle, "0"+str(self.data_width_p + self.mask_width_lp)+"b")
-    self.print_trace(trace)
-    trace = "0101_"
-    trace += "1111_"        
-    trace += (self.data_width_p + self.mask_width_lp)*"0" 
-    self.print_trace(trace)
-
-  def print_trace(self, data):
-      new_data = re.sub(r'_$', '', data)
-      print(new_data)
-
-if __name__ == "__main__":
-  tg = TraceGen(addr_width_p=28, data_width_p=32, cmd_width_p=4, burst_length_p = 8 )
-  id_p = int(sys.argv[1])
-  random.seed(time.time())
-
-  mem_dict = {}
-  write_val = id_p 
-
-  tg.wait(1000)
-
-  for i in range(10):
-    addr = (random.randint(0, 2**22) << 6)
-    delay = random.randint(0,10)
-
-
-    mask_val = 0
-    #mask_val = random.randint(0, 2^(tg.mask_width_lp))
-
-    if delay == 0:
-      pass
-    elif delay == 1:
-      tg.nop()
-    else:
-      tg.wait(delay)
-
-    if addr in mem_dict:
-      write_not_read = random.randint(0,1)
-      if write_not_read == 0:
-        tg.send_read(addr)
-        tg.send_exe()
-        tg.recv_data(mem_dict[addr])
-      else:
-        tg.send_write(addr, write_val, mask_val)
-        tg.send_exe()
-        #tg.recv_data(0)
-        mem_dict[addr] = write_val
-        write_val += 4
-    else:
-      tg.send_write(addr, write_val, mask_val)
-      tg.send_exe()
-      #tg.recv_data(0)
-      mem_dict[addr] = write_val
-      write_val += 4
-
-  #tg.wait(500)
-
-  # read back everything
-  for tu in mem_dict.items():
-    delay = random.randint(0,32)
-
-    if delay == 0:
-      pass
-    elif delay == 1:
-      tg.nop()
-    else:
-      tg.wait(delay)
-
-    tg.send_read(tu[0])
-    tg.send_exe()
-    tg.recv_data(tu[1])  
-  tg.test_done()
diff --git a/testing/bsg_dmc/bsg_nonsynth_dmc_clock_monitor.v b/testing/bsg_dmc/bsg_nonsynth_dmc_clock_monitor.v
deleted file mode 100644
index a11a61bd..00000000
--- a/testing/bsg_dmc/bsg_nonsynth_dmc_clock_monitor.v
+++ /dev/null
@@ -1,136 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////////////////////////
-//    		BASEJUMP STL
-//
-//       MODULE: bsg_nonsynth_dmc_clock_monitor
-//  DESCRIPTION: Monitors DDR clock frequency with respect to the FPGA clock frequency.
-//    AUTHOR(S): Akash Suresh, akashs3@uw.edu
-// ORGANIZATION: Bespoke Silicon Group, University of Washington
-//      CREATED: 01/23/22
-///////////////////////////////////////////////////////////////////////////////////////////////////
-module bsg_nonsynth_dmc_clock_monitor
-				#(  parameter counter_width_p = 1024
-					,parameter sampling_period_ns_p = 100
-					,`BSG_INV_PARAM(max_fpga_count)
-					,`BSG_INV_PARAM(expected_ddr_period_ns_p)
-					,`BSG_INV_PARAM(fpga_clk_period_ns_p)
-				)
-			   		//parameter period_tolerance_p = 0	)
-				(input fpga_clk,
-				 input fpga_reset,
-				 input ddr_clk_i,
-				 output logic frequency_mismatch_o
-				);
-
-	logic [$clog2(counter_width_p) - 1 : 0] fpga_counter_lo;
-	bit fpga_counter_clear_li, ddr_counter_clear_li, tally_freq;
-	logic [$clog2(counter_width_p) - 1 : 0] ddr_clock_gray_count_lo;
-	logic [$clog2(counter_width_p) - 1 : 0] ddr_clock_binary_count_lo, prev_ddr_binary_count;
-
-	logic reset_async_gray_counter;
-
-	real ddr_count_start_time, ddr_cycle_time, fpga_count_start_time, fpga_cycle_time ;
-
-	// counter to clock 100 ns on fpga clock
-	bsg_counter_clear_up 
-				#(.max_val_p(counter_width_p-1),
-				  .init_val_p(0))
-				fpga_clock_counter
-				(.clk_i(fpga_clk),
-				 .reset_i(fpga_reset),
-				 .clear_i(fpga_counter_clear_li),
-				 .up_i(1'b1),
-				 .count_o(fpga_counter_lo)
-				);
-
-	// gray counter to count ddr clock ticks and read it in the fpga clock domain
-	logic async_ptr_increment;
-
-	bsg_async_ptr_gray
-				#(.lg_size_p($clog2(counter_width_p)))
-				ddr_clk_async_gray_counter
-			    (.w_clk_i(ddr_clk_i),
-				 .w_reset_i(fpga_counter_clear_li | fpga_reset),
-				 .w_inc_i(1'b1),
-				 .r_clk_i(fpga_clk),
-                 .w_ptr_binary_r_o(),
-                 .w_ptr_gray_r_o(),
-				 .w_ptr_gray_r_rsync_o(ddr_clock_gray_count_lo)
-				);
-
-	// convert gray counter value received above to binary for correlating with fpga clock ticks and finding the time period
-	bsg_gray_to_binary
-				#(.width_p($clog2(counter_width_p)))
-				ddr_clock_tick_gray_to_binary
-				(.gray_i(ddr_clock_gray_count_lo),
-				 .binary_o(ddr_clock_binary_count_lo)
-				);
-	
-	// non-synthesisable for now
-	always_comb begin
-		frequency_mismatch_o = 0;
-		if(ddr_clock_binary_count_lo == 0) begin
-			ddr_cycle_time = $realtime - ddr_count_start_time;			
-			ddr_count_start_time = $time;
-
-			//$display("fpga time: %d ddr time: %d previous binary count: %d",fpga_cycle_time , ddr_cycle_time, prev_ddr_binary_count);
-			if(prev_ddr_binary_count >= ((max_fpga_count-1)*fpga_clk_period_ns_p/expected_ddr_period_ns_p)) begin
-				//$display("success");
-				frequency_mismatch_o = 1;
-			end
-
-		end
-		prev_ddr_binary_count = ddr_clock_binary_count_lo;
-		if((ddr_clock_binary_count_lo >= ((max_fpga_count )*fpga_clk_period_ns_p/expected_ddr_period_ns_p)) && (!ddr_counter_clear_li) ) begin
-			ddr_counter_clear_li = 1;
-		end
-		else begin
-			ddr_counter_clear_li = 0;
-		end
-	end
-
-	always_comb begin
-		if(fpga_counter_lo == 1) begin
-			fpga_cycle_time = $realtime - fpga_count_start_time;																
-			fpga_count_start_time = $realtime;
-		end
-		if(fpga_counter_lo >= max_fpga_count ) begin
-			fpga_counter_clear_li = 1;
-		end
-		else begin
-			fpga_counter_clear_li = 0;
-		end
-	end
-	
-endmodule
-
-module ddr_clock_monitor_tb;
-
-	logic fpga_clk;
-	logic fpga_reset;
-	logic ddr_clk;
-	logic frequency_mismatch;
-
-	bsg_nonsynth_dmc_clock_monitor
-   					#(.max_fpga_count(20)
-					  ,.expected_ddr_period_ns_p(2.5)
-					  ,.fpga_clk_period_ns_p(5)
-					)	
-					ddr_clock_mon
-					(	.fpga_clk(fpga_clk)
-						,.fpga_reset(fpga_reset)
-						,.ddr_clk_i(ddr_clk)
-						,.frequency_mismatch_o(frequency_mismatch)
-					);
-
-	initial begin
-		fpga_clk = 0;
-		ddr_clk = 0;
-		fpga_reset = 1;
-		#100;
-		fpga_reset = 0;
-	end
-
-	always #2.5ns fpga_clk = ~fpga_clk;
-	always #1.25ns ddr_clk = ~ddr_clk;
-
-endmodule
diff --git a/testing/bsg_dmc/bsg_tag_boot_rom.tr b/testing/bsg_dmc/bsg_tag_boot_rom.tr
deleted file mode 100644
index 3fed4ed2..00000000
--- a/testing/bsg_dmc/bsg_tag_boot_rom.tr
+++ /dev/null
@@ -1,280 +0,0 @@
-# PRO-TIP: Set editior syntax to bash (or sh)
-
-################################################################################
-# DESIGN SPECIFIC TAG INFO
-#
-# Number | Description                       | Width
-# -------+-----------------------------------+-------
-#     0  | Delay Line Async Reset            | 1-bit
-#   4-1  | Delay Line Ctrl Bits              | 8-bits
-#   8-5  | Delay Line Trigger                | 1-bit
-#   9-7  | 2x-to-1x Clock Downsampler Reset  | 3-bit
-# 11-10  | DMC trefi                         | 8-bits
-#    12  | DMC tmrd trfc                     | 8-bits
-#    13  | DMC trc trp                       | 8-bits
-#    14  | DMC tras trrd                     | 8-bits
-#    15  | DMC trcd twr                      | 8-bits
-#    16  | DMC twtr trtp                     | 8-bits
-#    17  | DMC dqs_sel_cal tcas              | 8-bits
-#    18  | DMC row col width                 | 8-bits
-#    19  | DMC bank position width           | 8-bits
-# 21-20  | DMC initialization cycles         | 8-bits
-#    22  | DMC Async Reset                   | 1-bit
-#    23  | DMC stall_transactions            | 1-bit
-#    24  | DMC test_mode                     | 1-bit
-#    25  | Clkgen Async Reset                | 1-bit
-#    26  | Clkgen Oscillator                 | 5-bits
-#    27  | Clkgen Osc Trigger                | 1-bit
-#    28  | Clkgen Downsampler                | 2-bits
-#    29  | Clkgen Select                     | 2 bits
-#
-#
-# Number of masters = 1
-# Number of clients = 29
-# Max data width = 8
-#
-# Packet lengths
-# <4b>___<1b>___<5b>_1b_<4b>___<8b>
-# <4b>___<19b>
-#
-# There is one tagmaster driving 29 clients in the traffic_generator. The 1 bit
-# masterEn indicates whether the tag master is selected or not.
-#
-
-################################################################################
-# Tag Trace Replay Packet Format
-#
-# M = number of masters
-# N = max(1, clog2(#_of_tag_clients))
-# D = max(client_1_width, client_2_width, ..., client_n_width)
-# L = clog2(D+1)
-#
-# |<    4-bits    >|< M-bits >|< N-bits >|<     1-bit    >|< L-bits >|< D-bits >|
-# +----------------+----------+----------+----------------+----------+----------+
-# | replay command | masterEn |  nodeID  | data_not_reset |  length  |   data   |
-# +----------------+----------+----------+----------------+----------+----------+
-#
-# Replay Commands
-#   0 = 0000 = Wait a cycle
-#   1 = 0001 = Send data
-#   2 = 0010 = Receive data
-#   3 = 0011 = Assert done_o ouput signal
-#   4 = 0100 = End test (calls $finish)
-#   5 = 0101 = Wait for cycle_counter == 0
-#   6 = 0110 = Initialize cycle_counter with a 16 bit number
-
-################################################################################
-#
-# RESET BSG TAG MASTER
-#
-# First, we must reset the bsg_tag_master. To do this, we send a 1, then we
-# send a bunch of 0's! By a bunch, the exact amount is (2^clog2(N+1+L+D))+1
-
-# Send a full 0 packet to all masters
-0001___1___00000_0_0000___00000000
-
-# Wait ~32 cycles
-0110___0000000000000100000
-0101___0000000000000000000
-
-################################################################################
-#
-# RESET BSG TAG CLIENTS
-#
-# Next, we should reset each client node. To do this we send a packet
-# that has all 1's for data, and has data_not_reset=0. The nodeID should
-# be the ID of the client we are reseting, and length should be the
-# corrent length of the packet. We should send this packet to each client.
-
-#SEND  en   id=0  r l=1
-0001___1___00000_0_0001___00000001
-#SEND  en   id=1  r l=5
-0001___1___00001_0_0101___00011111
-#SEND  en   id=2  r l=5
-0001___1___00010_0_0101___00011111
-#SEND  en   id=3  r l=5
-0001___1___00011_0_0101___00011111
-#SEND  en   id=4  r l=5
-0001___1___00100_0_0101___00011111
-#SEND  en   id=5  r l=1
-0001___1___00101_0_0001___00000001
-#SEND  en   id=6  r l=1
-0001___1___00110_0_0001___00000001
-#SEND  en   id=7  r l=1
-0001___1___00111_0_0001___00000001
-#SEND  en   id=8  r l=1
-0001___1___01000_0_0001___00000001
-#SEND  en   id=9  r l=3
-0001___1___01001_0_0011___00000111
-#SEND  en   id=10  r l=8
-0001___1___01010_0_1000___11111111
-#SEND  en   id=11  r l=8
-0001___1___01011_0_1000___11111111
-#SEND  en   id=12  r l=8
-0001___1___01100_0_1000___11111111
-#SEND  en   id=13  r l=8
-0001___1___01101_0_1000___11111111
-#SEND  en   id=14  r l=8
-0001___1___01110_0_1000___11111111
-#SEND  en   id=15  r l=8
-0001___1___01111_0_1000___11111111
-#SEND  en   id=16  r l=8
-0001___1___10000_0_1000___11111111
-#SEND  en   id=17  r l=7
-0001___1___10001_0_1000___01111111
-#SEND  en   id=18  r l=8
-0001___1___10010_0_1000___11111111
-#SEND  en   id=19  r l=8
-0001___1___10011_0_1000___11111111
-#SEND  en   id=20  r l=8
-0001___1___10100_0_1000___11111111
-#SEND  en   id=21  r l=8
-0001___1___10101_0_1000___11111111
-#SEND  en   id=22  r l=1
-0001___1___10110_0_0001___00000001
-#SEND  en   id=23  r l=1
-0001___1___10111_0_0001___00000001
-#SEND  en   id=24  r l=1
-0001___1___11000_0_0001___00000001
-#SEND  en   id=25  r l=1
-0001___1___11001_0_0001___00000001
-#SEND  en   id=26  r l=5
-0001___1___11010_0_0101___00011111
-#SEND  en   id=27  r l=1
-0001___1___11011_0_0001___00000001
-#SEND  en   id=28  r l=2
-0001___1___11100_0_0010___00000011
-#SEND  en   id=29  r l=2
-0001___1___11101_0_0010___00000011
-################################################################################
-#
-# START CONFIGURATION
-#
-# The bsg tag network is now live! We can begin our configuration.
-#    25  | Clkgen Async Reset                 | 1-bit
-#    26  | Clkgen Oscillator                  | 5-bits
-#    27  | Clkgen Osc Trigger                 | 1-bit
-#    28  | Clkgen Downsampler                 | 2-bits
-#    29  | Clkgen Select                      | 2-bits
-### Async clk-gen reset to get things moving
-
-#SEND  en   id=25   d l=1    {async_reset}
-0001___1___11001_1_0001___00000000
-0001___1___11001_1_0001___00000001
-0001___1___11001_1_0001___00000000
-
-### Set osc triggers low
-
-#SEND  en   id=27   d l=1    {trigger}
-0001___1___11011_1_0001___00000000
-
-### Program the raw oscillators speed
-
-#SEND  en   id=26   d l=5    {adt, cdt, fdt}
-0001___1___11010_1_0101___00011101
-
-### Trigger oscillators
-
-#SEND  en   id=27   d l=1    {trigger}
-0001___1___11011_1_0001___00000001
-0001___1___11011_1_0001___00000000
-
-#SEND  en   id=28   d l=3    {ds_val, reset}
-0001___1___11100_1_0011___00000001
-0001___1___11100_1_0011___00000000
-
-#SEND  en   id=29   d l=2    {sel}
-0001___1___11101_1_0010___00000001
-
-### Set delay line triggers low
-
-#SEND  en   id=5  d l=1    {trigger}
-0001___1___00101_1_0001___00000000
-#SEND  en   id=6  d l=1    {trigger}
-0001___1___00110_1_0001___00000000
-#SEND  en   id=7  d l=1    {trigger}
-0001___1___00111_1_0001___00000000
-#SEND  en   id=8  d l=1    {trigger}
-0001___1___01000_1_0001___00000000
-
-### Program the delay lines
-
-#SEND  en   id=1  d l=5    {adt, cdt, fdt}
-0001___1___00001_1_0101___00011101
-#SEND  en   id=2  d l=5    {adt, cdt, fdt}
-0001___1___00010_1_0101___00011101
-#SEND  en   id=3  d l=5    {adt, cdt, fdt}
-0001___1___00011_1_0101___00011101
-#SEND  en   id=4  d l=5    {adt, cdt, fdt}
-0001___1___00100_1_0101___00011101
-
-### Trigger delay lines
-
-#SEND  en   id=5  d l=1    {trigger}
-0001___1___00101_1_0001___00000001
-0001___1___00101_1_0001___00000000
-#SEND  en   id=6  d l=1    {trigger}
-0001___1___00110_1_0001___00000001
-0001___1___00110_1_0001___00000000
-#SEND  en   id=7  d l=1    {trigger}
-0001___1___00111_1_0001___00000001
-0001___1___00111_1_0001___00000000
-#SEND  en   id=8  d l=1    {trigger}
-0001___1___01000_1_0001___00000001
-0001___1___01000_1_0001___00000000
-
-### Async delay line reset to get things moving
-
-#SEND  en   id=0  d l=1    {async_reset}
-0001___1___00000_1_0001___00000000
-0001___1___00000_1_0001___00000001
-0001___1___00000_1_0001___00000000
-
-### Set downsamples and reset
-#
-#SEND  en   id=9  d l=3    {ds_val, reset}
-0001___1___01001_1_0011___00000001
-0001___1___01001_1_0011___00000000
-
-# Reset DMC configs and set dmc_p
-#SEND  en   id=10  d l=8    {trefi[7:0]}
-0001___1___01010_1_1000___11111111
-#SEND  en   id=11  d l=8    {trefi[15:8]}
-0001___1___01011_1_1000___00000011
-#SEND  en   id=12  d l=8    {trfc, tmrd}
-0001___1___01100_1_1000___11110001
-#SEND  en   id=13  d l=8    {trp, trc}
-0001___1___01101_1_1000___00111011
-#SEND  en   id=14  d l=8    {trrd, tras}
-0001___1___01110_1_1000___00101000
-#SEND  en   id=15  d l=8    {twr, trcd}
-0001___1___01111_1_1000___10110010
-#SEND  en   id=16  d l=8    {trtp, twtr}
-0001___1___10000_1_1000___10101001
-#SEND  en   id=17  d l=7    {dqs_sel_cal, cas}
-0001___1___10001_1_0111___00110011
-#SEND  en   id=18  d l=8    {row_width, col_width}
-0001___1___10010_1_1000___11101011
-#SEND  en   id=19  d l=8    {bank_pos, bank_width}
-0001___1___10011_1_1000___01100110
-#SEND  en   id=20  d l=8    {init_cycles[7:0]}
-0001___1___10100_1_1000___01001010
-#SEND  en   id=21  d l=8    {init_cycles[15:8]}
-0001___1___10101_1_1000___10011100
-#SEND  en   id=22  d l=1    {reset}
-0001___1___10110_1_0001___00000001
-0001___1___10110_1_0001___00000000
-
-# SEND en  id=23 d l=1     {stall_transactions}
-0001___1___10111_1_0001___00000000
-# SEND en  id=24 d l=1     {test_mode}
-0001___1___10111_1_0001___00000000
-################################################################################
-#
-# Done!
-#
-# Configuration is complete and we are out of reset. We should indicate we are
-# done to allow the next part of the testbench to come alive.
-
-# Assert done_o
-0011___0000000000000000000
diff --git a/testing/bsg_dmc/filelist.lst b/testing/bsg_dmc/filelist.lst
index f4c84d1b..7cc0ef68 100644
--- a/testing/bsg_dmc/filelist.lst
+++ b/testing/bsg_dmc/filelist.lst
@@ -1,25 +1,14 @@
-+incdir+../../bsg_misc
-+incdir+../../bsg_clk_gen
-+incdir+../../bsg_tag/
-+incdir+../../bsg_dmc/
-+incdir+../../bsg_link/
-+incdir+lpddr_verilog_model
-
 ../../bsg_misc/bsg_defines.v
-../../bsg_tag/bsg_tag_pkg.v
 ../../bsg_dmc/bsg_dmc_pkg.v
+../../bsg_tag/bsg_tag_pkg.v
 ../../bsg_async/bsg_async_fifo.v
 ../../bsg_async/bsg_async_ptr_gray.v
 ../../bsg_async/bsg_launch_sync_sync.v
 ../../bsg_async/bsg_sync_sync.v
 ../../bsg_clk_gen/bsg_dly_line.v
-../../bsg_clk_gen/bsg_clk_gen.v
-../../bsg_clk_gen/bsg_clk_gen_osc.v
 ../../bsg_dataflow/bsg_fifo_1r1w_small.v
 ../../bsg_dataflow/bsg_fifo_1r1w_small_unhardened.v
-../../bsg_dataflow/bsg_fifo_1r1w_small_credit_on_input.v
 ../../bsg_dataflow/bsg_fifo_tracker.v
-../../bsg_dataflow/bsg_flow_counter.v
 ../../bsg_dataflow/bsg_flatten_2D_array.v
 ../../bsg_dataflow/bsg_make_2D_array.v
 ../../bsg_dataflow/bsg_parallel_in_serial_out.v
@@ -30,13 +19,11 @@
 ../../bsg_dmc/bsg_dmc_clk_rst_gen.v
 ../../bsg_dmc/bsg_dmc_controller.v
 ../../bsg_dmc/bsg_dmc_phy.v
-../../bsg_fsb/bsg_fsb_node_trace_replay.v
 ../../bsg_mem/bsg_mem_1r1w.v
 ../../bsg_mem/bsg_mem_1r1w_synth.v
 ../../bsg_misc/bsg_buf.v
 ../../bsg_misc/bsg_circular_ptr.v
 ../../bsg_misc/bsg_counter_clock_downsample.v
-../../bsg_misc/bsg_counter_up_down.v
 ../../bsg_misc/bsg_dff.v
 ../../bsg_misc/bsg_dff_reset_en.v
 ../../bsg_misc/bsg_mux.v
@@ -50,33 +37,7 @@
 ../../bsg_misc/bsg_counter_clear_up.v
 ../../bsg_misc/bsg_dff_reset.v
 ../../bsg_misc/bsg_dff_en.v
-../../bsg_tag/bsg_tag_master.v
 ../../bsg_tag/bsg_tag_client.v
 ../../bsg_tag/bsg_tag_client_unsync.v
-../../bsg_tag/bsg_tag_trace_replay.v
-../../bsg_test/bsg_nonsynth_clock_gen.v
-../../bsg_test/bsg_nonsynth_reset_gen.v
-../../bsg_test/bsg_trace_replay.v
-../../bsg_link/bsg_link_ddr_downstream.v
-../../bsg_link/bsg_link_ddr_upstream.v
-../../bsg_link/bsg_link_source_sync_upstream.v
-../../bsg_link/bsg_link_oddr_phy.v
-../../bsg_async/bsg_async_credit_counter.v
-../../bsg_misc/bsg_gray_to_binary.v
-../../bsg_misc/bsg_scan.v
-../../bsg_link/bsg_link_iddr_phy.v
-../../bsg_link/bsg_link_source_sync_downstream.v
-../../bsg_dataflow/bsg_serial_in_parallel_out_full.v
-../../bsg_dataflow/bsg_round_robin_1_to_n.v
-
-bsg_dmc_trace_rom.v
-../../bsg_dmc/bsg_dmc_xilinx_ui_trace_replay.v
-#bsg_dmc_tester.v
-../../bsg_dmc/bsg_dmc_sys_cfg_gen.v
-
-bsg_tag_boot_rom.v
-traffic_generator.v
-bsg_nonsynth_dmc_clock_monitor.v
-testbench.v
-
 lpddr_verilog_model/mobile_ddr.v
+testbench.v
diff --git a/testing/bsg_dmc/tasks.v b/testing/bsg_dmc/tasks.v
index 81a5a7ba..5723f58c 100644
--- a/testing/bsg_dmc/tasks.v
+++ b/testing/bsg_dmc/tasks.v
@@ -1,13 +1,13 @@
 task ui_write;
-  input [ui_mask_width_lp*ui_burst_length_lp-1:0] wmask;
-  input  [ui_data_width_p*ui_burst_length_lp-1:0] wdata;
+  input [ui_mask_width_lp*ui_burst_length_p-1:0] wmask;
+  input  [ui_data_width_p*ui_burst_length_p-1:0] wdata;
   integer i;
   begin
     app_wdf_wren <= 1'b1;
-    for(i=0;i<ui_burst_length_lp;i++) begin
+    for(i=0;i<ui_burst_length_p;i++) begin
       app_wdf_data <= wdata >> (ui_data_width_p * i);
       app_wdf_mask <= wmask >> (ui_mask_width_lp * i);
-      if(i==ui_burst_length_lp-1) app_wdf_end <= 1'b1;
+      if(i==ui_burst_length_p-1) app_wdf_end <= 1'b1;
       do @(posedge ui_clk); while(!app_wdf_rdy);
     end
     app_wdf_wren <= 1'b0;
diff --git a/testing/bsg_dmc/testbench.v b/testing/bsg_dmc/testbench.v
index 7cf59416..974c6a5c 100644
--- a/testing/bsg_dmc/testbench.v
+++ b/testing/bsg_dmc/testbench.v
@@ -1,15 +1,19 @@
+`define WRITE 3'b000
+`define READ  3'b001
 
-module testbench();
+`include "bsg_dmc.vh"
+
+module testbench
   import bsg_tag_pkg::*;
   import bsg_dmc_pkg::*;
- 
+  ();
   parameter clk_gen_num_adgs_p = 1;
   parameter ui_addr_width_p    = 28;
-  parameter ui_data_width_p    = 32;
+  parameter ui_data_width_p    = 64;
   parameter ui_burst_length_p  = 8;
   parameter dq_data_width_p    = 32;
-  parameter cmd_afifo_depth_p  = 6;
-  parameter cmd_sfifo_depth_p  = 6;
+  parameter cmd_afifo_depth_p  = 4;
+  parameter cmd_sfifo_depth_p  = 4;
   parameter debug_p            = 1'b1;
 
   localparam burst_data_width_lp = ui_data_width_p * ui_burst_length_p;
@@ -21,16 +25,14 @@ module testbench();
 
   integer j,k;
 
-  bsg_dmc_s                        dmc_p;
+  wire bsg_tag_s        dmc_reset_tag_lines_lo;
+  wire bsg_tag_s  [3:0] dmc_dly_tag_lines_lo;
+  wire bsg_tag_s  [3:0] dmc_dly_trigger_tag_lines_lo;
+  wire bsg_tag_s        dmc_ds_tag_lines_lo;
 
-  logic							   stall_transactions_lo;
-  logic							   transaction_in_progress_lo;
-  logic							   test_mode_lo;
-  logic							   refresh_in_progress_lo;
+  bsg_dmc_s                        dmc_p;
 
   logic                            sys_reset;
-  logic							   clock_monitor_clk_lo;
-
   // User interface signals
   logic      [ui_addr_width_p-1:0] app_addr;
   app_cmd_e                        app_cmd;
@@ -54,13 +56,11 @@ module testbench();
   wire                             app_sr_active;
   // Status signal
   wire                             init_calib_complete;
-  logic							   frequency_mismatch_lo;
 
   logic                            ui_clk;
-  wire                             ui_clk_sync_rst;
-
   logic                            dfi_clk_2x;
-  logic                            dfi_clk_1x;
+  wire                             dfi_clk_1x;
+  wire                             ui_clk_sync_rst;
 
   wire                      [11:0] device_temp;
 
@@ -95,58 +95,53 @@ module testbench();
   wire  [(dq_data_width_p>>3)-1:0] ddr_dqs_n;
   wire       [dq_data_width_p-1:0] ddr_dq;
 
-  // All tag lines from the btm
-  localparam tag_dmc_local_els_lp = tag_dmc_dly_local_els_gp+tag_dmc_cfg_local_els_gp+tag_dmc_sys_local_els_gp+tag_dmc_osc_local_els_gp;
-  bsg_tag_s [tag_dmc_local_els_lp-1:0] tag_lines_lo;
-
-  logic send_dynamic_tag, irritate_clock, clock_correction_done_lo;
-
-  traffic_generator #
-    (.num_adgs_p         ( clk_gen_num_adgs_p  )
-    ,.ui_addr_width_p    ( ui_addr_width_p     )
-    ,.ui_data_width_p    ( ui_data_width_p     )
-    ,.burst_data_width_p ( burst_data_width_lp )
-    ,.dq_data_width_p    ( dq_data_width_p     )
-    ,.cmd_afifo_depth_p  ( cmd_afifo_depth_p   )
-    ,.cmd_sfifo_depth_p  ( cmd_sfifo_depth_p   ))
-    // Tag lines
-  traffic_generator_inst
-    // Global asynchronous reset input, will be synchronized to each clock domain
-    // Consistent with the reset signal defined in Xilinx UI interface
-    // User interface signals
-    (.app_addr_o            ( app_addr            )
-    ,.app_cmd_o             ( app_cmd             )
-    ,.app_en_o              ( app_en              )
-    ,.app_rdy_i             ( app_rdy             )
-    ,.app_wdf_wren_o        ( app_wdf_wren        )
-    ,.app_wdf_data_o        ( app_wdf_data        )
-    ,.app_wdf_mask_o        ( app_wdf_mask        )
-    ,.app_wdf_end_o         ( app_wdf_end         )
-    ,.app_wdf_rdy_i         ( app_wdf_rdy         )
-    ,.app_rd_data_valid_i   ( app_rd_data_valid   )
-    ,.app_rd_data_i         ( app_rd_data         )
-    ,.app_rd_data_end_i     ( app_rd_data_end     )
-    // Reserved to be compatible with Xilinx IPs
-    ,.app_ref_req_o         ( app_ref_req         )
-    ,.app_ref_ack_i         ( app_ref_ack         )
-    ,.app_zq_req_o          ( app_zq_req          )
-    ,.app_zq_ack_i          ( app_zq_ack          )
-    ,.app_sr_req_o          ( app_sr_req          )
-    ,.app_sr_active_i       ( app_sr_active       )
-    // Status signal
-    ,.init_calib_complete_i ( init_calib_complete )
-    ,.ui_clk_o              ( ui_clk              )
-    ,.ui_clk_sync_rst_i     ( ui_clk_sync_rst     )
-    ,.dfi_clk_o             ( dfi_clk              )
-	,.tag_lines_o			(tag_lines_lo)
-	,.stall_trace_reading_i (send_dynamic_tag)
-	,.irritate_clock_i		(irritate_clock)
-	,.refresh_in_progress_i (refresh_in_progress_lo)
-	,.clock_monitor_clk_i	(clock_monitor_clk_lo)
-	,.frequency_mismatch_o	(frequency_mismatch_lo)
-	,.clock_correction_done_o(clock_correction_done_lo)
-	);
+  logic [burst_data_width_lp-1] wdata_array[integer];
+  logic [ui_addr_width_p] waddr_queue, raddr_queue[$];
+  logic [ui_addr_width_p] waddr, raddr;
+  logic [burst_data_width_lp-1] wdata, rdata;
+
+  wire [ui_burst_length_p-1:0] sipo_valid_lo;
+  wire [ui_burst_length_p-1:0][ui_data_width_p-1:0] sipo_data_lo;
+  wire [$clog2(ui_burst_length_p):0] sipo_yumi_cnt_li;
+  wire [burst_data_width_lp-1:0] sipo_data;
+
+  logic [ui_addr_width_p] rx_addr;
+  logic [burst_data_width_lp-1:0] tx_data, rx_data;
 
+  integer read_transactions;
+
+`include "tasks.v"
+
+  initial begin
+    dmc_p.trefi = 1023;
+    dmc_p.tmrd = 1;
+    dmc_p.trfc = 15;
+    dmc_p.trc = 10;
+    dmc_p.trp = 2;
+    dmc_p.tras = 7;
+    dmc_p.trrd = 1;
+    dmc_p.trcd = 2;
+    dmc_p.twr = 10;
+    dmc_p.twtr = 7;
+    dmc_p.trtp = 10;
+    dmc_p.tcas = 3;
+    dmc_p.col_width = 11;
+    dmc_p.row_width = 14;
+    dmc_p.bank_width = 2;
+    dmc_p.dqs_sel_cal = 3;
+    dmc_p.init_cycles = 40010;
+    dmc_p.bank_pos = 25;
+    force dmc_inst.dmc_clk_rst_gen.btc_async_reset.tag_data_reg.data_r = 0;
+    force dmc_inst.dmc_clk_rst_gen.dly_lines[0].dly_line_inst.ctrl_rrr = 31;
+    force dmc_inst.dmc_clk_rst_gen.dly_lines[1].dly_line_inst.ctrl_rrr = 31;
+    force dmc_inst.dmc_clk_rst_gen.dly_lines[2].dly_line_inst.ctrl_rrr = 31;
+    force dmc_inst.dmc_clk_rst_gen.dly_lines[3].dly_line_inst.ctrl_rrr = 31;
+    force dmc_inst.dmc_clk_rst_gen.clk_gen_ds_inst.reset_i = 1'b1;
+    force dmc_inst.dmc_clk_rst_gen.clk_gen_ds_inst.strobe_r = 1'b0;
+    #100;
+    force dmc_inst.dmc_clk_rst_gen.clk_gen_ds_inst.reset_i = 1'b0;
+    force dmc_inst.dmc_clk_rst_gen.clk_gen_ds_inst.strobe_r = 1'b1;
+  end
 
   bsg_dmc #
     (.num_adgs_p            ( clk_gen_num_adgs_p  )
@@ -157,12 +152,15 @@ module testbench();
     ,.cmd_afifo_depth_p     ( cmd_afifo_depth_p   )
     ,.cmd_sfifo_depth_p     ( cmd_sfifo_depth_p   ))
   dmc_inst
-    (
+    (.async_reset_tag_i     ( dmc_reset_tag_lines_lo       )
+    ,.bsg_dly_tag_i         ( dmc_dly_tag_lines_lo         )
+    ,.bsg_dly_trigger_tag_i ( dmc_dly_trigger_tag_lines_lo )
+    ,.bsg_ds_tag_i          ( dmc_ds_tag_lines_lo          )
+
+    ,.dmc_p_i               ( dmc_p               )
+
+    ,.sys_reset_i           ( sys_reset           )
 
-	.dly_tag_lines_i       (tag_lines_lo[0+:tag_dmc_dly_local_els_gp] )
-	,.cfg_tag_lines_i      (tag_lines_lo[tag_dmc_dly_local_els_gp+:tag_dmc_cfg_local_els_gp] )
-	,.sys_tag_lines_i      (tag_lines_lo[tag_dmc_dly_local_els_gp+tag_dmc_cfg_local_els_gp+:tag_dmc_sys_local_els_gp] )
-	,.osc_tag_lines_i      (tag_lines_lo[tag_dmc_dly_local_els_gp+tag_dmc_cfg_local_els_gp+tag_dmc_sys_local_els_gp+:tag_dmc_osc_local_els_gp] )
     ,.app_addr_i            ( app_addr            )
     ,.app_cmd_i             ( app_cmd             )
     ,.app_en_i              ( app_en              )
@@ -175,18 +173,14 @@ module testbench();
     ,.app_rd_data_valid_o   ( app_rd_data_valid   )
     ,.app_rd_data_o         ( app_rd_data         )
     ,.app_rd_data_end_o     ( app_rd_data_end     )
-    ,.app_ref_req_i         ( app_ref_req         )
+    ,.app_ref_req_i         ( 1'b0                )
     ,.app_ref_ack_o         ( app_ref_ack         )
-    ,.app_zq_req_i          ( app_zq_req          )
+    ,.app_zq_req_i          ( 1'b0                )
     ,.app_zq_ack_o          ( app_zq_ack          )
-    ,.app_sr_req_i          ( app_sr_req          )
+    ,.app_sr_req_i          ( 1'b0                )
     ,.app_sr_active_o       ( app_sr_active       )
 
     ,.init_calib_complete_o ( init_calib_complete )
-	,.stall_transactions_o(stall_transactions_lo)
-	,.transaction_in_progress_o(transaction_in_progress_lo)
-	,.test_mode_o(test_mode_lo)
-	,.refresh_in_progress_o(refresh_in_progress_lo)
 
     ,.ddr_ck_p_o            ( ddr_ck_p            )
     ,.ddr_ck_n_o            ( ddr_ck_n            )
@@ -215,21 +209,10 @@ module testbench();
     ,.ddr_dq_i              ( ddr_dq_li           )
 
     ,.ui_clk_i              ( ui_clk              )
-    ,.ui_clk_sync_rst_o     ( ui_clk_sync_rst     )
-    ,.device_temp_o         ( device_temp         )
-    ,.ext_dfi_clk_2x_i      ( dfi_clk             )
+    ,.dfi_clk_2x_i          ( dfi_clk_2x          )
     ,.dfi_clk_1x_o          ( dfi_clk_1x          )
-    ,.dfi_clk_2x_o          ( dfi_clk_2x          ));
-
-  bsg_counter_clock_downsample #
-    (.width_p  ( 2 )
-    ,.harden_p ( 1 ))
-  clk_monitor_clk_gen
-    (.clk_i   ( dfi_clk_2x               )
-    ,.reset_i ( ui_clk_sync_rst          )
-    ,.val_i   ( 2'b01 )
-    ,.clk_r_o (clock_monitor_clk_lo	   ));
-
+    ,.ui_clk_sync_rst_o     ( ui_clk_sync_rst     )
+    ,.device_temp_o         ( device_temp         ));
 
   generate
     for(i=0;i<dq_group_lp;i++) begin: dm_io
@@ -265,18 +248,80 @@ module testbench();
     end
   endgenerate
 
+  always #1.25 dfi_clk_2x = ~dfi_clk_2x;
+  //always #0.625 ui_clk = ~ui_clk;
+  always #2.5 ui_clk = ~ui_clk;
+
   initial begin
-	  irritate_clock = 0;
-      send_dynamic_tag = 0;
-	  if($test$plusargs("irritate_clk")) begin
-      	#212us;
-	  	irritate_clock = 1;
-	  	#0.5us;
-	  	irritate_clock = 0;
-	  	@(frequency_mismatch_lo);
-      	send_dynamic_tag = 1;
-	  	@(clock_correction_done_lo);
-	  	send_dynamic_tag = 0;
-	 end
+    //$vcdplusmemon();
+    app_en = 0;
+    app_wdf_wren = 0;
+    app_wdf_end = 0;
   end
+
+  initial begin
+    $display("\n#### Regression test started ####");
+    sys_reset = 1'b1;
+    ui_clk = 1'b0;
+    dfi_clk_2x = 1'b0;
+    #1000 sys_reset=1'b0;
+    repeat(100) @(posedge ui_clk);
+    for(k=0;k<256;k++) begin
+      waddr = k*dq_burst_length_lp;
+      wdata = 0;
+      for(j=0;j<ui_burst_length_p;j++)
+        wdata = (wdata << ui_data_width_p) + waddr + j;
+      wdata_array[waddr] = wdata;
+      $display("Time: %8d ns, Write %x to %x", $time(), wdata, waddr);
+      fork
+        ui_cmd(`WRITE, waddr);
+        ui_write(0, wdata);
+      join
+    end
+    for(k=0;k<256;k++) begin
+      raddr = k*dq_burst_length_lp;
+      raddr_queue.push_front(raddr);
+      ui_cmd(`READ, raddr);
+    end
+    repeat(1000) @(posedge ui_clk);
+    $display("\nRegression test passed!");
+    $display("\n#### Regression test ended ####");
+    $finish();
+  end
+
+  for(i=0;i<ui_burst_length_p;i++) begin
+    assign sipo_data[ui_data_width_p*i+:ui_data_width_p] = sipo_data_lo[i];
+  end
+
+  bsg_serial_in_parallel_out #
+    (.width_p    ( ui_data_width_p   )
+    ,.els_p      ( ui_burst_length_p ))
+  sipo
+    (.clk_i      ( ui_clk            )
+    ,.reset_i    ( ui_clk_sync_rst   )
+    ,.valid_i    ( app_rd_data_valid )
+    ,.data_i     ( app_rd_data       )
+    ,.ready_o    (                   ) 
+    ,.valid_o    ( sipo_valid_lo     )
+    ,.data_o     ( sipo_data_lo      )
+    ,.yumi_cnt_i ( sipo_yumi_cnt_li  ));
+
+  assign sipo_yumi_cnt_li = ($clog2(ui_burst_length_p)+1)'(&sipo_valid_lo? ui_burst_length_p: 0);
+
+  always @(posedge ui_clk) begin
+    if(&sipo_valid_lo) begin
+      read_transactions = read_transactions + 1;
+      rx_addr = raddr_queue.pop_back();
+      tx_data = wdata_array[rx_addr];
+      rx_data = sipo_data;
+      $display("Time: %8d ns, Read %x from %x", $time(), rx_data, rx_addr);
+      if(tx_data != rx_data) begin
+        $display("Error: Data expected to be %x, but %x received", tx_data, rx_data);
+        $display("\nRegression test failed!");
+        $finish();
+      end
+    end
+  end
+
 endmodule
+
diff --git a/testing/bsg_dmc/traffic_generator.v b/testing/bsg_dmc/traffic_generator.v
deleted file mode 100644
index 48982c72..00000000
--- a/testing/bsg_dmc/traffic_generator.v
+++ /dev/null
@@ -1,655 +0,0 @@
-`include "bsg_defines.v"
-`include "bsg_dmc.vh"
-
-`ifndef UI_CLK_PERIOD
-  `define UI_CLK_PERIOD 2500.0
-`endif
-
-`ifndef DFI_CLK_PERIOD
-  `define DFI_CLK_PERIOD 1250.0
-`endif
-
-`ifndef TAG_CLK_PERIOD
-  `define TAG_CLK_PERIOD 10000.0
-`endif
-
-`ifndef LINK_IO_CLK_PERIOD
-  `define LINK_IO_CLK_PERIOD 1000.0
-`endif
-
-`ifndef FPGA_CLK_PERIOD
-  `define FPGA_CLK_PERIOD 2500.0
-`endif
-
-module traffic_generator
-  import bsg_tag_pkg::*;
-  import bsg_dmc_pkg::*;
- #(parameter  num_adgs_p         = 1
-  ,parameter `BSG_INV_PARAM(ui_addr_width_p)
-  ,parameter `BSG_INV_PARAM(ui_data_width_p) // data width of UI interface, can be 2^n while n = [3, log2(burst_data_width_p)]
-  ,parameter `BSG_INV_PARAM(burst_data_width_p) // data width of an outstanding read/write transaction, typically data width of a cache line
-  ,parameter `BSG_INV_PARAM( dq_data_width_p) // data width of DDR interface, consistent with packaging
-  ,parameter `BSG_INV_PARAM(cmd_afifo_depth_p) // maximum number of outstanding read/write transactions can be queued when the controller is busy
-  ,parameter `BSG_INV_PARAM(cmd_sfifo_depth_p) // maximum number of DRAM commands can be queued when the DDR interface is busy, no less than cmd_afifo_depth_p
-  , parameter ui_cmd_width_p	 = 4
-  ,localparam ui_mask_width_lp   = ui_data_width_p >> 3
-  ,localparam dfi_data_width_lp  = dq_data_width_p << 1
-  ,localparam dfi_mask_width_lp  = (dq_data_width_p >> 3) << 1
-  ,localparam dq_group_lp        = dq_data_width_p >> 3
-  ,localparam ui_burst_length_lp = burst_data_width_p / ui_data_width_p
-  ,localparam dq_burst_length_lp = burst_data_width_p / dq_data_width_p
-  ,localparam payload_width_lp 	 = `bsg_dmc_trace_entry_width(ui_data_width_p, ui_addr_width_p)
-  ,localparam tag_dmc_local_els_lp = tag_dmc_dly_local_els_gp+tag_dmc_cfg_local_els_gp+tag_dmc_sys_local_els_gp+tag_dmc_osc_local_els_gp
-  )
-  // Tag lines
-  (output  bsg_tag_s [tag_dmc_local_els_lp-1:0]	tag_lines_o
-  //
-  // Global asynchronous reset input, will be synchronized to each clock domain
-  // Consistent with the reset signal defined in Xilinx UI interface
-  // User interface signals
-  ,output       [ui_addr_width_p-1:0] app_addr_o
-  ,output app_cmd_e                   app_cmd_o
-  ,output                             app_en_o
-  ,input                              app_rdy_i
-  ,output                             app_wdf_wren_o
-  ,output       [ui_data_width_p-1:0] app_wdf_data_o
-  ,output      [ui_mask_width_lp-1:0] app_wdf_mask_o
-  ,output                             app_wdf_end_o
-  ,input                              app_wdf_rdy_i
-  ,input                              app_rd_data_valid_i
-  ,input        [ui_data_width_p-1:0] app_rd_data_i
-  ,input                              app_rd_data_end_i
-  // Reserved to be compatible with Xilinx IPs
-  ,output                             app_ref_req_o
-  ,input                              app_ref_ack_i
-  ,output                             app_zq_req_o
-  ,input                              app_zq_ack_i
-  ,output                             app_sr_req_o
-  ,input                              app_sr_active_i
-  // Status signal
-  ,input                              init_calib_complete_i
-  ,input							  stall_trace_reading_i
-  //
-  ,output                             ui_clk_o
-  //
-  ,input                              ui_clk_sync_rst_i
-  ,output                             dfi_clk_o
-  ,input							  irritate_clock_i
-  ,input							  refresh_in_progress_i
-  ,input							  clock_monitor_clk_i
-  ,output							  frequency_mismatch_o
-  ,output							  clock_correction_done_o
-  );
-
-  // Total number of clients the master will be driving.
-  localparam tag_num_clients_gp = tag_dmc_local_els_lp;
-  // The number of bits required to represent the max payload width
-  localparam tag_max_payload_width_gp = 8;
-  localparam tag_lg_max_payload_width_gp = `BSG_SAFE_CLOG2(tag_max_payload_width_gp + 1);
-
-  logic ui_clk;
-
-  assign ui_clk_o = ui_clk;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`UI_CLK_PERIOD)) ui_clk_gen (.o(ui_clk));
-	
-  logic dfi_clk;
-
-  assign dfi_clk_o = dfi_clk;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`DFI_CLK_PERIOD)) dfi_clk_gen (.o(dfi_clk));
-
-  logic fpga_link_clk;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`FPGA_CLK_PERIOD)) fpga_link_clk_gen (.o(fpga_link_clk));
-
-  logic fpga_link_io_clk_li;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`LINK_IO_CLK_PERIOD)) fpga_link_io_clk_gen (.o(fpga_link_io_clk_li));
-
-  logic asic_link_io_clk;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`LINK_IO_CLK_PERIOD)) asic_link_io_clk_gen (.o(asic_link_io_clk));
-
-  logic tag_clk;
-  bsg_nonsynth_clock_gen #(.cycle_time_p(`TAG_CLK_PERIOD)) tag_clk_gen (.o(tag_clk));
-
-  //////////////////////////////////////////////////
-  //
-  // BSG Tag Trace Replay
-  //
-  localparam tag_trace_rom_addr_width_lp = 32;
-  localparam tag_trace_rom_data_width_lp = 23;
-
-  logic [tag_trace_rom_addr_width_lp-1:0] rom_addr_li;
-  logic [tag_trace_rom_data_width_lp-1:0] rom_data_lo;
-
-  logic tag_trace_en_r_lo;
-  logic tag_trace_done_lo;
-
-  logic en_trace_reading_li;
-
-  // TAG TRACE ROM
-  bsg_tag_boot_rom #(.width_p( tag_trace_rom_data_width_lp )
-                    ,.addr_width_p( tag_trace_rom_addr_width_lp )
-                    )
-    tag_trace_rom
-      (.addr_i( rom_addr_li )
-      ,.data_o( rom_data_lo )
-      );
-
-  logic tag_reset;
-  bsg_nonsynth_reset_gen #(.num_clocks_p(1),.reset_cycles_lo_p(10),.reset_cycles_hi_p(5))
-    tag_reset_gen
-      (.clk_i(tag_clk)
-      ,.async_reset_o(tag_reset)
-      );
-	
-
-  assign en_trace_reading_li = init_calib_complete_i & tag_trace_done_lo & (~stall_trace_reading_i);
-
-  wire tag_trace_valid_lo;
-
-  // TAG TRACE REPLAY
-  bsg_tag_trace_replay #(.rom_addr_width_p( tag_trace_rom_addr_width_lp )
-                        ,.rom_data_width_p( tag_trace_rom_data_width_lp )
-                        ,.num_masters_p( 1 )
-                        ,.num_clients_p( tag_num_clients_gp )
-                        ,.max_payload_width_p( tag_max_payload_width_gp )
-                        )
-    tag_trace_replay
-      (.clk_i   ( tag_clk )
-      ,.reset_i ( tag_reset    )
-      ,.en_i    ( 1'b1            )
-      ,.rom_addr_o( rom_addr_li )
-      ,.rom_data_i( rom_data_lo )
-
-      ,.valid_i ( 1'b0 )
-      ,.data_i  ( '0 )
-      ,.ready_o ()
-
-      ,.valid_o    ( tag_trace_valid_lo )
-      ,.en_r_o     ( tag_trace_en_r_lo )
-      ,.tag_data_o ( bsg_tag_data )
-      ,.yumi_i     ( tag_trace_valid_lo )
-
-      ,.done_o  ( tag_trace_done_lo )
-      ,.error_o ()
-      ) ;
-
-  //////////////////////////////////////////////////
-  //
-  // BSG Tag Master Instance (Copied from ASIC)
-  //
-
-  // All tag lines from the btm
-
-  logic tag_master_data_li;
-  logic [6:0] clock_update_tag_index, wrong_clock_tag_index;
-  logic [4:0] stall_transmission_tag_index, re_enable_transmission_tag_index;
-
-  logic update_clock_freq;
-  assign update_clock_freq = stall_trace_reading_i & ~(refresh_in_progress_i);
-
-  logic [20:0] stall_dmc_tag_reg;
-  logic [20:0] no_stall_dmc_tag_reg;
-
-  logic [20:0] clock_period_tag_reg;
-  logic [20:0] clock_period_change_set_tag_reg;
-  logic [20:0] clock_period_change_reset_tag_reg;  
-  logic [62:0] tag_data_clock_period_and_trigger;
-
-  logic [20:0] wrong_clock_period_tag_reg;
-  logic [62:0] tag_data_wrong_clk_period_and_trigger;
-
-  logic clock_correction_done;
-  assign clock_correction_done_o = (re_enable_transmission_tag_index > 20);
-
-  //Tag format: {2'b0, 8'1 (tag data), 5'<client_id>, 1'<data_or_reset>, 4'<payload_length>, 1'b1}
-  assign stall_dmc_tag_reg = 21'b00_00000001_10111_1_1000_1;
-  assign no_stall_dmc_tag_reg = 21'b00_00000000_10111_1_1000_1;
-
-  assign clock_period_tag_reg = 21'b00_00011011_11001_1_0101_1;
-  assign clock_period_change_set_tag_reg = 21'b00_00000001_11010_1_0001_1;
-  assign clock_period_change_reset_tag_reg = 21'b00_00000000_11010_1_0001_1;
-  
-  assign tag_data_clock_period_and_trigger = {clock_period_change_reset_tag_reg, clock_period_change_set_tag_reg, clock_period_tag_reg};
-
-  assign wrong_clock_period_tag_reg = 21'b00_00011000_11001_1_0101_1;
-  assign tag_data_wrong_clk_period_and_trigger = {clock_period_change_reset_tag_reg, clock_period_change_set_tag_reg, wrong_clock_period_tag_reg};
-
-  always_comb begin
-	 if(tag_trace_done_lo && irritate_clock_i &&  (wrong_clock_tag_index <=61 )) begin
-		 tag_master_data_li = tag_data_wrong_clk_period_and_trigger[wrong_clock_tag_index];
-	 end
-     else if(tag_trace_done_lo && stall_trace_reading_i && (stall_transmission_tag_index <=19)) begin
-   	  	tag_master_data_li = stall_dmc_tag_reg[stall_transmission_tag_index];
-     end
-	 else if(tag_trace_done_lo && update_clock_freq && (clock_update_tag_index <= 61 )) begin
-		 tag_master_data_li = tag_data_clock_period_and_trigger[clock_update_tag_index];
-	 end
-	 else if(stall_trace_reading_i && (re_enable_transmission_tag_index <= 20)) begin
-		 tag_master_data_li = no_stall_dmc_tag_reg[re_enable_transmission_tag_index];		
-	 end
-     else if(tag_trace_valid_lo) begin
-   	  	tag_master_data_li = bsg_tag_data;
-     end
-     else begin
-     	tag_master_data_li = 0;
-     end
-  end
-
-  always @(posedge tag_clk) begin
-      if(tag_reset) begin
-		  stall_transmission_tag_index <= 0;
-		  clock_update_tag_index <= 0;
-		  wrong_clock_tag_index <= 0;
-		  re_enable_transmission_tag_index <= 0;
-      end
-      else if (stall_trace_reading_i && (stall_transmission_tag_index <= 19)) begin
-    	  stall_transmission_tag_index <= stall_transmission_tag_index + 1;
-      end
-	  else if (update_clock_freq && (clock_update_tag_index <= 61)) begin
-    	 clock_update_tag_index  <= clock_update_tag_index + 1;
-      end
-	  else if (stall_trace_reading_i && (re_enable_transmission_tag_index <= 20)) begin
-		re_enable_transmission_tag_index <= re_enable_transmission_tag_index + 1;
-	  end
-	  else if (irritate_clock_i && (wrong_clock_tag_index <= 61)) begin
-    	 wrong_clock_tag_index  <= wrong_clock_tag_index + 1;
-      end
-  end
-
-  bsg_nonsynth_dmc_clock_monitor
-	#(.max_fpga_count(10)
-	  ,.expected_ddr_period_ns_p(10)
-	  ,.fpga_clk_period_ns_p(10)
-	)	
-	ddr_clock_mon
-	(	.fpga_clk(tag_clk)
-		,.fpga_reset(ui_clk_sync_rst_i)
-		,.ddr_clk_i(clock_monitor_clk_i)
-		,.frequency_mismatch_o(frequency_mismatch_o)
-	);
-
-  // BSG tag master instance
-  bsg_tag_master #(.els_p( tag_dmc_local_els_lp )
-                  ,.lg_width_p( tag_lg_max_payload_width_gp )
-                  )
-    btm
-      (.clk_i      ( tag_clk )
-      ,.data_i     ( tag_master_data_li )
-      ,.en_i       ( 1'b1 )
-      ,.clients_r_o( tag_lines_o )
-      );
-
-  logic     [ui_addr_width_p-1:0]  app_addr;
-  app_cmd_e                        app_cmd;
-  logic                            app_en;
-  wire                             app_rdy;
-  logic                            app_wdf_wren;
-  logic      [ui_data_width_p-1:0] app_wdf_data;
-  logic [(ui_data_width_p>>3)-1:0] app_wdf_mask;
-  logic                            app_wdf_end;
-  wire                             app_wdf_rdy;
-
-  wire                             app_rd_data_valid;
-  wire       [ui_data_width_p-1:0] app_rd_data;
-  wire                             app_rd_data_end;
-
-  logic [burst_data_width_p-1] wdata_array[integer];
-  logic [ui_addr_width_p] waddr_queue, raddr_queue[$];
-  logic [ui_addr_width_p] waddr, raddr;
-  logic [burst_data_width_p-1] wdata, rdata;
-
-  wire [ui_burst_length_lp-1:0] sipo_valid_lo;
-  wire [ui_burst_length_lp-1:0][ui_data_width_p-1:0] sipo_data_lo;
-  wire [$clog2(ui_burst_length_lp):0] sipo_yumi_cnt_li;
-  wire [burst_data_width_p-1:0] sipo_data;
-
-  logic [ui_addr_width_p] rx_addr;
-  logic [burst_data_width_p-1:0] tx_data, rx_data;
-
-  genvar i;
-  int read_transactions;
-  int j,k;
-
-`ifdef NONSYNTH_TB
-	// non-synthesisable testing
-	`include "tasks.v"
-
-  	  initial begin
-  	      //$vcdplusmemon();
-  	      app_en = 0;
-  	      app_wdf_wren = 0;
-  	      app_wdf_end = 0;
-  	  end
-
-	  initial begin
-	    $display("\n#### Regression test started ####");
-	    @(posedge tag_trace_done_lo);
-	    repeat(100) @(posedge ui_clk);
-	    for(k=0;k<256;k++) begin
-	      waddr = k*dq_burst_length_lp;
-	      wdata = 0;
-	      for(j=0;j<ui_burst_length_lp;j++)
-	        wdata = (wdata << ui_data_width_p) + waddr + j;
-	      wdata_array[waddr] = wdata;
-	      $display("Time: %8d ns, Write %x to %x", $time(), wdata, waddr);
-	      fork
-	        ui_cmd(WR, waddr);
-	        ui_write(0, wdata);
-	      join
-	    end
-	    for(k=0;k<256;k++) begin
-	      raddr = k*dq_burst_length_lp;
-	      raddr_queue.push_front(raddr);
-	      ui_cmd(RD, raddr);
-	    end
-	    repeat(1000) @(posedge ui_clk);
-	    $display("\nRegression test passed!");
-	    $display("\n#### Regression test ended ####");
-	    $finish();
-	  end
-	
-	  for(i=0;i<ui_burst_length_lp;i++) begin
-	    assign sipo_data[ui_data_width_p*i+:ui_data_width_p] = sipo_data_lo[i];
-	  end
-	
-	  bsg_serial_in_parallel_out #
-	    (.width_p    ( ui_data_width_p    )
-	    ,.els_p      ( ui_burst_length_lp ))
-	  sipo
-	    (.clk_i      ( ui_clk            )
-	    ,.reset_i    ( ui_clk_sync_rst_i )
-	    ,.valid_i    ( app_rd_data_valid )
-	    ,.data_i     ( app_rd_data       )
-	    ,.ready_o    (                   )
-	    ,.valid_o    ( sipo_valid_lo     )
-	    ,.data_o     ( sipo_data_lo      )
-	    ,.yumi_cnt_i ( sipo_yumi_cnt_li  ));
-	
-	  assign sipo_yumi_cnt_li = ($clog2(ui_burst_length_lp)+1)'(&sipo_valid_lo? ui_burst_length_lp: 0);
-	
-	  always @(posedge ui_clk) begin
-	    if(&sipo_valid_lo) begin
-	      read_transactions = read_transactions + 1;
-	      rx_addr = raddr_queue.pop_back();
-	      tx_data = wdata_array[rx_addr];
-	      rx_data = sipo_data;
-	      $display("Time: %8d ns, Read %x from %x", $time(), rx_data, rx_addr);
-	      if(tx_data != rx_data) begin
-	        $display("Error: Data expected to be %x, but %x received", tx_data, rx_data);
-	        $display("\nRegression test failed!");
-	        $finish();
-	      end
-	    end
-	  end
-`else
-	
-	// Synthesisable testing below:
-	// Topology:
-	// * BSG TRACE ROM contains command, address, write data and write mask
-	// * BSG TRACE REPLAY used to 
-	// 		** read TRACE ROM and transmit cmd, addr, write data mask forward
-	// 		** receive read data from DMC and compare with data that was already written to that address
-	// * FPGA SIDE DDR LINKS:
-	// 		** BSG DDR UPSTREAM LINK to tranmsit command, address, write data and write mask to ASIC
-	// 		** BSG DDR DOWNSTREAM LINK to get read data from ASIC
-	// * ASIC SIDE DDR LINKS:
-	// 		** BSG DDR DOWNSTREAM LINK to tranmsit command, address, write data and write mask to DMC
-	// 		** BSG DDR UPSTREAM LINK to pass read data from DMC to FPGA
-	// * STORE FORWARD FIFO to collect command, address, write data and write mask from DDR LINK and forward
-	// * TRACE TO DMC UI ADAPTER to convert :
-	// 		** trace packet to XILINX UI command and write interfaces
-	// 		** XILINX UI interface read interface signals to trace packet
-	// * BSG DRAM CONTROLLER
-	//
-	logic fpga_link_upstream_edge_clk_lo;
-	logic [payload_width_lp/2-1:0] fpga_link_upstream_edge_data_lo;
-	logic fpga_link_upstream_edge_valid_lo;
-
-	logic fpga_link_reset_li, asic_link_reset_li;
-  	logic fpga_link_upstream_io_reset_li, asic_link_downstream_io_reset;
-	logic fpga_link_downstream_io_reset_li, asic_link_upstream_io_reset;
-
-	logic fpga_link_token_reset_li, asic_link_token_reset_li;
-
-    // ASIC SIDE LINK SIGNALS
-  	logic [payload_width_lp/2-1:0] asic_link_downstream_edge_data;
-  	logic asic_link_downstream_edge_valid;
-  	logic asic_link_downstream_edge_token_li;
-  	logic asic_link_downstream_edge_clk;
-  	logic asic_link_downstream_core_ready_li;
-	logic asic_link_upstream_core_ready_lo;
-
-
-  	logic [payload_width_lp-1:0] asic_link_downstream_core_data_lo;
-  	logic asic_link_downstream_core_valid_lo;
-  	logic asic_link_downstream_core_yumi_lo;
-
-	logic [payload_width_lp-1:0] asic_link_upstream_core_data_li;
-  	logic asic_link_upstream_core_valid_li;
-  	logic asic_link_upstream_core_yumi_lo;
-
-	logic [payload_width_lp/2 - 1:0] asic_link_upstream_edge_data_li;
-	logic asic_link_upstream_edge_clk_li;
-	logic asic_link_upstream_edge_valid_li;
-	logic fpga_link_downstream_edge_token_li;
-
-  	// DMC input FIFO related signals
-  	logic [payload_width_lp - 1:0] dmc_adapter_input_data_lo;
-  	logic dmc_adapter_input_valid_lo;
-  	logic dmc_adapter_yumi_lo;
-  	logic dmc_input_fifo_ready_lo;	
-  	
-  	logic dmc_adapter_ready_lo;
-
-    logic trace_reading_done_lo;
-	// Whatever testing environment that goes into the FPGA: trace ROM, trace replay, FPGA side DDR upstream and downstream links
-	bsg_dmc_tester
-				#(	.data_width_p(ui_data_width_p),
-					.addr_width_p(ui_addr_width_p),
-					.burst_width_p(ui_burst_length_lp)
-				) dmc_tester
-				(	.fpga_link_clk_i(fpga_link_clk),
-					.fpga_link_io_clk_i(fpga_link_io_clk_li),
-					.fpga_link_reset_i(fpga_link_reset_li),
-					.fpga_link_upstream_io_reset_i(fpga_link_upstream_io_reset_li),
-					.fpga_link_downstream_io_reset_i(fpga_link_downstream_io_reset_li),
-					.fpga_link_token_reset_i(fpga_link_token_reset_li),
-					.fpga_link_upstream_edge_clk_o(fpga_link_upstream_edge_clk_lo),
-					.asic_link_downstream_edge_token_i(asic_link_downstream_edge_token_li),
-					.fpga_link_upstream_edge_data_o(fpga_link_upstream_edge_data_lo),
-					.fpga_link_upstream_edge_valid_o(fpga_link_upstream_edge_valid_lo),
-
-					.asic_link_upstream_edge_clk_i(asic_link_upstream_edge_clk_li),
-					.asic_link_upstream_edge_data_i(asic_link_upstream_edge_data_li),
-					.asic_link_upstream_edge_valid_i(asic_link_upstream_edge_valid_li),
-					.fpga_link_downstream_edge_token_o(fpga_link_downstream_edge_token_li),
-
-					.en_trace_reading_i(en_trace_reading_li),
-                    .trace_reading_done_o(trace_reading_done_lo)
-				);
-
-  	assign asic_link_downstream_core_yumi_lo = asic_link_downstream_core_valid_lo & dmc_input_fifo_ready_lo ;
-
-  	  // ASIC SIDE LINKS START
-  	bsg_link_ddr_downstream
-  					#(.width_p        (payload_width_lp)
-  					 ,.channel_width_p(payload_width_lp/2)
-  					 ,.num_channels_p (1)
-  					 ) asic_link_downstream
-  					 (.core_clk_i       (ui_clk)
-  					 ,.core_link_reset_i(asic_link_reset_li)
-  					 ,.io_link_reset_i  (asic_link_downstream_io_reset)
-  					 
-  					 ,.core_data_o   (asic_link_downstream_core_data_lo)
-  					 ,.core_valid_o  (asic_link_downstream_core_valid_lo)
-  					 ,.core_yumi_i   (asic_link_downstream_core_yumi_lo)
-  					
-  					 ,.io_clk_i      (fpga_link_upstream_edge_clk_lo)
-  					 ,.io_data_i     (fpga_link_upstream_edge_data_lo)
-  					 ,.io_valid_i    (fpga_link_upstream_edge_valid_lo)
-  					 ,.core_token_r_o(asic_link_downstream_edge_token_li)
-  					 );
-
-    logic read_data_to_consumer_valid_lo;
-	logic [payload_width_lp-1:0] read_data_to_consumer_lo;
-    logic [ui_data_width_p-1:0] rdata_from_adapter_lo;
-
-    assign read_data_to_consumer_lo = {{ui_mask_width_lp{1'b0}}, rdata_from_adapter_lo};
-
-    always@(posedge ui_clk) begin
-        if(asic_link_reset_li) begin
-            asic_link_upstream_core_valid_li <= 0;
-            asic_link_upstream_core_data_li <= 0; 
-        end
-        else if(read_data_to_consumer_valid_lo) begin
-            asic_link_upstream_core_valid_li <= 1;
-            asic_link_upstream_core_data_li <= read_data_to_consumer_lo;
-        end
-        else begin
-            asic_link_upstream_core_valid_li <= 0;
-        end
-    end
-
-	bsg_link_ddr_upstream
- 					#(.width_p        (payload_width_lp)
- 					 ,.channel_width_p(payload_width_lp/2)
- 					 ,.num_channels_p (1)
- 					 ) asic_link_upstream
- 					 (.core_clk_i         (ui_clk)
- 					 ,.io_clk_i           (asic_link_io_clk)
- 					 ,.core_link_reset_i  (asic_link_reset_li)
- 					 ,.io_link_reset_i    (asic_link_upstream_io_reset)
- 					 ,.async_token_reset_i(asic_link_token_reset_li)
- 					 
- 					 ,.core_data_i (asic_link_upstream_core_data_li)
- 					 ,.core_valid_i(asic_link_upstream_core_valid_li)
- 					 ,.core_ready_o(asic_link_upstream_core_ready_lo)
-
- 					 ,.io_clk_r_o  (asic_link_upstream_edge_clk_li)
- 					 ,.io_data_r_o (asic_link_upstream_edge_data_li)
- 					 ,.io_valid_r_o(asic_link_upstream_edge_valid_li)
- 					 ,.token_clk_i (fpga_link_downstream_edge_token_li)
- 					 );
-
-  	// ASIC SIDE LINKS END
-	assign dmc_adapter_yumi_lo = dmc_adapter_ready_lo & dmc_adapter_input_valid_lo;
-  	
-	// Trace packets going towards DMC
-  	bsg_fifo_1r1w_small 
-  						#(.width_p(payload_width_lp)
-  						,.els_p(10)
-  						) dmc_input_fifo
-  						(.clk_i  (ui_clk)
-  						,.reset_i(asic_link_reset_li)
-  						
-  						,.ready_o(dmc_input_fifo_ready_lo)
-  						,.data_i (asic_link_downstream_core_data_lo)
-  						,.v_i    (asic_link_downstream_core_valid_lo)
-  						
-  						,.v_o    (dmc_adapter_input_valid_lo)
-  						,.data_o (dmc_adapter_input_data_lo)
-  						,.yumi_i (dmc_adapter_yumi_lo)
-  						);
-
-	// Receive trace packet - convert it to XILINX UI command and write interface signals
-	// Receive read signals in XILINX UI interface and convert it to trace packet
-  	bsg_dmc_xilinx_ui_trace_replay
-  						#(	.data_width_p(ui_data_width_p),
-  							.addr_width_p(ui_addr_width_p),
-  							.burst_len_p(ui_burst_length_lp),
-                            // Arbitrary for now, just make sure the trace correlates
-                            .cmd_tfifo_depth_p(3*ui_burst_length_lp),
-                            .cmd_rfifo_depth_p(2*ui_burst_length_lp)
-  						) trace_to_dmc_ui
-  						(	.clk_i(ui_clk),
-  							.reset_i(ui_clk_sync_rst_i),
-							//.ui_clk_sync_rst_i(ui_clk_sync_rst_i),
-  							.data_i(dmc_adapter_input_data_lo),
-  						 	.v_i(dmc_adapter_input_valid_lo),
-
-							.v_o(read_data_to_consumer_valid_lo),
-							.data_o(rdata_from_adapter_lo),
-                            .yumi_i(asic_link_upstream_core_ready_lo & read_data_to_consumer_valid_lo),
-
-  						 	.ready_o(dmc_adapter_ready_lo),
-  	
-  						    // XILINX UI signals	
-  							.app_addr_o(app_addr),
-  							.app_cmd_o(app_cmd),
-  							.app_en_o(app_en),
-  							.app_rdy_i(app_rdy),
-  							.app_wdf_wren_o(app_wdf_wren),
-  							.app_wdf_data_o(app_wdf_data),
-  							.app_wdf_mask_o(app_wdf_mask),
-  							.app_wdf_end_o(app_wdf_end),
-  							.app_wdf_rdy_i(app_wdf_rdy),
-  							.app_rd_data_valid_i(app_rd_data_valid),
-  							.app_rd_data_i(app_rd_data),
-  							.app_rd_data_end_i(app_rd_data_end)
-  						 );
-	initial begin
-
-		fpga_link_reset_li = 1;
-		asic_link_reset_li = 1;
-
-		fpga_link_upstream_io_reset_li = 1;
-		asic_link_upstream_io_reset = 1;
-
-		#1000;
-
-		fpga_link_token_reset_li = 1;
-		asic_link_token_reset_li = 1;
-
-		#1000;
-
-		fpga_link_token_reset_li = 0;
-		asic_link_token_reset_li = 0;
-
-		#1000;
-
-		@(posedge fpga_link_io_clk_li); #1;
-  		  	fpga_link_upstream_io_reset_li = 0;
-
-		@(posedge asic_link_io_clk); #1;
-  		  	asic_link_upstream_io_reset = 0;
-
-		#100;
-
-		@(posedge fpga_link_upstream_edge_clk_lo); #1;
-  		  	asic_link_downstream_io_reset = 1;
-
-		@(posedge asic_link_upstream_edge_clk_li); #1;
-			fpga_link_downstream_io_reset_li = 1;
-
-		#1000;
-  	  	@(posedge fpga_link_upstream_edge_clk_lo); #1;
-  		  	asic_link_downstream_io_reset = 0;
-
-		@(posedge asic_link_upstream_edge_clk_li); #1;
-			fpga_link_downstream_io_reset_li = 0;
-
-		#1000;	
-  	  	// core link reset
-  	  	@(posedge fpga_link_clk); #1;
-  	  		fpga_link_reset_li = 0;
-		@(posedge ui_clk); #1;
-			asic_link_reset_li = 0;
-
-		@(posedge trace_reading_done_lo); #1000;
-		$finish();
-	end
-
-`endif
-
-  assign app_addr_o          = app_addr;
-  assign app_cmd_o           = app_cmd;
-  assign app_en_o            = app_en;
-  assign app_rdy             = app_rdy_i;
-  assign app_wdf_wren_o      = app_wdf_wren;
-  assign app_wdf_data_o      = app_wdf_data;
-  assign app_wdf_mask_o      = app_wdf_mask;
-  assign app_wdf_end_o       = app_wdf_end;
-  assign app_wdf_rdy         = app_wdf_rdy_i;
-  assign app_rd_data_valid   = app_rd_data_valid_i;
-  assign app_rd_data         = app_rd_data_i;
-  assign app_rd_data_end     = app_rd_data_end_i;
-endmodule
